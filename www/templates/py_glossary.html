{% extends 'c-word.html' %}

{% block title %} glossary - python {% endblock title %}

{% block point1 %}
<article contenteditable="true">
  <p>Category: python</p>
  <h1 id="blogTitle0">Python Glossary</h1><h5>&gt;&gt;&gt;</h5><p>交互式终端中默认的 Python 提示符，经常出现在和 Python 有关的代码样例（可以在 Python 解释器中以交互的方式被执行）中。</p><h5>...</h5><p></p><ul><li>交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内（圆括号、方括号、花括号或三重引号），或是指定一个装饰器之后。<br></li><li style="hyphens: auto; line-height: 20.8px;">The&nbsp;<a class="reference internal" href="https://docs.python.org/3.8/library/constants.html#Ellipsis" title="Ellipsis" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">Ellipsis</span></a>&nbsp;built-in constant.</li></ul><p></p><h5>abstract base class - 抽象基类</h5><p><span style="text-align: justify;">抽象基类简称 ABC，是对&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-duck-typing" style="text-align: justify;"><span class="xref std std-term">duck-typing</span></a><span style="text-align: justify;">&nbsp;的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#hasattr" title="hasattr" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">hasattr()</span></a><span style="text-align: justify;">&nbsp;显得过于笨拙或有微妙错误（例如使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#special-lookup" style="text-align: justify;"><span class="std std-ref">魔术方法</span></a><span style="text-align: justify;">）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" title="isinstance" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">isinstance()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" title="issubclass" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">issubclass()</span></a><span style="text-align: justify;">&nbsp;所认可；详见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">abc</span></a><span style="text-align: justify;">&nbsp;模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.abc</span></a><span style="text-align: justify;">&nbsp;模块中）、数字（在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">numbers</span></a><span style="text-align: justify;">&nbsp;模块中）、流（在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/io.html#module-io" title="io: Core tools for working with streams." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">io</span></a><span style="text-align: justify;">&nbsp;模块中）、导入查找器和加载器（在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">importlib.abc</span></a><span style="text-align: justify;">&nbsp;模块中）。你可以使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">abc</span></a><span style="text-align: justify;">&nbsp;模块来创建自己的 ABC。</span><br></p><h5>annotation - 标注</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">关联到某个变量、类属性、函数形参或返回值的标签，被约定作为&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-type-hint" style="">type hint</a>&nbsp;来使用。</p><div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">Annotations of local variables cannot be accessed at runtime, but annotations of global variables, class attributes, and functions are stored in the&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__annotations__</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;special attribute of modules, classes, and functions, respectively.</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">See&nbsp;<a class="reference internal" href="https://docs.python.org/3.8/glossary.html#term-variable-annotation" style="">variable annotation</a>,&nbsp;<a class="reference internal" href="https://docs.python.org/3.8/glossary.html#term-function-annotation" style="">function annotation</a>,&nbsp;<span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" style="">PEP 484</a>&nbsp;and&nbsp;<span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526" style="">PEP 526</a>, which describe this functionality.</p></div><h5>argument - 参数</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">在调用函数时传给&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-function" style="">function</a>（或&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-method" style="">method</a>&nbsp;）的值。参数分为两种：</p><ul style="margin-bottom: 10px; text-align: justify;"><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><b>关键字参数:</b> 在函数调用中前面带有标识符（例如&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">name=</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">）或者作为包含在前面带有</span>&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">**</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span>的字典里的值传入。举例来说，<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">3</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span>和&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">5</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span>在以下对&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#complex" title="complex" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">complex()</span></a>的调用中均属于关键字参数:</p><div class="highlight-python3 notranslate" style="position: relative;"><div class="highlight" style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><pre style="overflow-y: hidden; padding: 5px; line-height: 18.528px; border: 1px solid rgb(170, 204, 153);"><span class="nb" style="">complex</span><span class="p">(</span><span class="n">real</span><span class="o" style="">=</span><span class="mi" style="">3</span><span class="p">,</span> <span class="n">imag</span><span class="o" style="">=</span><span class="mi" style="">5</span><span class="p">)</span>
<span class="nb" style="">complex</span><span class="p">(</span><span class="o" style="">**</span><span class="p">{</span><span class="s1" style="">'real'</span><span class="p">:</span> <span class="mi" style="">3</span><span class="p">,</span> <span class="s1" style="">'imag'</span><span class="p">:</span> <span class="mi" style="">5</span><span class="p">})</span>
</pre></div></div></li><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><b>位置参数: </b>不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">*</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span>的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-iterable" style="">iterable</a>&nbsp;里的元素被传入。举例来说，<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">3</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span>和&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">5</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">在以下调用中均属于位置参数:</span></p><div class="highlight-python3 notranslate" style="position: relative;"><div class="highlight" style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><pre style="overflow-y: hidden; padding: 5px; line-height: 18.528px; border: 1px solid rgb(170, 204, 153);"><span class="nb" style="">complex</span><span class="p" style="">(</span><span class="mi" style="">3</span><span class="p" style="">,</span> <span class="mi" style="">5</span><span class="p" style="">)</span>
<span class="nb" style="">complex</span><span class="p" style="">(</span><span class="o" style="">*</span><span class="p" style="">(</span><span class="mi" style="">3</span><span class="p" style="">,</span> <span class="mi" style="">5</span><span class="p" style="">))</span>
</pre></div></div></li></ul><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">参数会被赋值给函数体中对应的局部变量。有关赋值规则参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/expressions.html#calls" style="">调用</a>&nbsp;一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-parameter" style="">parameter</a>&nbsp;术语表条目，常见问题中&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/faq/programming.html#faq-argument-vs-parameter" style="">参数与形参的区别</a>&nbsp;以及&nbsp;<span class="target" id="index-71" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362" style="">PEP 362</a>。</p><h5>asynchronous context manager – 异步上下文管理器</h5><p><span style="text-align: justify;">该对象通过定义&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aenter__" title="object.__aenter__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__aenter__()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aexit__" title="object.__aexit__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__aexit__()</span></a><span style="text-align: justify;">&nbsp;方法来对&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">with</span></a><span style="text-align: justify;">&nbsp;语句中的环境进行控制。由&nbsp;</span><span class="target" id="index-72" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="text-align: justify;">PEP 492</a><span style="text-align: justify;">&nbsp;引入。</span><br></p><h5>asynchronous generator – 异步生成器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">返回值为&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-generator-iterator" style="">asynchronous generator iterator</a>&nbsp;的函数。它与使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">def</span></a>&nbsp;定义的协程函数很相似，不同之处在于它包含&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">yield</span></a>&nbsp;表达式以产生一系列可在&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">for</span></a>&nbsp;循环中使用的值。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">此术语通常是指异步生成器函数，但在某些情况下则可能是指&nbsp;<i>异步生成器迭代器</i>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">一个异步生成器函数可能包含&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">await</span></a>&nbsp;表达式或者&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">for</span></a>&nbsp;以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">with</span></a>语句。</p><h5>asynchronous generator iterator – 异步生成器迭代器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-generator" style="">asynchronous generator</a>&nbsp;函数所创建的对象。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">此对象属于&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterator" style="">asynchronous iterator</a>，当使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__anext__" title="object.__anext__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__anext__()</span></a>&nbsp;方法调用时会返回一个可等待对象来执行异步生成器函数的代码直到下一个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">yield</span></a>&nbsp;表达式。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">每个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">yield</span></a>&nbsp;会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该&nbsp;异步生成器迭代器&nbsp;与其他&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__anext__" title="object.__anext__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__anext__()</span></a>&nbsp;返回的可等待对象有效恢复时，它会从离开位置继续执行。参见&nbsp;<span class="target" id="index-73" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="">PEP 492</a>&nbsp;和&nbsp;<span class="target" id="index-74" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525" style="">PEP 525</a>。</p><h5>asynchronous iterable – 异步可迭代对象</h5><p><span style="text-align: justify;">可在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">for</span></a><span style="text-align: justify;">&nbsp;语句中被使用的对象。必须通过它的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aiter__" title="object.__aiter__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__aiter__()</span></a><span style="text-align: justify;">&nbsp;方法返回一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterator" style="text-align: justify;"><span class="xref std std-term">asynchronous iterator</span></a><span style="text-align: justify;">。由&nbsp;</span><span class="target" id="index-75" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="text-align: justify;">PEP 492</a><span style="text-align: justify;">&nbsp;引入。</span><br></p><h5>asynchronous iterator – 异步迭代器</h5><p><span style="text-align: justify;">实现了&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aiter__" title="object.__aiter__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__aiter__()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__anext__" title="object.__anext__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__anext__()</span></a><span style="text-align: justify;">&nbsp;方法的对象。</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">__anext__</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;必须返回一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="xref std std-term">awaitable</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;对象。</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">for</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;会处理异步迭代器的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__anext__" title="object.__anext__" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__anext__()</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;方法所返回的可等待对象，直到其引发一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">StopAsyncIteration</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;异常。由&nbsp;</span><span class="target" id="index-76" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 492</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">引入。</span><br></p><h5>attribute – 特性</h5><p>关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 o 具有一个特性 a，就可以用 o.a 来引用它。<br></p><h5>awaitable – 可等待对象</h5><p><span style="text-align: justify;">能在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">await</span></a><span style="text-align: justify;">&nbsp;表达式中使用的对象。可以是&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" style="text-align: justify;"><span class="xref std std-term">coroutine</span></a><span style="text-align: justify;">&nbsp;或是具有&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" title="object.__await__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__await__()</span></a><span style="text-align: justify;">方法的对象。参见&nbsp;</span><span class="target" id="index-77" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="text-align: justify;">PEP 492</a><span style="text-align: justify;">。</span><br></p><h5>binary file – 二进制文件</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" style="">file object</a>&nbsp;能够读写&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" style="">类字节对象</a>。二进制文件的例子包括以二进制模式（<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">'rb'</span><span style="padding: 0px 1px; border-radius: 3px;">,&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">'wb'</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;or&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">'rb+'</span><span style="padding: 0px 1px; border-radius: 3px;">）打开的文件、</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.stdin.buffer</span><span style="padding: 0px 1px; border-radius: 3px;">、</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.stdout.buffer</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;以及&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" title="io.BytesIO" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">io.BytesIO</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/gzip.html#gzip.GzipFile" title="gzip.GzipFile" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">gzip.GzipFile</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;的实例。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另请参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file" style="">text file</a>&nbsp;了解能够读写&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a>&nbsp;对象的文件对象。</p><h5>bytes-like object – 类字节对象</h5><div><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">支持&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects" style="">缓冲协议</a>&nbsp;并且能导出 C-<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-contiguous" style="">contiguous</a>&nbsp;缓冲的对象。这包括所有&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="bytearray" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytearray</span></a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/array.html#array.array" title="array.array" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">array.array</span></a>&nbsp;对象，以及许多普通&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" title="memoryview" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">memoryview</span></a>&nbsp;对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="bytearray" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytearray</span></a>&nbsp;以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" title="bytearray" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytearray</span></a>&nbsp;的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" title="memoryview" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">memoryview</span></a>。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a>&nbsp;以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a>&nbsp;对象的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" title="memoryview" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">memoryview</span></a>。</p></div><h5>bytecode – 字节码</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">.pyc</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-virtual-machine" style="padding: 0px 1px; border-radius: 3px;">virtual machine</a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">字节码指令列表可以在&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/dis.html#bytecodes" style="">dis 模块</a>&nbsp;的文档中查看。</p><h5>class – 类</h5><p>用于创建用户自定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p><h5>class variable - 类变量</h5><p>在类中定义的变量，并且仅限于在类的层级上修改（而不是在累的实例中修改）。</p><h5>coercion - 强制类型转换</h5><p><span style="text-align: justify;">在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">int(3.15)</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;是将原浮点数转换为整型数&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">3</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">，但在&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">3+4.5</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" title="TypeError" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">TypeError</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">float(3)+4.5</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;而不是&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">3+4.5</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><h5>complex number – 复数</h5><p><span style="text-align: justify;">对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">-1</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;的平方根）的实倍数，通常在数学中写为&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">i</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">，在工程学中写为&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">j</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">j</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;后缀，例如&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">3+1j</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。如果需要&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/math.html#module-math" title="math: Mathematical functions (sin() etc.)." style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">math</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;模块内对象的对应复数版本，请使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers." style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">cmath</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。</span><br></p><h5>context manager – 上下文管理器</h5><p><span style="text-align: justify;">在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">with</span></a><span style="text-align: justify;">&nbsp;语句中使用，通过定义&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" title="object.__enter__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__enter__()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" title="object.__exit__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__exit__()</span></a><span style="text-align: justify;">&nbsp;方法来控制环境状态的对象。参见&nbsp;</span><span class="target" id="index-78" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343" style="text-align: justify;">PEP 343</a><span style="text-align: justify;">。</span><br></p><h5>contiguous – 连续</h5><p><span style="text-align: justify;">一个缓冲如果是<i>&nbsp;</i></span><span style="text-align: justify;"><i>C-连续</i></span><span style="text-align: justify;"><i>&nbsp;</i>或&nbsp;</span><span style="text-align: justify;"><i>Fortran 连续</i></span><span style="text-align: justify;">&nbsp;就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</span><br></p><h5>coroutine – 协程</h5><p><span style="text-align: justify;">协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">def</span></a><span style="text-align: justify;">&nbsp;语句来实现。参见&nbsp;</span><span class="target" id="index-79" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="text-align: justify;">PEP 492</a><span style="text-align: justify;">。</span><br></p><h5>coroutine function – 协程函数</h5><p><span style="text-align: justify;">返回一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" style="text-align: justify;"><span class="xref std std-term">coroutine</span></a><span style="text-align: justify;">&nbsp;对象的函数。协程函数可通过&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">def</span></a><span style="text-align: justify;">&nbsp;语句来定义，并可能包含&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">await</span></a><span style="text-align: justify;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">for</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">async</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">with</span></a><span style="text-align: justify;">&nbsp;关键字。这些特性是由&nbsp;</span><span class="target" id="index-80" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" style="text-align: justify;">PEP 492</a><span style="text-align: justify;">&nbsp;引入的。</span><br></p><h5>CPython</h5><p><span style="text-align: justify;">Python 编程语言的规范实现，在&nbsp;</span><a class="reference external" href="https://www.python.org/" style="text-align: justify;">python.org</a><span style="text-align: justify;">&nbsp;上发布。”CPython” 一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。</span><br></p><h5>decorator – 装饰器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">返回值为另一个函数的函数，通常使用&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">@wrapper</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;语法形式来进行函数变换。装饰器的常见例子包括&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#classmethod" title="classmethod" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">classmethod()</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#staticmethod" title="staticmethod" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">staticmethod()</span></a><span style="padding: 0px 1px; border-radius: 3px;">。</span></p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p><div class="highlight-python3 notranslate" style="text-align: justify; position: relative; background-color: rgb(255, 255, 255); font-size: 16px; font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; color: rgb(34, 34, 34);"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">f</span><span class="p">(</span><span class="o" style="color: rgb(102, 102, 102);">...</span><span class="p">):</span>
    <span class="o" style="color: rgb(102, 102, 102);">...</span>
<span class="n">f</span> <span class="o" style="color: rgb(102, 102, 102);">=</span> <span class="nb" style="color: rgb(0, 112, 32);">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd" style="color: rgb(85, 85, 85); font-weight: bold;">@staticmethod</span>
<span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">f</span><span class="p">(</span><span class="o" style="color: rgb(102, 102, 102);">...</span><span class="p">):</span>
    <span class="o" style="color: rgb(102, 102, 102);">...</span></pre></div></div><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">同样的概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" style="">函数定义</a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class" style="">类定义</a>&nbsp;的文档。</p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">descriptor – 描述符</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">任何定义了&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" title="object.__get__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__get__()</span></a>,&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" title="object.__set__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__set__()</span></a>&nbsp;或&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delete__" title="object.__delete__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__delete__()</span></a>&nbsp;方法的对象。当一个类属性为描述符时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用&nbsp;a.b&nbsp;来获取、设置或删除一个属性时会在&nbsp;a&nbsp;的类字典中查找名称为&nbsp;b&nbsp;的对象，但如果&nbsp;b&nbsp;是一个描述符，则会调用对应的描述符方法。理解描述符的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">有关描述符的方法的详情可参看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors" style="">实现描述器</a>。</p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">dictionary – 字典</h5><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;"><span style="text-align: justify;">一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" title="object.__hash__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__hash__()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" title="object.__eq__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__eq__()</span></a><span style="text-align: justify;">&nbsp;方法的对象。在 Perl 语言中称为 hash。</span><br></p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">dictionary view – 字典视图</h5><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;"><span style="text-align: justify;">从&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.keys" title="dict.keys" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict.keys()</span></a><span style="text-align: justify;">,&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.values" title="dict.values" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict.values()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict.items" title="dict.items" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict.items()</span></a><span style="text-align: justify;">&nbsp;返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">list(dictview)</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict-views" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="std std-ref">Dictionary view objects</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">docstring – 文档字符串</h5><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 __doc__ 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。<br></p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">duck-typing – 鸭子类型</h5><p><span style="text-align: justify;">指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#type" title="type" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">type()</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" title="isinstance" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">isinstance()</span></a><span style="text-align: justify;">&nbsp;检测。(但要注意鸭子类型可以使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-abstract-base-class" style="text-align: justify;"><span class="xref std std-term">抽象基类</span></a><span style="text-align: justify;">&nbsp;作为补充。) 而往往会采用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#hasattr" title="hasattr" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">hasattr()</span></a><span style="text-align: justify;">&nbsp;检测或是&nbsp;</span><span class="xref std std-term" style="text-align: justify;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-eafp" style="text-align: justify;">EAFP</a>&nbsp;</span><span style="text-align: justify;">编程。</span></p><h5 style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">EAFP</h5><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;"><span style="text-align: justify;">“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特定就是大量运用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">try</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">except</span></a><span style="text-align: justify;">&nbsp;语句。于其相对的则是所谓&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-lbyl" style="text-align: justify;"><span class="xref std std-term">LBYL</span></a><span style="text-align: justify;">&nbsp;风格，常见于 C 等许多其他语言。</span><br></p><h5>expression – 表达式</h5><p><span style="text-align: justify;">可以求出某个值的语法单元。换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。与许多其他语言不同，并非所有语言构件都是表达式。还存在不能用作表达式的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-statement" style="text-align: justify;"><span class="xref std std-term">statement</span></a><span style="text-align: justify;">，例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span></a><span style="text-align: justify;">。赋值也是语句而非表达式。</span><br></p><h5>extension module – 扩展模块</h5><p>以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。<br></p><h5>f-string – f-字符串</h5><p><span style="text-align: justify;">带有&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">'f'</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;或&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">'F'</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;前缀的字符串字面值通常被称为“f-字符串”即&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="std std-ref">格式化字符串字面值</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;的简写。参见&nbsp;</span><span class="target" id="index-81" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0498" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 498</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><h5>file object – 文件对象</h5><p><span style="text-align: justify;">对外提供面向文件 API 以使用下层资源的对象（带有&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">read()</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;或&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">write()</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。文件对象也被称为&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;"><i>文件类对象</i></span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;或&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;"><i>流</i></span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><p><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">实际上共有三种类别的文件对象: 原始&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" style=""><span class="xref std std-term">二进制文件</span></a>, 缓冲&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" style=""><span class="xref std std-term">二进制文件</span></a>&nbsp;以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file" style=""><span class="xref std std-term">文本文件</span></a>。它们的接口定义均在&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/io.html#module-io" title="io: Core tools for working with streams." style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">io</span></a>&nbsp;模块中。创建文件对象的规范方式是使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#open" title="open" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">open()</span></a>函数。<br></span></p><h5>file-like object – 文件类对象</h5><p><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" style="text-align: justify;"><span class="xref std std-term" style="">file object</span></a><span style="text-align: justify;">&nbsp;的同义词。</span><br></p><h5>finder – 查找器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种会尝试查找被导入模块的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-loader" style="">loader</a>&nbsp;的对象。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">从 Python 3.3 起存在两种类型的查找器:&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-meta-path-finder" style="">元路径查找器</a>&nbsp;配合&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" title="sys.meta_path" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.meta_path</span></a>使用，以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" style="">path entry finders</a>&nbsp;配合&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" title="sys.path_hooks" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.path_hooks</span></a>&nbsp;使用。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">更多详情可参见&nbsp;<span class="target" id="index-82" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" style="">PEP 302</a>,&nbsp;<span class="target" id="index-83" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420" style="">PEP 420</a>&nbsp;和&nbsp;<span class="target" id="index-84" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451" style="">PEP 451</a>。</p><h5>loor division – 向下取整除法</h5><p><span style="text-align: justify;">向下舍入到最接近的整数的数学除法。向下取整除法的运算符是&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">//</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;。例如，表达式&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">11</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;">&nbsp;</span><span class="pre" style="hyphens: none;">//</span>&nbsp;<span class="pre" style="hyphens: none;">4</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;的计算结果是&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">2</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;，而与之相反的是浮点数的真正除法返回&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">2.75</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。注意&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">(-11)</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;">&nbsp;</span><span class="pre" style="hyphens: none;">//</span>&nbsp;<span class="pre" style="hyphens: none;">4</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;会返回&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">-3</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;因为这是&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">-2.75</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;"><i>向下</i></span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;舍入得到的结果。见&nbsp;</span><span class="target" id="index-85" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 238</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;。</span><br></p><h5>function – 函数</h5><p><span style="text-align: justify;">可以向调用者返回某个值的一组语句。还可以向其传入零个或多个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="text-align: justify;"><span class="xref std std-term">参数</span></a><span style="text-align: justify;">&nbsp;并在函数体执行中被使用。另见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-parameter" style="text-align: justify;"><span class="xref std std-term">parameter</span></a><span style="text-align: justify;">,&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-method" style="text-align: justify;"><span class="xref std std-term">method</span></a><span style="text-align: justify;">&nbsp;和 the&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" style="text-align: justify;"><span class="std std-ref">Function definitions</span></a><span style="text-align: justify;">&nbsp;等节。</span><br></p><h5>function annotation – 函数标注</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">即针对函数形参或返回值的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-annotation" style="">annotation</a>&nbsp;。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">函数标注通常用于&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-type-hint" style="">类型提示</a>：例如以下函数预期接受两个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">int</span></a>&nbsp;参数并预期返回一个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">int</span></a>&nbsp;值:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">)</span> <span class="o" style="color: rgb(102, 102, 102);">-&gt;</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">:</span>
   <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">return</span> <span class="n">a</span> <span class="o" style="color: rgb(102, 102, 102);">+</span> <span class="n">b</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">函数标注语法的详解见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" style="">Function definitions</a>&nbsp;一节。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">请参看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-variable-annotation" style="">variable annotation</a>&nbsp;和&nbsp;<span class="target" id="index-86" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" style="">PEP 484</a>&nbsp;对此功能的描述。</p><h5>__future__</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种伪模块，可被程序员用来启用与当前解释器不兼容的新语言特性。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">通过导入&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/__future__.html#module-__future__" title="__future__: Future statement definitions" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__future__</span></a>&nbsp;模块并对其中的变量求值，你可以查看新特性何时首次加入语言以及何时成为默认:</p><div class="last highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="kn" style="color: rgb(0, 112, 32); font-weight: bold;">import</span> <span class="nn" style="color: rgb(14, 132, 181); font-weight: bold;">__future__</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)</span></pre></div></div><h5>garbage collection – 垃圾回收</h5><p><span style="text-align: justify;">释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">gc</span></a><span style="text-align: justify;">&nbsp;模块来控制垃圾回收器。</span><br></p><h5>generator – 生成器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">返回一个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-generator-iterator" style="">generator iterator</a>&nbsp;的函数。它看起来很像普通函数，不同点在于其包含&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">yield</span></a>&nbsp;表达式以便产生一系列值供给 for-循环使用或是通过&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">next()</span></a>&nbsp;函数逐一获取。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">通常是指生成器函数，但在某些情况下也可能是指&nbsp;<i>生成器迭代器</i>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p><h5>generator iterator – 生成器迭代器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-generator" style="">generator</a>&nbsp;函数所创建的对象。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">每个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">yield</span></a>&nbsp;会临时暂停处理，记住当前位置执行状态（包括局部变量和挂起的 try 语句）。当该&nbsp;<i>生成器迭代器</i>&nbsp;恢复时，它会从离开位置继续执行（这与每次调用都从新开始的普通函数差别很大）。</p><h5>generator expression – 生成器表达式</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">返回一个迭代器的表达式。它看起来很像普通表达式后面带有定义了一个循环变量、范围以及一个可选的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span></a>&nbsp;表达式的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span></a>&nbsp;表达式。以下复合表达式为外层函数生成一系列值:</p><div class="last highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="nb" style="color: rgb(0, 112, 32);">sum</span><span class="p">(</span><span class="n">i</span><span class="o" style="color: rgb(102, 102, 102);">*</span><span class="n">i</span> <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">for</span> <span class="n">i</span> <span class="ow" style="color: rgb(0, 112, 32); font-weight: bold;">in</span> <span class="nb" style="color: rgb(0, 112, 32);">range</span><span class="p">(</span><span class="mi" style="color: rgb(32, 128, 80);">10</span><span class="p">))</span>         <span class="c1" style="color: rgb(64, 128, 144); font-style: italic;"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span></pre></div></div><h5>generic function – 泛型函数</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另请参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-single-dispatch" style="">single dispatch</a>&nbsp;术语表条目、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functools.html#functools.singledispatch" title="functools.singledispatch" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">functools.singledispatch()</span></a>&nbsp;装饰器以及&nbsp;<span class="target" id="index-87" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0443" style="">PEP 443</a>。</p><h5>GIL</h5><p>参见 global interpreter lock。<br></p><h5>global interpreter lock – 全局解释器锁</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-cpython" style=""><span class="xref std std-term" style="">CPython</span></a>&nbsp;解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-bytecode" style="">bytecode</a>。此机制通过设置对象模型（包括&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" title="dict" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict</span></a>&nbsp;等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p><h5>hash-based pyc – 基于哈希的 pyc</h5><p><span style="text-align: justify;">使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/import.html#pyc-invalidation" style="text-align: justify;"><span class="std std-ref">Cached bytecode invalidation</span></a><span style="text-align: justify;">。</span><br></p><h5>hashable – 可哈希</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一个对象的哈希值如果在其生命周期内绝不改变，就被称为&nbsp;<i>可哈希&nbsp;</i>（它需要具有&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" title="object.__hash__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__hash__()</span></a>&nbsp;方法），并可以同其他对象进行比较（它需要具有&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" title="object.__eq__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__eq__()</span></a>&nbsp;方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">所有 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希。用户定义类的实例对象默认是可哈希的。它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成基于其&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#id" title="id" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">id()</span></a>。</p><h5>IDLE</h5><p><span style="text-align: justify;">Python 的 IDE，“集成开发与学习环境”的英文缩写。是 Python 标准发行版附带的基本编程器和解释器环境。</span><br></p><h5>immutable – 不可变</h5><p>具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。<br></p><h5>import path – 导入路径</h5><p><span style="text-align: justify;">由多个位置（或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" style="text-align: justify;"><span class="xref std std-term">路径条目</span></a><span style="text-align: justify;">）组成的列表，会被模块的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" style="text-align: justify;"><span class="xref std std-term">path based finder</span></a><span style="text-align: justify;">&nbsp;用来查找导入目标。在导入时，此位置列表通常来自&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" title="sys.path" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.path</span></a><span style="text-align: justify;">，但对次级包来说也可能来自上级包的&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">__path__</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;属性。</span><br></p><h5>importing – 导入</h5><p>令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。<br></p><h5>importer – 导入器</h5><p><span style="text-align: justify;">查找并加载模块的对象；此对象既属于&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-finder" style="text-align: justify;"><span class="xref std std-term">finder</span></a><span style="text-align: justify;">&nbsp;又属于&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-loader" style="text-align: justify;"><span class="xref std std-term">loader</span></a><span style="text-align: justify;">。</span><br></p><h5>interactive – 交互</h5><p><span style="text-align: justify;">Python 带有一个交互式解释器，即你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。只需不带参数地启动&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">python</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;命令（也可以在你的计算机开始菜单中选择相应菜单项）。在测试新想法或检验模块和包的时候用这种方式会非常方便（请记得使用&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">help(x)</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">）。</span><br></p><h5>interpreted – 解释型</h5><p><span style="text-align: justify;">Python 一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发/调试周期，但是其程序往往运行得更慢。参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-interactive" style="text-align: justify;"><span class="xref std std-term">interactive</span></a><span style="text-align: justify;">。</span><br></p><h5>interpreter shutdown – 解释器关闭</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-garbage-collection" style="">垃圾回收器</a>。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">解释器需要关闭的主要原因有&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__main__</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;</span><span style="padding: 0px 1px; border-radius: 3px;">模块或所运行的脚本已完成执行。</span></p><h5>iterable – 可迭代对象</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">能够逐一返回其成员项的对象。可迭代对象的例子包括所有序列类型（例如&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="list" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">list</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="tuple" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">tuple</span></a>）以及某些非序列类型例如&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" title="dict" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" style="">文件对象</a>&nbsp;以及定义了&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__iter__()</span></a>&nbsp;方法或是实现了&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-sequence" style="">Sequence</a>&nbsp;语义的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" title="object.__getitem__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__getitem__()</span></a>&nbsp;方法的任意自定义类对象。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">可迭代对象被可用于&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span></a>&nbsp;循环以及许多其他需要一个序列的地方（<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#zip" title="zip" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">zip()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#map" title="map" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">map()</span></a>&nbsp;…）。当一个可迭代对象作为参数传给内置函数&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#iter" title="iter" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">iter()</span></a>&nbsp;时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#iter" title="iter" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">iter()</span></a>&nbsp;或者自己处理迭代器对象。<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator" style="padding: 0px 1px; border-radius: 3px;">iterator</a><span style="padding: 0px 1px; border-radius: 3px;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-sequence" style="padding: 0px 1px; border-radius: 3px;">sequence</a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;以及&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-generator" style="padding: 0px 1px; border-radius: 3px;">generator</a><span style="padding: 0px 1px; border-radius: 3px;">。</span></p><h5>iterator – 迭代器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">用来表示一连串数据流的对象。重复调用迭代器的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" title="iterator.__next__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__next__()</span></a>&nbsp;方法（或将其传给内置函数&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#next" title="next" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">next()</span></a>）将逐个返回流中的项。当没有数据可用时则将引发&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">StopIteration</span></a>&nbsp;异常。到这时迭代器对象中的数据项已耗尽，继续调用其&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__next__()</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;方法只会再次引发&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" title="StopIteration" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">StopIteration</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;异常。迭代器必须具有&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" title="object.__iter__" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__iter__()</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="list" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">list</span></a><span style="padding: 0px 1px; border-radius: 3px;">）在你每次向其传入&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#iter" title="iter" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">iter()</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;函数或是在&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">更多信息可查看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typeiter" style="">Iterator Types</a>。</p><h5>key function – 键函数</h5><div><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/locale.html#locale.strxfrm" title="locale.strxfrm" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">locale.strxfrm()</span></a>&nbsp;可用于生成一个符合特定区域排序约定的排序键。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#min" title="min" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">min()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#max" title="max" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">max()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#sorted" title="sorted" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sorted()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list.sort" title="list.sort" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">list.sort()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.merge" title="heapq.merge" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">heapq.merge()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.nsmallest" title="heapq.nsmallest" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">heapq.nsmallest()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.nlargest" title="heapq.nlargest" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">heapq.nlargest()</span></a>&nbsp;以及&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.groupby" title="itertools.groupby" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">itertools.groupby()</span></a>。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">要创建一个键函数有多种方式。例如，<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.lower" title="str.lower" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str.lower()</span></a>&nbsp;方法可以用作忽略大小写排序的键函数。另外，键函数也可通过&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">lambda</span></a>&nbsp;表达式来创建，例如&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">lambda</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">r:</span><span class="pre" style="hyphens: none;">(r[0],</span>&nbsp;<span class="pre" style="hyphens: none;">r[2])</span>。还有&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators." style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">operator</span></a>&nbsp;模块提供了三个键函数构造器：<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.attrgetter" title="operator.attrgetter" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">attrgetter()</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.itemgetter" title="operator.itemgetter" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">itemgetter()</span></a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.methodcaller" title="operator.methodcaller" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">methodcaller()</span></a>。请查看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/howto/sorting.html#sortinghowto" style="">如何排序</a>&nbsp;一节以获取创建和使用键函数的示例。</p></div><h5>keyword argument – 关键字参数</h5><p><span style="text-align: justify;">参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="text-align: justify;"><span class="xref std std-term">argument</span></a><span style="text-align: justify;">。</span><br></p><h5>lambda</h5><p><span style="text-align: justify;">由一个单独&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-expression" style="text-align: justify;"><span class="xref std std-term">expression</span></a><span style="text-align: justify;">&nbsp;构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">lambda</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;">&nbsp;</span><span class="pre" style="hyphens: none;">[parameters]:</span>&nbsp;<span class="pre" style="hyphens: none;">expression</span><br></p><h5>LBYL</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-eafp" style="">EAFP</a>&nbsp;方式恰成对比，其特点是大量使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span></a>&nbsp;语句。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">key</span>&nbsp;<span class="pre" style="hyphens: none;">in</span>&nbsp;<span class="pre" style="hyphens: none;">mapping:</span>&nbsp;<span class="pre" style="hyphens: none;">return</span>&nbsp;<span class="pre" style="hyphens: none;">mapping[key]</span>&nbsp;可能由于在检查操作之后其他线程从&nbsp;mapping&nbsp;中移除了&nbsp;key&nbsp;而出错。这种问题可通过加锁或使用 EAFP 方式来解决。</p><h5>list – 列表</h5><p><span style="text-align: justify;">Python 内置的一种&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-sequence" style="text-align: justify;"><span class="xref std std-term">sequence</span></a><span style="text-align: justify;">。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</span><br></p><h5>list comprehension – 列表推导式</h5><p><span style="text-align: justify;">处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">result</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px; text-align: justify;">&nbsp;</span><span class="pre" style="hyphens: none;">=</span><span class="pre" style="hyphens: none;">['{:#04x}'.format(x)</span>&nbsp;<span class="pre" style="hyphens: none;">for</span>&nbsp;<span class="pre" style="hyphens: none;">x</span>&nbsp;<span class="pre" style="hyphens: none;">in</span>&nbsp;<span class="pre" style="hyphens: none;">range(256)</span>&nbsp;<span class="pre" style="hyphens: none;">if</span>&nbsp;<span class="pre" style="hyphens: none;">x</span>&nbsp;<span class="pre" style="hyphens: none;">%</span>&nbsp;<span class="pre" style="hyphens: none;">2</span>&nbsp;<span class="pre" style="hyphens: none;">==</span>&nbsp;<span class="pre" style="hyphens: none;">0]</span><span style="text-align: justify;">&nbsp;将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span></a><span style="text-align: justify;">&nbsp;子句是可选的，如果省略则&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">range(256)</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;中的所有元素都会被处理。</span><br></p><h5>loader – 加载器</h5><p><span style="text-align: justify;">负责加载模块的对象。它必须定义名为&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">load_module()</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;的方法。加载器通常由一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-finder" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="xref std std-term">finder</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;返回。详情参见&nbsp;</span><span class="target" id="index-88" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 302</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">，对于&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-abstract-base-class" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="xref std std-term">abstract base class</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;可参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">importlib.abc.Loader</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><h5>mapping – 映射</h5><p><span style="text-align: justify;">一种支持任意键查找并实现了&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">Mapping</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">MutableMapping</span></a><span style="text-align: justify;">&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections-abstract-base-classes" style="text-align: justify;"><span class="std std-ref">抽象基类</span></a><span style="text-align: justify;">&nbsp;中所规定方法的容器对象。此类对象的例子包括&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" title="dict" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict</span></a><span style="text-align: justify;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict" title="collections.defaultdict" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.defaultdict</span></a><span style="text-align: justify;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.OrderedDict" title="collections.OrderedDict" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.OrderedDict</span></a><span style="text-align: justify;">&nbsp;以及&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.Counter" title="collections.Counter" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.Counter</span></a><span style="text-align: justify;">。</span><br></p><h5>meta path finder – 元路径查找器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" title="sys.meta_path" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.meta_path</span></a>&nbsp;的搜索所返回的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-finder" style="">finder</a>。元路径查找器与&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" style="">path entry finders</a>存在关联但并不相同。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">请查看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">importlib.abc.MetaPathFinder</span></a>&nbsp;了解元路径查找器所实现的方法。</p><h5>metaclass – 元类</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">更多详情参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#metaclasses" style="">元类</a>。</p><h5>method – 方法</h5><p><span style="text-align: justify;">在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个&nbsp;</span><span class="xref std std-term" style="text-align: justify;">argument`（通常命名为 ``self`</span><span style="text-align: justify;">）。参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-function" style="text-align: justify;"><span class="xref std std-term">function</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-nested-scope" style="text-align: justify;"><span class="xref std std-term">nested scope</span></a><span style="text-align: justify;">。</span><br></p><h5>method resolution order – 方法解析顺序</h5><p><span style="text-align: justify;">方法解析顺序就是在查找成员时搜索全部基类所用的先后顺序。请查看&nbsp;</span><a class="reference external" href="https://www.python.org/download/releases/2.3/mro/" style="text-align: justify;">Python 2.3 方法解析顺序</a><span style="text-align: justify;">&nbsp;了解自 2.3 版起 Python 解析器所用相关算法的详情。</span><br></p><h5>module – 模块</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-importing" style="">importing</a>&nbsp;操作被加载到 Python 中。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-package" style="">package</a>。</p><h5>module spec – 模块规格</h5><p><span style="text-align: justify;">一个命名空间，其中包含用于加载模块的相关导入信息。是&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">importlib.machinery.ModuleSpec</span></a><span style="text-align: justify;">&nbsp;的实例。</span><br></p><h5>MRO</h5><p><span style="text-align: justify;">参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order" style="text-align: justify;"><span class="xref std std-term">method resolution order</span></a><span style="text-align: justify;">。</span><br></p><h5>mutable – 可变</h5><p><span style="text-align: justify;">可变对象可以在其&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#id" title="id" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">id()</span></a><span style="text-align: justify;">&nbsp;保持固定的情况下改变其取值。另请参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable" style="text-align: justify;"><span class="xref std std-term">immutable</span></a><span style="text-align: justify;">。</span><br></p><h5>named tuple – 具名元组</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">任何类似元组的类，其中的可索引元素也能使用名称属性来访问。（例如，<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/time.html#time.localtime" title="time.localtime" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">time.localtime()</span></a>&nbsp;会返回一个类似元组的对象，其中的&nbsp;year&nbsp;既可以通过索引访问如&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">t[0]</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;也可以通过名称属性访问如&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">t.tm_year</span><span style="padding: 0px 1px; border-radius: 3px;">）。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">具名元组可以是一个内置类型例如&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/time.html#time.struct_time" title="time.struct_time" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">time.struct_time</span></a>，也可以通过正规的类定义来创建。一个完备的具名元组还可以通过工厂函数&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple" title="collections.namedtuple" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.namedtuple()</span></a>&nbsp;来创建。后面这种方式会自动提供一些额外特性，例如&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">Employee(name='jones',</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">&nbsp;</span><span class="pre" style="hyphens: none;">title='programmer')</span>&nbsp;这样的自包含文档表示形式。</p><h5>namespace – 命名空间</h5><p><span style="text-align: justify;">命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#open" title="open" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">builtins.open</span></a><span style="text-align: justify;">&nbsp;与&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.open" title="os.open" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.open()</span></a><span style="text-align: justify;">&nbsp;可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/random.html#random.seed" title="random.seed" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">random.seed()</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.islice" title="itertools.islice" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">itertools.islice()</span></a><span style="text-align: justify;">&nbsp;这种写法明确了这些函数是由&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">random</span></a><span style="text-align: justify;">&nbsp;与&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">itertools</span></a><span style="text-align: justify;">&nbsp;模块分别实现的。</span><br></p><h5>namespace package – 命名空间包</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420" style="">PEP 420</a>&nbsp;所引入的一种仅被用作子包的容器的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-package" style="">package</a>，命名空间包可以没有实体表示物，其描述方式与&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-regular-package" style="">regular package</a>&nbsp;不同，因为它们没有&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__init__.py</span><span style="padding: 0px 1px; border-radius: 3px;">文件。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另可参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-module" style="">module</a>。</p><h5>nested scope – 嵌套作用域</h5><p><span style="text-align: justify;">在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">nonlocal</span></a><span style="text-align: justify;">&nbsp;关键字可允许写入外层作用域。</span><br></p><h5>new-style class – 新式类</h5><p><span style="text-align: justify;">对于目前已被应于所有类对象的类形式的旧称谓。在早先的 Python 版本中，只有新式类能够使用 Python 新增的更灵活特性，例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__slots__" title="object.__slots__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__slots__</span></a><span style="text-align: justify;">、描述符、特征属性、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" title="object.__getattribute__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__getattribute__()</span></a><span style="text-align: justify;">、类方法和静态方法等。</span><br></p><h5>object – 对象</h5><p><span style="text-align: justify;">任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-new-style-class" style="text-align: justify;"><span class="xref std std-term">new-style class</span></a><span style="text-align: justify;">&nbsp;的最顶层基类名。</span><br></p><h5>package – 包</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种可包含子模块或递归地包含子包的 Python&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-module" style="">module</a>。从技术上说，包是带有&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__path__</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;属性的 Python 模块。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-regular-package" style="">regular package</a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-namespace-package" style="">namespace package</a>。</p><h5>parameter – 形参</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-function" style="">function</a>&nbsp;（或方法）定义中的命名实体，它指定函数可以接受的一个&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="">argument</a>（或在某些情况下，arguments）。有五种形参：</p><ul class="simple" id="positional-only-parameter" style="margin-bottom: 10px; text-align: justify;"><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><i>positional-or-keyword</i>：位置或关键字，指定一个可以作为&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="">位置参数</a>&nbsp;传入也可以作为&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="">关键字参数</a>&nbsp;传入的实参。这是默认的形参类型，例如下面的&nbsp;foo&nbsp;和&nbsp;bar:</p><div class="highlight-python3 notranslate" style="position: relative; background-color: rgb(255, 255, 255); font-size: 16px; font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; color: rgb(34, 34, 34);"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o" style="color: rgb(102, 102, 102);">=</span><span class="kc" style="color: rgb(0, 112, 32); font-weight: bold;">None</span><span class="p">):</span> <span class="o" style="color: rgb(102, 102, 102);">...</span></pre></div></div></li><li style="hyphens: auto; line-height: 20.8px;">positional-only：仅限位置，指定一个只能按位置传入的参数。Python 中没有定义仅限位置形参的语法。但是一些内置函数有仅限位置形参（比如&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#abs" title="abs" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">abs()</span></a>）。</li></ul><ul id="keyword-only-parameter" style="margin-bottom: 10px; text-align: justify;"><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><i>keyword-only</i>：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">*</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;来定义，例如下面的&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;"><i>kw_only1</i></span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;和&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;"><i>kw_only2</i></span><span style="padding: 0px 1px; border-radius: 3px;">:</span></p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o" style="color: rgb(102, 102, 102);">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o" style="color: rgb(102, 102, 102);">...</span></pre></div></div></li><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><i>var-positional</i>：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">*</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;来定义，例如下面的&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;"><i>args</i></span><span style="padding: 0px 1px; border-radius: 3px;">:</span></p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">func</span><span class="p">(</span><span class="o" style="color: rgb(102, 102, 102);">*</span><span class="n">args</span><span class="p">,</span> <span class="o" style="color: rgb(102, 102, 102);">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o" style="color: rgb(102, 102, 102);">...</span></pre></div></div></li><li style="hyphens: auto; text-align: justify; line-height: 20.8px;"><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><i>var-keyword</i>：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">**</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;来定义，例如上面的&nbsp;</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;"><i>kwargs</i></span><span style="padding: 0px 1px; border-radius: 3px;">。</span></p></li></ul><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="">argument</a>&nbsp;术语表条目、<a class="reference internal" href="https://docs.python.org/zh-cn/3/faq/programming.html#faq-argument-vs-parameter" style="">参数与形参的区别</a>&nbsp;中的常见问题、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/inspect.html#inspect.Parameter" title="inspect.Parameter" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">inspect.Parameter</span></a>&nbsp;类、<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" style="">Function definitions</a>&nbsp;一节以及&nbsp;<span class="target" id="index-90"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362" style="">PEP 362</a>。</p><h5>path entry – 路径入口</h5><p><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" style="text-align: justify;"><span class="xref std std-term" style="">import path</span></a><span style="text-align: justify;">&nbsp;中的一个单独位置，会被&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" style="text-align: justify;"><span class="xref std std-term">path based finder</span></a><span style="text-align: justify;">&nbsp;用来查找要导入的模块。</span><br></p><h5>path entry finder – 路径入口查找器</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">任一可调用对象使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" title="sys.path_hooks" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.path_hooks</span></a>&nbsp;(即&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-hook" style="">path entry hook</a>) 返回的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-finder" style="">finder</a>，此种对象能通过&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" style="">path entry</a>&nbsp;来定位模块。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">请参看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">importlib.abc.PathEntryFinder</span></a>&nbsp;以了解路径入口查找器所实现的各个方法。</p><h5>path entry hook – 路径入口钩子</h5><p><span style="text-align: justify;">一种可调用对象，在知道如何查找特定&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" style="text-align: justify;"><span class="xref std std-term">path entry</span></a><span style="text-align: justify;">&nbsp;中的模块的情况下能够使用&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">sys.path_hook</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;列表返回一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="xref std std-term">path entry finder</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。</span><br></p><h5>path based finder – 基于路径的查找器</h5><p><span style="text-align: justify;">默认的一种&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-meta-path-finder" style="text-align: justify;"><span class="xref std std-term">元路径查找器</span></a><span style="text-align: justify;">，可在一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" style="text-align: justify;"><span class="xref std std-term">import path</span></a><span style="text-align: justify;">&nbsp;中查找模块。</span><br></p><h5>path-like object – 类路径对象</h5><p><span style="text-align: justify;">代表一个文件系统路径的对象。类路径对象可以是一个表示路径的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a><span style="text-align: justify;">&nbsp;或者&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a><span style="text-align: justify;">&nbsp;对象，还可以是一个实现了&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="os.PathLike" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.PathLike</span></a><span style="text-align: justify;">&nbsp;协议的对象。一个支持&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.PathLike" title="os.PathLike" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.PathLike</span></a><span style="text-align: justify;">&nbsp;协议的对象可通过调用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.fspath" title="os.fspath" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.fspath()</span></a><span style="text-align: justify;">&nbsp;函数转换为&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a><span style="text-align: justify;">&nbsp;或者&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a><span style="text-align: justify;">&nbsp;类型的文件系统路径；</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.fsdecode" title="os.fsdecode" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.fsdecode()</span></a><span style="text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.fsencode" title="os.fsencode" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.fsencode()</span></a><span style="text-align: justify;">&nbsp;可被分别用来确保获得&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a><span style="text-align: justify;">&nbsp;类型的结果。此对象是由&nbsp;</span><span class="target" id="index-91" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0519" style="text-align: justify;">PEP 519</a><span style="text-align: justify;">&nbsp;引入的。</span><br></p><h5>PEP</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">参见&nbsp;<span class="target" id="index-92" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0001" style="">PEP 1</a>。</p><h5>portion – 部分</h5><p><span style="text-align: justify;">构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见&nbsp;</span><span class="target" id="index-93" style="text-align: justify;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420" style="text-align: justify;">PEP 420</a><span style="text-align: justify;">。</span><br></p><h5>positional argument – 位置参数</h5><p><span style="text-align: justify;">参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" style="text-align: justify;"><span class="xref std std-term">argument</span></a><span style="text-align: justify;">。</span><br></p><h5>provisional API – 暂定 API</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">暂定 API 是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行 – 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见&nbsp;<span class="target" id="index-94" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0411" style="">PEP 411</a>。</p><h5>provisional package – 暂定包</h5><p><span style="text-align: justify;">参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-provisional-api" style="text-align: justify;"><span class="xref std std-term">provisional API</span></a><span style="text-align: justify;">。</span><br></p><h5>Python 3000</h5><p><span style="text-align: justify;">Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。</span><br></p><h5>Pythonic</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span></a>&nbsp;语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python 的人有时会选择使用一个数字计数器:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">for</span> <span class="n">i</span> <span class="ow" style="color: rgb(0, 112, 32); font-weight: bold;">in</span> <span class="nb" style="color: rgb(0, 112, 32);">range</span><span class="p">(</span><span class="nb" style="color: rgb(0, 112, 32);">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb" style="color: rgb(0, 112, 32);">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">而相应的更简洁更 Pythonic 的方法是这样的:</p><div class="last highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">for</span> <span class="n">piece</span> <span class="ow" style="color: rgb(0, 112, 32); font-weight: bold;">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb" style="color: rgb(0, 112, 32);">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span></pre></div></div><h5>qualified name – 限定名称</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见&nbsp;<span class="target" id="index-95" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3155" style="">PEP 3155</a>。对于最高层级的函数和类，限定名称与对象名称一致:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">class</span> <span class="nc" style="color: rgb(14, 132, 181); font-weight: bold;">C</span><span class="p">:</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">... </span>    <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">class</span> <span class="nc" style="color: rgb(14, 132, 181); font-weight: bold;">D</span><span class="p">:</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">... </span>        <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">meth</span><span class="p">(</span><span class="bp" style="color: rgb(0, 112, 32);">self</span><span class="p">):</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">... </span>            <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">pass</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">...</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="n">C</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="vm" style="color: rgb(187, 96, 213);">__qualname__</span>
<span class="go">'C'</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="n">C</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">D</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="vm" style="color: rgb(187, 96, 213);">__qualname__</span>
<span class="go">'C.D'</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="n">C</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">D</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">meth</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="vm" style="color: rgb(187, 96, 213);">__qualname__</span>
<span class="go">'C.D.meth'</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">当被用于引用模块时，完整限定名称&nbsp;意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">email.mime.text</span><span style="padding-right: 1px; padding-left: 1px; border-radius: 3px;">:</span></p><div class="last highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="kn" style="color: rgb(0, 112, 32); font-weight: bold;">import</span> <span class="nn" style="color: rgb(14, 132, 181); font-weight: bold;">email.mime.text</span>
<span class="gp" style="color: rgb(198, 93, 9); font-weight: bold;">&gt;&gt;&gt; </span><span class="n">email</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">mime</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="n">text</span><span class="o" style="color: rgb(102, 102, 102);">.</span><span class="vm" style="color: rgb(187, 96, 213);">__name__</span>
<span class="go">'email.mime.text'</span></pre></div></div><h5>reference count – 引用计数</h5><p><span style="text-align: justify;">对特定对象的引用的数量。当一个对象的引用计数降为零时，所分配资源将被释放。引用计数对 Python 代码来说通常是不可见的，但它是&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-cpython" style="text-align: justify;"><span class="xref std std-term">CPython</span></a><span style="text-align: justify;">&nbsp;实现的一个关键元素。</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" title="sys: Access system-specific parameters and functions." style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys</span></a><span style="text-align: justify;">&nbsp;模块定义了一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.getrefcount" title="sys.getrefcount" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">getrefcount()</span></a><span style="text-align: justify;">&nbsp;函数，程序员可调用它来返回特定对象的引用计数。</span><br></p><h5>regular package – 正规包</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">传统型的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-package" style="">package</a>，例如包含有一个&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__init__.py</span><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;文件的目录。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-namespace-package" style="">namespace package</a>。</p><h5>__slots__</h5><p><span style="text-align: justify;">一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。</span><br></p><h5>sequence – 序列</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-iterable" style="">iterable</a>，它支持通过&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" title="object.__getitem__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__getitem__()</span></a>&nbsp;特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" title="object.__len__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__len__()</span></a>&nbsp;方法。内置的序列类型有&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" title="list" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">list</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a>、<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" title="tuple" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">tuple</span></a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" title="bytes" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes</span></a>。注意虽然&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" title="dict" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">dict</span></a>&nbsp;也支持&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" title="object.__getitem__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__getitem__()</span></a>&nbsp;和&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" title="object.__len__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__len__()</span></a>，但它被认为属于映射而非序列，因为它查找时使用任意的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable" style="">immutable</a>&nbsp;键而非整数。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">The&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">collections.abc.Sequence</span></a>&nbsp;abstract base class defines a much richer interface that goes beyond just&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" title="object.__getitem__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__getitem__()</span></a>&nbsp;and&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" title="object.__len__" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__len__()</span></a>, adding&nbsp;<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">count()</span><span style="padding: 0px 1px; border-radius: 3px;">,&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">index()</span><span style="padding: 0px 1px; border-radius: 3px;">,&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" title="object.__contains__" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__contains__()</span></a><span style="padding: 0px 1px; border-radius: 3px;">, and&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__reversed__" title="object.__reversed__" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__reversed__()</span></a><span style="padding: 0px 1px; border-radius: 3px;">. Types that implement this expanded interface can be registered explicitly using&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">register()</span><span style="padding: 0px 1px; border-radius: 3px;">.</span></p><h5>single dispatch – 单分派</h5><p><span style="text-align: justify;">一种&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-generic-function" style="text-align: justify;"><span class="xref std std-term">generic function</span></a><span style="text-align: justify;">&nbsp;分派形式，其实现是基于单个参数的类型来选择的。</span><br></p><h5>slice – 切片</h5><p><span style="text-align: justify;">通常只包含了特定&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-sequence" style="text-align: justify;"><span class="xref std std-term">sequence</span></a><span style="text-align: justify;">&nbsp;的一部分的对象。切片是通过使用下标标记来创建的，在&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">[]</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;中给出几个以冒号分隔的数字，例如&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">variable_name[1:3:5]</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。方括号（下标）标记在内部使用&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#slice" title="slice" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">slice</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;对象。</span><br></p><h5>special method – 特殊方法</h5><p><span style="text-align: justify;">一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。特殊方法的文档参见&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#specialnames" style="text-align: justify;"><span class="std std-ref">特殊方法名称</span></a><span style="text-align: justify;">。</span><br></p><h5>statement – 语句</h5><p><span style="text-align: justify;">语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-expression" style="text-align: justify;"><span class="xref std std-term">expression</span></a><span style="text-align: justify;">&nbsp;或某个带有关键字的结构，例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">if</span></a><span style="text-align: justify;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">while</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">for</span></a><span style="text-align: justify;">。</span><br></p><h5>struct sequence – 结构序列</h5><p><span style="text-align: justify;">具有命名元素的元组。结构序列所暴露的接口类似于&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-named-tuple" style="text-align: justify;"><span class="xref std std-term">named tuple</span></a><span style="text-align: justify;">，其元素既可通过索引也可作为属性来访问。不过，它们没有任何具名元组的方法，例如&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.somenamedtuple._make" title="collections.somenamedtuple._make" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">_make()</span></a><span style="text-align: justify;">&nbsp;或&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.somenamedtuple._asdict" title="collections.somenamedtuple._asdict" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">_asdict()</span></a><span style="text-align: justify;">。结构序列的例子包括&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.float_info" title="sys.float_info" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.float_info</span></a><span style="text-align: justify;">&nbsp;以及&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/os.html#os.stat" title="os.stat" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">os.stat()</span></a><span style="text-align: justify;">&nbsp;的返回值。</span><br></p><h5>text encoding – 文本编码</h5><p>用于将Unicode字符串编码为字节串的编码器。<br></p><h5>text file – 文本文件</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种能够读写&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" title="str" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">str</span></a>&nbsp;对象的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" style="">file object</a>。通常一个文本文件实际是访问一个面向字节的数据流并自动处理&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-encoding" style="">text encoding</a>。文本文件的例子包括以文本模式（<span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">'r'</span><span style="padding: 0px 1px; border-radius: 3px;">或&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">'w'</span><span style="padding: 0px 1px; border-radius: 3px;">）打开的文件、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.stdin" title="sys.stdin" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.stdin</span></a><span style="padding: 0px 1px; border-radius: 3px;">、</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.stdout" title="sys.stdout" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">sys.stdout</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;以及&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/io.html#io.StringIO" title="io.StringIO" style="padding: 0px 1px; border-radius: 3px;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">io.StringIO</span></a><span style="padding: 0px 1px; border-radius: 3px;">&nbsp;的实例。</span></p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另请参看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" style="">binary file</a>&nbsp;了解能够读写&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" style="">字节类对象</a>&nbsp;的文件对象。</p><h5>triple-quoted string – 三引号字符串</h5><p>首尾各带三个连续双引号（”）或者单引号（’）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。<br></p><h5>type – 类型</h5><p><span style="text-align: justify;">类型决定一个 Python 对象属于什么种类；每个对象都具有一种类型。要知道对象的类型，可以访问它的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#instance.__class__" title="instance.__class__" style="text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">__class__</span></a><span style="text-align: justify;">&nbsp;属性，或是通过&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">type(obj)</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;来获取。</span><br></p><h5>type alias – 类型别名</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一个类型的同义词，创建方式是把类型赋值给特定的标识符。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">类型别名的作用是简化&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-type-hint" style="">类型提示</a>。例如:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="kn" style="color: rgb(0, 112, 32); font-weight: bold;">from</span> <span class="nn" style="color: rgb(14, 132, 181); font-weight: bold;">typing</span> <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">]])</span> <span class="o" style="color: rgb(102, 102, 102);">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">]]:</span>
    <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">pass</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">可以这样提高可读性:</p><div class="highlight-python3 notranslate" style="text-align: justify; position: relative; background-color: rgb(255, 255, 255); font-size: 16px; font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; color: rgb(34, 34, 34);"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="kn" style="color: rgb(0, 112, 32); font-weight: bold;">from</span> <span class="nn" style="color: rgb(14, 132, 181); font-weight: bold;">typing</span> <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="n">Color</span> <span class="o" style="color: rgb(102, 102, 102);">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">,</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span><span class="p">]</span>

<span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">def</span> <span class="nf" style="color: rgb(6, 40, 126);">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o" style="color: rgb(102, 102, 102);">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">pass</span></pre></div></div><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/typing.html#module-typing" title="typing: Support for type hints (see PEP 484)." style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">typing</span></a>&nbsp;和&nbsp;<span class="target" id="index-96" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" style="">PEP 484</a>，其中有对此功能的详细描述。</p><h5>type hint – 类型提示</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;"><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-annotation" style="">annotation</a>&nbsp;为变量、类属性、函数的形参或返回值指定预期的类型。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">类型提示属于可选项，Python 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">全局变量、类属性和函数的类型提示可以使用&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/typing.html#typing.get_type_hints" title="typing.get_type_hints" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">typing.get_type_hints()</span></a>&nbsp;来访问，但局部变量则不可以。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/typing.html#module-typing" title="typing: Support for type hints (see PEP 484)." style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">typing</span></a>&nbsp;和&nbsp;<span class="target" id="index-97" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" style="">PEP 484</a>，其中有对此功能的详细描述。</p><h5>universal newlines – 通用换行</h5><p><span style="text-align: justify;">一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">'\n'</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">、Windows 的约定&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">'\r\n'</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;以及旧版 Macintosh 的约定&nbsp;</span><span class="pre" style="padding: 0px 1px; border-radius: 3px; text-align: justify; hyphens: none;">'\r'</span><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">。参见&nbsp;</span><span class="target" id="index-98" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0278" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 278</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;和&nbsp;</span><span class="target" id="index-99" style="text-align: justify; padding-right: 1px; padding-left: 1px; border-radius: 3px;"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3116" style="padding: 0px 1px; border-radius: 3px; text-align: justify;">PEP 3116</a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;和&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.splitlines" title="bytes.splitlines" style="padding: 0px 1px; border-radius: 3px; text-align: justify;"><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">bytes.splitlines()</span></a><span style="padding: 0px 1px; border-radius: 3px; text-align: justify;">&nbsp;了解更多用法说明。</span><br></p><h5>variable annotation – 变量标注</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">对变量或类属性的&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-annotation" style="">annotation</a>。</p><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">在标注变量或类属性时，还可选择为其赋值:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="k" style="color: rgb(0, 112, 32); font-weight: bold;">class</span> <span class="nc" style="color: rgb(14, 132, 181); font-weight: bold;">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1" style="color: rgb(64, 112, 160);">'annotation'</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">变量标注通常被用作&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-type-hint" style="">类型提示</a>：例如以下变量预期接受&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/functions.html#int" title="int" style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">int</span></a>&nbsp;类型的值:</p><div class="highlight-python3 notranslate" style="color: rgb(34, 34, 34); font-family: &quot;Lucida Grande&quot;, Arial, sans-serif; font-size: 16px; text-align: justify; background-color: rgb(255, 255, 255); position: relative;"><div class="highlight" style="background: rgb(238, 255, 204);"><pre style="overflow-y: hidden; padding: 5px; background-color: rgb(238, 255, 204); color: rgb(51, 51, 51); line-height: 18.528px; border: 1px solid rgb(170, 204, 153); font-family: monospace, sans-serif; font-size: 15.44px;"><span class="n">count</span><span class="p">:</span> <span class="nb" style="color: rgb(0, 112, 32);">int</span> <span class="o" style="color: rgb(102, 102, 102);">=</span> <span class="mi" style="color: rgb(32, 128, 80);">0</span></pre></div></div><p style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">变量标注语法的详细解释见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#annassign" style="">Annotated assignment statements</a>&nbsp;一节。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">请参看&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-function-annotation" style="">function annotation</a>、<span class="target" id="index-100" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484" style="">PEP 484</a>&nbsp;和&nbsp;<span class="target" id="index-101" style=""></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526" style="">PEP 526</a>，其中对此功能有详细描述。</p><h5>virtual environment – 虚拟环境</h5><p class="first" style="hyphens: auto; line-height: 22.4px; margin-top: 0px !important;">一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。</p><p class="last" style="margin-top: 0px; hyphens: auto; line-height: 22.4px;">另参见&nbsp;<a class="reference internal" href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv" title="venv: Creation of virtual environments." style=""><span class="pre" style="padding: 0px 1px; border-radius: 3px; hyphens: none;">venv</span></a>。</p><h5>virtual machine – 虚拟机</h5><p><span style="text-align: justify;">一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的&nbsp;</span><a class="reference internal" href="https://docs.python.org/zh-cn/3/glossary.html#term-bytecode" style="text-align: justify;"><span class="xref std std-term">bytecode</span></a><span style="text-align: justify;">。</span><br></p><h5>Zen of Python – Python 之禅</h5><p>列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 “import this”。<br></p><p><br></p>
</article>
{% endblock point1 %}

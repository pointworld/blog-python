{% extends 'c-word.html' %}

{% block title %} canvas - computer | web | HTML {% endblock title %}

{% block point1 %}
<article contenteditable="true">
  <p>Category: computer | web | HTML | canvas</p>
  <h1 id="blogTitle0">canvas</h1><h2 id="blogTitle1">canvas</h2><div>width</div><div>height</div><div>getContext('2d' | 'webgl')</div><h3 id="blogTitle2">Introduction</h3><h4 id="blogTitle3">Definition</h4><p>canvas 是 HTML5 新增的元素，可用于通过使用 JavaScript 中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。</p><h3 id="blogTitle4">HTML canvas 元素接口</h3><p>DOM canvas 元素暴露了 HTMLCanvasElement 接口，该接口提供了用来操作一个 canvas 元素布局和呈现的属性和方法。HTMLCanvasElement 接口继承了 element 接口的属性和方法。<br></p><h4 id="blogTitle5">属性</h4><div><div><ul><li>width - HTML 中对应标签的 width 属性的值，指定了该元素所占空间的高度，单位为像素<br></li><li>height - HTML 中对应标签的 height 属性的值，指定了该元素所占空间的高度，单位为像素<br></li></ul></div></div><h4 id="blogTitle6">方法</h4><table><caption>table 1.1 heading</caption><tbody><tr><th>方法名和参数</th><th>返回值</th><th>描述</th></tr><tr><td>getContext(contextId)</td><td>object</td><td>返回 canvas 的绘制上下文，如果指定的上下文 ID 不支持，则返回null。目前可接受的参数有 "2d" 和 "experimental-webgl"。"experimental-webgl" 上下文只在那些实现了 WebGL 的浏览器上可用。调用 getContext("2d") 会返回一个&nbsp; CanvasRenderingContext2D 对象，调用 getContext("experimental-webgl") 会返回一个 WebGLRenderingContext 对象。</td></tr><tr><td>toDataURL(type,...args)</td><td>DOMString<br></td><td>返回一个 data: URL，根据 type 参数指定的类型，将包含在 canvas 中的图片文件编码成字符串形式，type 参数的默认值为 image/png。<br><ul><li>如果该 canvas 的宽度或长度是 0，则会返回字符串 "data:,"</li><li>如果指定的 type 参数不是 image/png，但返回的字符串是以 data:image/png 开头的，则所请求的图片类型不支持<br></li><li>Chrome 支持 image/webp 类型<br></li><li>如果 type 参数的值为 image/jpeg 或 image/webp，则第二个参数的值如果在 0.0 和 1.0 之间的话，会被看作是图片质量参数，如果第二个参数的值不在 0.0 和 1.0 之间，则会使用默认的图片质量<br></li></ul></td></tr><tr><td>toBlob(cb,type,...args)&nbsp;</td><td>Blob</td><td>返回一个 Blob 对象，表示包含在该 canvas 中的图片文件，这个文件可能缓存在硬盘上，也可能存储在内存中，这由浏览器决定。如果没有指定 type 参数，则默认使用 image/png</td></tr></tbody></table><blockquote>DOMString 是一个 UTF-16 字符串。由于 JavaScript 已经使用了这样的字符串，所以 DOMString 直接映射到 一个 String</blockquote><blockquote>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</blockquote><p><br></p><p><br></p><p><br></p><h2 id="blogTitle7">HTML Canvas 2D Context</h2><h3 id="blogTitle8">图形（矢量图）和图像（位图）</h3><div><ul><li>点<br></li><li>图形的基本元素是路径<br></li><ul><li>路径是（通过不同颜色和宽度的线段或曲线相连形成的不同形状的）点的集合，是一个由 0 个或多个子路径构成的列表，Each subpath consists of a list of one or more points, connected by straight or curved lines, and a flag indicating whether the subpath is closed or not</li><ul><li><b>创建起始点</b>：beginPath() - 调用该方法后，列表被清空重置</li><li><b>绘制路径</b>：调用相关绘制函数</li><li><b>封闭路径</b>：closePath() - 不是必需的，该方法通过绘制一条从当前点到开始点的直线来闭合图形</li><li><b>渲染图形（描边或填充）</b>：调用相关渲染函数</li></ul></ul><li>位图与矢量图</li><ul><li>位图，又称点阵图像、像素图或栅格图像，是由称作像素（图片元素）的单个点组成。这些点可以进行不同的排列和染色以构成图样。</li><ul><li>位图的单位：像素（Pixel）：指可以表现亮度甚至色彩变化的一个点，是构成数字图像的最小单位。像素具有大小相同、明暗和颜色的变化。特点是由固定的位置和特定的颜色值。</li><li>位图的特点：位图图像善于重现颜色的细微层次，能够制作出色彩和亮度变化丰富的图像，可逼真地再现这个世界，文件庞大，不能随意缩放；打印和输出的精度是有限的。</li><li>位图的文件格式：位图的文件类型很多，如*.bmp、*.pcx、*.gif、*.jpg、*.tif、photoshop的*.psd、kodak photo CD的*.pcd、corel photo paint的*.cpt等。同样的图形，存盘成以上几种文件时文件的字节数会有一些差别，尤其是jpg格式，它的大小只有同样的bmp格式的1/20到1/35，这是因为它们的点矩阵经过了复杂的压缩算法的缘故。</li><li>位图文件的规律：</li><ul><li>图形面积越大，文件的字节数越多；</li><li>文件的色彩越丰富，文件的字节数越多。</li></ul><li>常用的位图软件：Photoshop、Photo Painter、Photo Impact、Paint Shop Pro、Painter等。<br></li></ul><li>矢量图，矢量又称为“向量”，矢量图形中的图形元素（点和线段）称为对象，每个对象都是一个单独的个体，它具有大小、方向、轮廓、颜色和屏幕位置等属性。简单地说，矢量图形软件就是用数学的方法来绘制矩形等基本形状。</li><ul><li>矢量图特点：矢量图形能重现清晰的轮廓，线条非常光滑、且具有良好的缩放性；因为图像中保存的是线条和图块的信息，与分辨率和图形大小无关，只与图像的复杂程度有关，所以图像文件所占的存储空间交较小；此外文字编辑能力强。与位图相比，在显示和打印方面都快的多；图形不真实生动，颜色不丰富。无法像照片一样真实地再现这个世界的景色。</li><li>矢量图的文件格式：如Corel DRAW的*.cdr、Adobe Illustrator的*.AI、*.EPS和SVG、AutoCAD的*.dwg和dxf、windows标准图元文件*.wmf和增强型图元文件*.emf等等。<br></li><li>矢量图形文件的规律：</li><ul><li>可以无限放大图形中的细节，不用担心会造成失真和色块。</li><li>一般的线条的图形和卡通图形，存成矢量图文件就比存成位图文件要小很多。</li><li>存盘后文件的大小与图形中元素的个数和每个元素的复杂程度成正比。而与图形面积和色彩的丰富程度无关。（元素的复杂程度指的是这个元素的结构复杂度，如五角星就比矩形复杂、一个任意曲线就比一个直线段复杂）。</li><li>通过软件，矢量图可以轻松地转化为位图，而位图转化为矢量图就需要经过复杂而庞大的数据处理，而且生成的矢量图的质量绝对不能和原来的图形比拟。</li></ul><li>常用的矢量绘图软件：Illustrator、CorelDraw、FreeHand、AutoCAD等。<br></li></ul></ul></ul></div><div><br></div><h3 id="blogTitle9">api - Conformance requirements</h3><pre>interface CanvasRenderingContext2D {
<br>&nbsp; // back-reference to the canvas&nbsp;<br>&nbsp; canvas // returns the canvas element that the context paints on，对 HTMLCanvasElement 只读的反向引用。如果和 &lt;canvas&gt; 元素没有联系，可能为null
<br>&nbsp; // state, canvas 状态<br>&nbsp; save()     // Pushes the current state onto the state stack，使用栈保存当前的绘画样式状态，可以使用 restore() 恢复任何改变<br>&nbsp; restore()  // Pops the top state on the stack, restoring the context to that state，恢复到最近的绘制样式状态，此状态是通过 save() 保存到”状态栈“中最新的元素
<br>&nbsp; // transformations (default: transform is the identity matrix)，变换<br>&nbsp; scale(x, y)&nbsp;                    // 缩放，Changes the transformation matrix to apply a scaling transformation with the given characteristics，根据 x 水平方向和 y 垂直方向，为canvas 单位添加缩放变换<br>&nbsp; rotate(angle)                   // 旋转，Changes the transformation matrix to apply a rotation transformation with the given characteristics. The angle is in radians，在变换矩阵中增加旋转，角度变量表示一个顺时针旋转角度并且用弧度表示<br>&nbsp; translate(x, y)                 // 平移，Changes the transformation matrix to apply a translation transformation with the given characteristics，通过在网格中移动 canvas 和 canvas 原点 x 水平方向、原点 y 垂直方向，添加平移变换<br>&nbsp; transform(a, b, c, d, e, f)     // 变形，Changes the transformation matrix to apply the matrix given by the arguments，使用方法参数描述的矩阵多次叠加当前的变换矩阵(不会覆盖当前的变换矩阵，会多次叠加变换)，a (m11): 水平缩放; b (m12): 水平倾斜; c (m21): 垂直倾斜; d (m22): 垂直缩放; e (dx): 水平移动; f (dy): 垂直移动<br>&nbsp; setTransform(a, b, c, d, e, f)  // 重置，Changes the transformation matrix to the matrix given by the arguments，重新设置当前的变换为单位矩阵(会覆盖当前的变换矩阵)，并使用同样的变量调用 transform() 方法
  resetTransform()                // 使用单位矩阵重新设置当前的变换
<br>&nbsp; // Compositing，合成<br>&nbsp; globalAlpha [ = transparencyValue ]  // (default: 1.0), sets or returns the current alpha value applied to rendering operations，在合成到 canvas 之前，设置图形和图像透明度的值。默认 1.0 (不透明)<br>&nbsp; globalCompositeOperation [ = value ] // (default: "source-over"), sets or returns the current composition operation，设置要在绘制新形状时应用的合成操作的类型，其中 type 是用于标识要使用的合成或混合模式操作的字符串，type 取值：source-over source-in source-out source-atop destination-over destination-in destination-out destination-atop lighter copy xor multiply screen overlay darken lighten color-dodge color-burn hard-light soft-light difference exclusion hue saturation color luminosity
<br>&nbsp; // colors and styles (see also the CanvasDrawingStyles interface)，颜色和样式<br>&nbsp; strokeStyle [ = color | gradient | pattern ]&nbsp;// (default: "black"), set or get current stroke style，描边设计用于图形的边线<br>&nbsp; fillStyle [ = color | gradient | pattern ]   // (default: "black"), set or get current fill style，填充设计用于图形内部的颜色和样式<br>&nbsp; createLinearGradient(x0, y0, x1, y1)         // Returns a CanvasGradient object that represents a linear gradient that paints along the line given by the coordinates represented by the arguments，创建一个沿参数坐标指定的直线的渐变。该方法返回一个线性 CanvasGradient对象<br>&nbsp; createRadialGradient(x0, y0, r0, x1, y1, r1) // Returns a CanvasGradient object that represents a radial gradient that paints along the cone given by the circles represented by the arguments，创建一个沿着参数坐标指定的线的放射性性渐变<br>&nbsp; createPattern(image, repetition)             // 使用指定的图片创建图案。通过 repetition 变量指定的方向上重复源图片（repetition 取值：'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat'）。此方法返回 CanvasPattern 对象
<br>&nbsp; // Shadows，阴影<br>&nbsp; shadowOffsetX [ = value ] // (default: 0), sets or returns the current shadow offset，阴影水平方向的偏移量<br>&nbsp; shadowOffsetY [ = value ] // (default: 0), sets or returns the current shadow offset，阴影垂直方向的偏移量<br>&nbsp; shadowBlur [ = level ]    // (default: 0), sets or returns the current level of blur applied to shadows，描述模糊效果，注意：只有设置shadowColor属性值为不透明，阴影才会被绘制<br>&nbsp; shadowColor [ = value ]   // (default: "transparent black"), sets or returns the current shadow color，阴影的颜色
<br>&nbsp; // rects, Drawing rectangles to the canvas，绘制矩形位图<br>&nbsp; clearRect(x, y, w, h)  // Clears all pixels on the canvas in the given rectangle to transparent black，设置指定矩形区域内（以 点 (x, y) 为起点，范围是(width, height) ）所有像素变成透明，并擦除之前绘制的所有内容<br>&nbsp; fillRect(x, y, w, h)   // Paints the given rectangle onto the canvas, using the current fill style，使用当前的绘画样式，绘制填充矩形，矩形的起点在 (x, y) 位置，矩形的尺寸是 width 和 height<br>&nbsp; strokeRect(x, y, w, h) // Paints the box that outlines the given rectangle onto the canvas, using the current stroke style，使用当前的绘画样式，描绘一个起点在 (x, y) 、宽度为 w 、高度为 h 的矩形
<br>&nbsp; // path API (see also CanvasPathMethods), Drawing paths to the canvas，绘制路径  <br>&nbsp; fill([path])                         // Fills the subpaths of the current path or the given path with the current fill style，使用当前的样式填充子路径，采取非零环绕或者奇偶环绕规则
  fill(fillRule)                       // fillRule: 一种算法，决定点是在路径内还是在路径外；允许的值："nonzero": 非零环绕规则（默认的规则），"evenodd": 奇偶环绕规则
  fill(path, fillRule)                 // path: 需要填充的 Path2D 路径<br>&nbsp; stroke([path])                       // Strokes the subpaths of the current path or the given path with the current stroke style，使用非零环绕规则，根据当前的画线样式，绘制当前或已经存在的路径<br>&nbsp; drawFocusIfNeeded(element)           // Informs the user of the canvas location for the fallback element, based on the current path. If the given element has focus, draws a focus outline around the current path following the platform or user agent conventions for focus outlines as defined by the user agent，如果给定的元素获取了焦点，那么此方法会在当前的路径绘制一个焦点
  drawFocusIfNeeded(path, element)     // element: 需要设置焦点的元素；path: Path2D 路径<br>&nbsp; clip()                               // Further constrains the clipping region to the current path,从当前路径创建一个剪切路径。在  clip() 调用之后，绘制的所有信息只会出现在剪切路径内部
  clip(fillRule)                       //
  clip(path, fillRule)                 //<br>&nbsp; isPointInPath(x, y)                  // Returns true if the given point is in the current path，判断当前路径是否包含检测点
  isPointInPath(x, y, fillRule)        //
  isPointInPath(path, x, y)            //
  isPointInPath(path, x, y, fillRule)  //
  isPointInStroke(x, y)                // 判断检测点是否在路径的描边线上      
  isPointInStroke(path, x, y)          // 
  ？ scrollPathIntoView()              // 将当前或给定的路径滚动到窗口
<br>&nbsp; // text (see also the CanvasDrawingStyles interface), Drawing text to the canvas，绘制文本<br>&nbsp; fillText(text, x, y [, maxWidth])   // Fills the given text at the given position. If a maximum width is provided, the text will be scaled to fit that width if necessary. 在给定的 (x, y) 位置绘制（填充）文本的方法。如果提供了表示最大值的第四个参数，文本将会缩放适应宽度<br>&nbsp; strokeText(text, x, y [, maxWidth]) // Strokes the given text at the given position. If a maximum width is provided, the text will be scaled to fit that width if necessary. 在给定的 (x, y) 位置绘制文本的方法。如果提供了表示最大值的第四个参数，文本将会缩放适应宽度<br>&nbsp; metrics = context.measureText(text) // Returns a TextMetrics object with the metrics of the given text in the current font，返回一个 TextMetrics 对象，包含关于文本尺寸的信息（例如文本的宽度）
  metrics.width                       // Returns the advance width of the text that was passed to the measureText() method
<br>&nbsp; // Drawing images to the canvas，绘制图像<br>&nbsp; drawImage(image, dx, dy)                         //<br>&nbsp; drawImage(image, dx, dy, dw, dh)                 //<br>&nbsp; drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) // 
<br>&nbsp; // Hit regions，点击区域<br>&nbsp; addHitRegion(options) // Adds a hit region to the canvas bitmap based on the current default path. The argument is an object with the following members: id (default empty string), control (default null)，给 canvas 添加点击区域<br>&nbsp; removeHitRegion(id)   // Removes a hit region from the canvas bitmap. The argument is the ID of a region added using addHitRegion()，从 canvas 中删除指定 id  的点击区域<br>&nbsp; clearHitRegions()     // Removes all hit regions from the canvas bitmap，从 canvas 中删除所有的点击区域
<br>&nbsp; // Pixel manipulation，像素控制<br>&nbsp; imagedata = context.createImageData(sw, sh)                              // Returns an ImageData object with the given dimensions in CSS pixels (which might map to a different number of actual device pixels exposed by the object itself). All the pixels in the returned object are transparent black，使用指定的尺寸，创建一个新的、空白的 ImageData 对象。所有的像素在新对象中都是透明的<br>&nbsp; imagedata = context.createImageData(imagedata)                           // Returns an ImageData object with the same dimensions as the argument. All the pixels in the returned object are transparent black, 从现有的 ImageData 对象中，复制一个和其宽度和高度相同的对象。图像自身不允许被复制<br>&nbsp; imagedata = context.getImageData(sx, sy, sw, sh)                         // Returns an ImageData object containing the image data for the given rectangle of the canvas，返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh<br>&nbsp; imagedata.width                                                          // Returns the actual dimensions of the data in the ImageData object, in device pixels
  imagedata.height                                                         // Returns the actual dimensions of the data in the ImageData object, in device pixels
  imagedata.data                                                           // Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255
  putImageData(imagedata, dx, dy)                                          // Paints the data from the given ImageData object onto the canvas. If a dirty rectangle is provided, only the pixels from that rectangle are painted，将数据从已有的 ImageData 对象绘制到位图的方法。 此方法不受画布转换矩阵的影响<br>&nbsp; putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) // Paints the data from the given ImageData object onto the canvas. If a dirty rectangle is provided, only the pixels from that rectangle are painted，将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响
<br>}
<br>CanvasRenderingContext2D implements CanvasDrawingStyles<br>CanvasRenderingContext2D implements CanvasPathMethods

// [NoInterafceObject]<br>interface CanvasDrawingStyles {
<br>&nbsp; // line caps/joins，线条样式<br>&nbsp; lineWidth [ = value ]  // (default: 1)，设置或返回当前线条宽度<br>&nbsp; lineCap [ = type ]     // "butt", "round", "square" (default: "butt")，设置或返回线条末端样式<br>&nbsp; lineJoin [ = type ]    // "round", "bevel", "miter" (default: "miter")，设置或返回线条与线条间结合处的样式<br>&nbsp; miterLimit [ = value ] // (default: 10)，限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度
<br>&nbsp; // dashed lines，虚线<br>&nbsp; setLineDash(segments)            // (default: empty)，设置当前虚线样式<br>&nbsp; segments = context.getLineDash() // 返回一个包含当前虚线样式、长度为非负偶数的数组<br>&nbsp; lineDashOffset [ = value ]       // 设置或返回虚线样式的起始偏移量<br>&nbsp; 
  // text，文本样式<br>&nbsp; font [ = value ]         // (default: "10px sans-serif")，设置或返回当前字体<br>&nbsp; textAlign [ = value ]    // "start", "end", "left", "right", "center" (default: "start")，设置或返回当前文本对齐方式<br>&nbsp; textBaseline [ = value ] // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")，设置或返回当前文本基线的对齐方式&nbsp;<br>  ? direction [ = value ]    // "ltr", "rtl", inherit (default: "inherit")，设置或获取文本的方向

}

// [NoInterafceObject]，路径
interface CanvasPathMethods {
<br>&nbsp; // shared path API methods
  beginPath()                                                          // Resets the current path，清空子路径列表并开始一个新的路径。当你想创建一个新的路径时，调用此方法。<br>&nbsp; closePath()                                                          // Marks the current subpath as closed, and starts a new subpath with a point the same as the start and end of the newly closed subpath，// 使笔点返回到当前子路径的起始点。它尝试从当前点到起始点绘制一条直线。如果图形已经是封闭的或者只有一个点，那么此方法不会做任何操作。<br>&nbsp; moveTo(x, y)                                                         // Creates a new subpath with the given point，将一个新的子路径的起始点移动到(x，y)坐标<br>&nbsp; lineTo(x, y)                                                         // Adds the given point to the current subpath, connected to the previous one by a straight line，使用直线连接子路径的最后的点到x,y坐标（并不会真正地绘制）<br>&nbsp; quadraticCurveTo(cpx, cpy, x, y)                                     // Adds the given point to the current subpath, connected to the previous one by a quadratic Bezier curve with the given control point，添加一个2次贝赛尔曲线路径<br>&nbsp; bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)                          // Adds the point to the current subpath, connected to the previous one by a cubic Bezier curve with the given control points，添加一个3次贝赛尔曲线路径。该方法需要三个点。 第一、第二个点是控制点，第三个点是结束点。起始点是当前路径的最后一个点，绘制贝赛尔曲线前，可以通过调用 moveTo() 进行修改<br>&nbsp; arcTo(x1, y1, x2, y2, radius)                                        // Adds an arc with the given control points and radius to the current subpath, connected to the previous point by a straight line<br>&nbsp; rect(x, y, w, h)                                                     // Adds a new closed subpath to the path, representing the given rectangle，创建一个矩形路径，矩形的起点位置是 (x, y) ，尺寸为 width 和 height<br>&nbsp; arc(x, y, radius, startAngle, endAngle [, counterclockwise = false]) // Adds points to the subpath such that the arc described by the circumference of the circle described by the arguments, starting at the given start angle and ending at the given end angle, going in the given direction (defaulting to clockwise), is added to the path, connected to the previous point by a straight line, 绘制一段圆弧路径， 圆弧路径的圆心在 (x, y) 位置，半径为 r ，根据anticlockwise （默认为顺时针）指定的方向从 startAngle 开始绘制，到 endAngle 结束
  ellipse(x, y, radiusX, radiusY, anticlockwise)                       // 添加一个椭圆路径，椭圆的圆心在（x,y）位置，半径分别是radiusX 和 radiusY ，按照anticlockwise （默认顺时针）指定的方向，从 startAngle  开始绘制，到 endAngle 结束。<br>
}
<br>interface CanvasGradient {<br>&nbsp; // opaque object<br>&nbsp; addColorStop(offset, color) // Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset at one end of the gradient, 1.0 is the offset at the other end<br>}
<br>interface CanvasPattern {<br>&nbsp; // opaque object<br>}
<br>interface ImageData {<br>&nbsp; width<br>&nbsp; height<br>&nbsp; data<br>}

// 缓存或记录绘画命令
interface Path2D {

  addPath()
  closePath()
  moveTo()
  lineTo()
  bezierCurveTo()
  quadraticCurveTo()
  arc()
  arcTo()
  ellipse()
  rect()

}

// Extends，拓展
interface Extends {

  imageSmoothingEnabled // 图像平滑的方式；如果禁用，缩放时，图像不会被平滑处理（缩放图像会失真）, true表示图片平滑（默认值），false表示图片不平滑, 以缩放画布为例，这个属性对像素为主的游戏很有用。默认的改变大小的算法会造成图片模糊并且破坏图片原有的像素。 如果那样的话，设置属性值为false

}</pre><h3 id="blogTitle10">The canvas state</h3><p></p><ul><li>save()<br></li><li>restore()<br></li></ul><p></p><p>Each context maintains a stack of drawing states. <b>Drawing states</b> consist of:</p><p></p><ul><li>The current transformation matrix.<br></li><li>The current clipping region.<br></li><li>The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline.<br></li></ul><blockquote>The current path and the current bitmap are not part of the drawing state. The current path is persistent, and can only be reset using the beginPath() method. The current bitmap is a property of the canvas, not the context.</blockquote><p></p><h3 id="blogTitle11">Line styles</h3><div>lineWidth [ = value ]</div><div>lineCap [ = <u>butt</u> | round | square ]</div><div>lineJoin [ = bevel | round | <u>miter</u> ]<br>miterLimit [ = value ]&nbsp;</div><div>setLineDash(segment)</div><div>getLineDash()</div><div>lineDashOffset [ = value ]</div><h3 id="blogTitle12">Text styles</h3><h3 id="blogTitle13">Building paths</h3><h3 id="blogTitle14">Transformations</h3><h3 id="blogTitle15">Image sources for 2D rendering contexts</h3><h3 id="blogTitle16">Fill and stroke styles</h3><h3 id="blogTitle17">Drawing rectangles to the canvas</h3><h3 id="blogTitle18">Drawing text to the canvas</h3><h3 id="blogTitle19">Drawing text to the canvas</h3><h3 id="blogTitle20">Drawing paths to the canvas</h3><h3 id="blogTitle21">Drawing images to the canvas</h3><h3 id="blogTitle22">Hit regions</h3><h3 id="blogTitle23">Pixel manipulation</h3><h3 id="blogTitle24">Compositing</h3><h3 id="blogTitle25">Shadows</h3><h3 id="blogTitle26">Drawing model</h3><h2 id="blogTitle27">PW</h2><div><h3 id="blogTitle28">CanvasRenderingContext.prototype</h3></div><h3 id="blogTitle29">extends CanvasRenderingContext.prototype</h3><p>object: point, path(set of points), line, text, graphics,</p><p>methods: draw..., get..., set..., clear..., fill..., stroke..., moveTo, lineTo, beginPath(), closePath()</p><p>properties</p><h3 id="blogTitle30">Object</h3><h4 id="blogTitle31">Point</h4><h4 id="blogTitle32">Line</h4><p>segment</p><p>straight</p><p>curve</p><p>broken</p><p>dash</p><h4 id="blogTitle33">Polygon</h4><h5 id="blogTitle34">Triangle</h5><h5 id="blogTitle35">Rectangle</h5><p>rect</p><p>roundedRect</p><h5 id="blogTitle36">Circle</h5><h2 id="blogTitle37">OPEN YOUR MIND</h2><p>有很少种方式可以在 canvas 上画一个点？</p><p>1.&nbsp;</p><p></p><ul><li>ctx.beginPath()<br></li><li>ctx.moveTo(10,10)<br></li><li>ctx.lineTo(11,11)<br></li><li>ctx.stroke()<br></li></ul><p></p><p>2.&nbsp;</p><p></p><ul><li>ctx.strokeStyle = "green";<br></li><li>ctx.fillRect(10, 10, 1, 1);<br></li></ul><p></p><p>3.</p><p>ctx.fillText(".", 100, 100);<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>
</article>
{% endblock point1 %}

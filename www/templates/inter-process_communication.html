{% extends 'c-word.html' %}

{% block title %} IPC (Inter-Process Communication) - computer | network {% endblock title %}

{% block point1 %}
<article contenteditable="true">
  <p>Category: computer | network | IPC (Inter-Process Communication)</p>
  <h1 id="blogTitle0">&nbsp;IPC (Inter-Process Communication)<br></h1><h2>概述</h2><h3>定义</h3><div><div class="lemma-summary" label-module="lemmaSummary" style="clear: both; font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);"><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">进程间通信就是在不同进程之间传播或交换信息，那么不同进程之间存在着什么双方都可以访问的介质呢？进程的<a target="_blank" href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/1178094" data-lemmaid="1178094" style="color: rgb(19, 110, 194); text-decoration-line: none;">用户空间</a>是互相独立的，一般而言是不能互相访问的，唯一的例外是<a target="_blank" href="https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98" style="color: rgb(19, 110, 194); text-decoration-line: none;">共享内存</a>区。另外，系统空间是“公共场所”，各进程均可以访问，所以<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8/108410" data-lemmaid="108410" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>也可以提供这样的条件。此外，还有双方都可以访问的外设。在这个意义上，两个进程当然也可以通过磁盘上的普通文件交换信息，或者通过“注册表”或其它数据库中的某些表项和记录交换信息。广义上这也是进程间通信的手段，但是一般都不把这算作“进程间通信”。</div><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。IPC接口就提供了这种可能性。<br></div><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1;">IPC方法包括管道（PIPE）、消息排队、旗语、共用内存以及套接字（Socket）。<br></div></div></div><div><br></div><h3>分类</h3><div><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">进程间通信主要包括</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">管道</h4><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">管道包括三种:</div><div class="para" label-module="para" style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;"><ul><li>普通管道：PIPE，通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.<br></li><li>流管道；s_pipe，去除了第一种限制,为半双工，可以双向传输.<br></li><li><a target="_blank" href="https://baike.baidu.com/item/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93">命名管道</a>：name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.<br></li></ul><div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">管道是单向的、先进先出的、无结构的、固定大小的<a target="_blank" href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E6%B5%81" style="color: rgb(19, 110, 194); text-decoration-line: none;">字节流</a>，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">传统上有很多种实现管道的方法，如利用文件系统、利用<a target="_blank" href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97" style="color: rgb(19, 110, 194); text-decoration-line: none;">套接字</a>（sockets）、利用流等。在Linux中，使用两个file数据结构来实现管道。这两个file数据结构中的f_inode（f_dentry）<a target="_blank" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" style="color: rgb(19, 110, 194); text-decoration-line: none;">指针</a>指向同一个临时创建的VFS I节点，而该VFS I节点本身又指向内存中的一个物理页，如图5.1所示。两个file数据结构中的f_op指针指向不同的文件操作例程向量表：一个用于向管道中写，另一个用于从管道中读。这种实现方法掩盖了底层实现的差异，从进程的角度来看，读写管道的<a target="_blank" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" style="color: rgb(19, 110, 194); text-decoration-line: none;">系统调用</a>和读写普通文件的普通系统调用没什么不同。当写进程向管道中写时，字节被拷贝到了共享数据页，当读进程从管道中读时，字节被从共享页中拷贝出来。Linux必须同步对于管道的存取，必须保证管道的写和读步调一致。Linux使用锁、<a target="_blank" href="https://baike.baidu.com/item/%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97" style="color: rgb(19, 110, 194); text-decoration-line: none;">等待队列</a>和信号（locks，wait queues and signals）来实现同步。</div></div></div></div><h4><span style="text-indent: 28px;">系统 IPC</span></h4><h5><a target="_blank" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" style="text-indent: 28px;">消息队列</a></h5><h5><span style="text-indent: 28px;">信号</span></h5><div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">信号（Signals ）是 Unix 系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的<a target="_blank" href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" style="color: rgb(19, 110, 194); text-decoration-line: none;">虚拟内存</a>中不存在的位置等）都有可能产生一个信号。Shell 也使用信号向它的子进程发送<a target="_blank" href="https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6" style="color: rgb(19, 110, 194); text-decoration-line: none;">作业控制</a>信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">信号是在Unix System V中首先引入的，它实现了15种信号，但很不可靠。BSD4.2解决了其中的许多问题，而在BSD4.3中进一步加强和改善了信号机制。但两者的接口不完全兼容。在Posix 1003.1标准中做了一些强行规定，它定义了一个标准的信号接口，但没有规定接口的实现。目前几乎所有的Unix变种都提供了和Posix标准兼容的信号实现机制。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">一、 在一个信号的生命周期中有两个阶段：生成和传送。当一个事件发生时，需要通知一个进程，这时生成一个信号。当进程识别出信号的到来，就采取适当的动作来传送或处理信号。在信号到来和进程对信号进行处理之间，信号在进程上挂起（pending）。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);"><a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>为进程生产信号，来响应不同的事件，这些事件就是信号源。主要的信号源如下：</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">异常：进程运行过程中出现异常；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">其它进程：一个进程可以向另一个或一组进程发送信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">终端中断：Ctrl-C，Ctrl-\等；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);"><a target="_blank" href="https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6" style="color: rgb(19, 110, 194); text-decoration-line: none;">作业控制</a>：前台、后台进程的管理；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">分配额：CPU超时或文件大小突破限制；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">通知：通知进程某事件发生，如I/O就绪等；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">报警：计时器到期。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">在 Linux 中，信号的种类和数目与硬件平台有关。<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>用一个字代表所有的信号，每个信号占一位，因此一个字的位数就是系统可以支持的最多信号种类数。i386 平台上有32 种信号，而Alpha AXP 平台上最多可有 64 种信号。系统中有一组定义好的信号，它们可以由内核产生，也可以由系统中其它有权限的进程产生。可以使用kill命令列出系统中的信号集。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">下面是几个常见的信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGHUP： 从终端上发出的结束信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGINT： 来自键盘的中断信号（Ctrl-C）；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGQUIT：来自键盘的退出信号（Ctrl-\）；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGFPE： 浮点异常信号（例如<a target="_blank" href="https://baike.baidu.com/item/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97" style="color: rgb(19, 110, 194); text-decoration-line: none;">浮点运算</a>溢出）；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGKILL：该信号结束接收信号的进程；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGALRM：进程的定时器到期时，发送该信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGTERM：kill 命令发出的信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGCHLD：标识子进程停止或结束的信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">SIGSTOP：来自键盘（Ctrl-Z）或调试程序的停止执行信号；</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">…………</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">每一个信号都有一个缺省动作，它是当进程没有给这个信号指定处理程序时，内核对信号的处理。有5种缺省的动作：</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">异常终止（abort）：在进程的当前目录下，把进程的<a target="_blank" href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" style="color: rgb(19, 110, 194); text-decoration-line: none;">地址空间</a>内容、寄存器内容保存到一个叫做core的文件中，而后终止进程。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">退出（exit）：不产生core文件，直接终止进程。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">忽略（ignore）：忽略该信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">停止（stop）：挂起该进程。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">继续（continue）：如果进程被挂起，则恢复进程的运行。否则，忽略信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">进程可以对任何信号指定另一个动作或<a target="_blank" href="https://baike.baidu.com/item/%E9%87%8D%E8%BD%BD" style="color: rgb(19, 110, 194); text-decoration-line: none;">重载</a>缺省动作，指定的新动作可以是忽略信号。进程也可以暂时地阻塞一个信号。因此进程可以选择对某种信号所采取的特定操作，这些操作包括：</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">忽略信号：进程可忽略产生的信号，但 SIGKILL 和 SIGSTOP 信号不能被忽略,必须处理（由进程自己或由<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>处理）。进程可以忽略掉系统产生的大多数信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">阻塞信号：进程可选择阻塞某些信号，即先将到来的某些信号记录下来，等到以后（解除阻塞后）再处理它。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">由进程处理该信号：进程本身可在系统中注册处理信号的处理程序地址，当发出该信号时，由注册的处理程序处理信号。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">由内核进行缺省处理：信号由内核的缺省处理程序处理，执行该信号的缺省动作。例如，进程接收到SIGFPE（浮点异常）的缺省动作是产生core并退出。大多数情况下，信号由<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>处理。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">需要指出的是，对信号的任何处理，包括终止进程，都必须由接收到信号的进程来执行。而进程要执行<a target="_blank" href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86" style="color: rgb(19, 110, 194); text-decoration-line: none;">信号处理</a>程序，就必须等到它真正运行时。因此，对信号的处理可能需要延迟一段时间。</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">信号没有固有的优先级。如果为一个进程同时产生了两个信号，这两个信号会以任意顺序出现在进程中并会按任意顺序被处理。另外，也没有机制用于区分同一种类的多个信号。如果进程在处理某个信号之前，又有相同的信号发出，则进程只能接收到一个信号。进程无法知道它接收了1个还是42个SIGCONT信号。</div></div><h5><span style="text-indent: 28px;">共享存储</span></h5><div><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);">通常由一个进程创建，其余进程对这块内存区进行读写。得到共享内存有两种方式：映射/dev/mem设备和内存</span><a target="_blank" href="https://baike.baidu.com/item/%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6" style="color: rgb(19, 110, 194); text-decoration-line: none; font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);">映像文件</a><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);">。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的是实际的</span><a target="_blank" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98" style="color: rgb(19, 110, 194); text-decoration-line: none; font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);">物理内存</a><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; text-indent: 28px; background-color: rgb(255, 255, 255);">；常用的方式是通过shmXXX函数族来实现共享内存</span><span style="text-indent: 28px;"><br></span></div><div><span style="text-indent: 28px;"><br></span></div><h4><span style="text-indent: 28px;">套接字(SOCKET)</span></h4><h3>IPC 目的</h3><div><div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">进程通过与内核及其它进程之间的互相通信来协调它们的行为。Linux支持多种进程间通信（IPC）机制，信号和管道是其中的两种。除此之外，Linux还支持System V 的IPC机制（用首次出现的Unix版本命名）。</div></div></div><div><br></div><div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">数据传输</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">共享数据</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">通知事件</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知<a target="_blank" href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B" style="color: rgb(19, 110, 194); text-decoration-line: none;">父进程</a>）。</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">资源共享</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">多个进程之间共享同样的资源。为了作到这一点，需要<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>提供锁和同步机制。</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">进程控制</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</div></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><h2>FAQ</h2><h4>管道与文件描述符,文件指针的关系?</h4><div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">答: 其实管道的使用方法与文件类似,都能使用 read, write, open 等普通 IO 函数. 管道描述符类似于文件描述符. 事实上, 管道使用的描述符,&nbsp;<a target="_blank" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88" style="color: rgb(19, 110, 194); text-decoration-line: none;">文件指针</a>和文件描述符最终都会转化成系统中 SOCKET 描述符. 都受到系统内核中 SOCKET 描述符的限制. 本质上 LINUX 内核源码中管道是通过空文件来实现.</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">管道的使用方法?</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">答: 主要有下面几种方法:&nbsp;</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">1)pipe, 创建一个管道,返回2个管道描述符.通常用于父子进程之间通讯.&nbsp;</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">2)popen, pclose: 这种方式只返回一个管道描述符,常用于通信另一方是 stdin or stdout;</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">3)mkpipe:&nbsp;<a target="_blank" href="https://baike.baidu.com/item/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" style="color: rgb(19, 110, 194); text-decoration-line: none;">命名管道</a>, 在许多进程之间进行交互.</div><h4 style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">管道与系统IPC之间的优劣比较?</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">答: 管道: 优点是所有的UNIX实现都支持, 并且在最后一个访问管道的进程终止后,管道就被完全删除;缺陷是管道只允许单向传输或者用于父子进程之间.</div><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是<a target="_blank" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97" style="color: rgb(19, 110, 194); text-decoration-line: none;">关键字</a>KEY_T使用了<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">WINDOS进程间通信与LINUX进程间通信的关系?</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">答: 事实上,WINDOS的<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1" style="color: rgb(19, 110, 194); text-decoration-line: none;">进程通信</a>大部分移植于UNIX, WINDOS的剪贴板,文件映射等都可从UNIX进程通信的共享存储中找到影子.</div><h4 style="overflow-wrap: break-word; margin-bottom: 15px; line-height: 24px; zoom: 1;">进程间通信与线程间通信之间的关系?</h4><div class="para" label-module="para" style="font-size: 14px; overflow-wrap: break-word; color: rgb(51, 51, 51); margin-bottom: 15px; text-indent: 2em; line-height: 24px; zoom: 1; font-family: arial, 宋体, sans-serif; background-color: rgb(255, 255, 255);">答: 因为WINDOWS运行的实体是线程, 狭义上的进程间通信其实是指分属于不同进程的线程之间的通讯.而单个进程之间的<a target="_blank" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5" style="color: rgb(19, 110, 194); text-decoration-line: none;">线程同步</a>问题可归并为一种特殊的进程通信.它要用到<a target="_blank" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" style="color: rgb(19, 110, 194); text-decoration-line: none;">内核</a>支持的<a target="_blank" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" style="color: rgb(19, 110, 194); text-decoration-line: none;">系统调用</a>来保持线程之间同步. 通常用到的一些线程同步方法包括:Event, Mutex,<a target="_blank" href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F" style="color: rgb(19, 110, 194); text-decoration-line: none;">信号量</a>Semaphore,<a target="_blank" href="https://baike.baidu.com/item/%E4%B8%B4%E7%95%8C%E5%8C%BA" style="color: rgb(19, 110, 194); text-decoration-line: none;">临界区</a>资源等.</div></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div>
</article>
{% endblock point1 %}

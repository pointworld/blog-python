{% extends 'c-word.html' %}

{% block title %} Magic Methods - Python {% endblock title %}

{% block point1 %}
<article contenteditable="true">
    <p><b style="background-color: yellow;">Category: 计算机 | 程序设计语言 | Python | Magic Methods</b></p>
    <h1 id="blogTitle0">Magic Methods</h1><h2 id="blogTitle1">概述</h2><h3 id="blogTitle2">什么是魔法方法</h3><div>魔法方法（魔法函数）是网上对 Python 数据模型的一个叫法。</div><div><br></div><div>在一个对象中，通过组合不同的魔法方法，会得到 Python 的各种数据类型。</div><div><br></div><div>Python 中以双下划线 '__' 开头和结尾的方法即魔法方法（Magic Methods）。</div><div><br></div><div>魔法方法会影响到 Python 本身的语法。</div><div><br></div><div>定义了魔法方法，不必去显示的调用它，Python 会在需要的时候（比如调用某些内置函数时，或应用了某些语法时）去调用它。</div><div><br></div><h3 id="blogTitle3">如何学习</h3><div>从设计者的角度去理解</div><div><br></div><div>从 Python 内部设计理念的角度去理解</div><h2 id="blogTitle4">分类 1</h2><h3 id="blogTitle5">构造方法</h3><h3 id="blogTitle6">操作符</h3><h4 id="blogTitle7">比较操作符</h4><h4 id="blogTitle8">数值操作符&nbsp;</h4><h5 id="blogTitle9">一元操作符</h5><h5 id="blogTitle10">常见算数操作符</h5><h5 id="blogTitle11">反射算数运算符</h5><h5 id="blogTitle12">增强赋值运算符</h5><h5 id="blogTitle13">类型转换操作符</h5><h3 id="blogTitle14">类的表示</h3><h3 id="blogTitle15">访问控制</h3><h3 id="blogTitle16">自定义序列</h3><h3 id="blogTitle17">反射</h3><h3 id="blogTitle18">抽象基类</h3><h3 id="blogTitle19">可调用的对象</h3><h3 id="blogTitle20">上下文管理器</h3><h3 id="blogTitle21">创建描述符对象</h3><h3 id="blogTitle22">拷贝</h3><h3 id="blogTitle23">Pickling</h3><h2 id="blogTitle24">分类 2</h2><h3 id="blogTitle25">数学运算</h3><h4 id="blogTitle26">一元运算符</h4><h5 id="blogTitle27">__neg__</h5><div>-</div><h5 id="blogTitle28">__pos__</h5><div>+</div><h5 id="blogTitle29">__abs__</h5><div>abs()</div><h4 id="blogTitle30">二元运算符</h4><h5 id="blogTitle31">__lt__</h5><div>&lt;</div><h5 id="blogTitle32">__le__</h5><div>&lt;=</div><h5 id="blogTitle33">__eq__</h5><div>==</div><h5 id="blogTitle34">__ne__</h5><div>!=</div><h5 id="blogTitle35">__gt__</h5><div>&gt;</div><h5 id="blogTitle36">__ge__</h5><div>&gt;=</div><h4 id="blogTitle37">算术运算符<br></h4><h5 id="blogTitle38">__add__</h5><div>+</div><h5 id="blogTitle39">__sub__</h5><div>-</div><h5 id="blogTitle40">__mul__</h5><div>*</div><h5 id="blogTitle41">__truediv__</h5><div>/</div><h5 id="blogTitle42">__floordiv__</h5><div>//</div><h5 id="blogTitle43">__mod__</h5><div>%</div><h5 id="blogTitle44">__divmod__</h5><div>divmod()</div><h5 id="blogTitle45">__pow__</h5><div>** 或 pow()</div><h5 id="blogTitle46">__round__</h5><div>round()</div><h4 id="blogTitle47">反向算术运算符</h4><div><h5 id="blogTitle48">__radd__</h5><h5 id="blogTitle49">__rsub__</h5><h5 id="blogTitle50">__rmul__</h5><h5 id="blogTitle51">__rtruediv__</h5><h5 id="blogTitle52">__rfloordiv__</h5><h5 id="blogTitle53">__rmod__</h5><h5 id="blogTitle54">__rdivmod__</h5><h5 id="blogTitle55">__rpow__</h5></div><h4 id="blogTitle56">增量赋值算术运算符</h4><h5 id="blogTitle57">__iadd__</h5><div>+=</div><h5 id="blogTitle58">__isub__</h5><div>-=</div><h5 id="blogTitle59">__imul__</h5><div>*=</div><h5 id="blogTitle60">__itruediv_</h5><div>/=</div><h5 id="blogTitle61">___ifloordiv__</h5><div>//=</div><h5 id="blogTitle62">__imod_</h5><div>%=</div><h5 id="blogTitle63">___ipow__</h5><div>**=</div><h4 id="blogTitle64">位运算符</h4><h5 id="blogTitle65">__invert__</h5><div>~</div><h5 id="blogTitle66">__lshift__</h5><div>&lt;&lt;</div><h5 id="blogTitle67">__rshift__</h5><div>&gt;&gt;</div><h5 id="blogTitle68">__and__</h5><div>&amp;</div><h5 id="blogTitle69">__or__</h5><div>|</div><h5 id="blogTitle70">__xor__</h5><div>^</div><h4 id="blogTitle71">反向位运算符</h4><div><h5 id="blogTitle72">__rlshift__</h5><h5 id="blogTitle73">__rrshift__</h5><h5 id="blogTitle74">__rand__</h5><h5 id="blogTitle75">__ror__</h5><h5 id="blogTitle76">__rxor__</h5></div><h4 id="blogTitle77">增量赋值位运算符</h4><div><h5 id="blogTitle78">__ilshift__</h5><div>&lt;&lt;=</div><h5 id="blogTitle79">__irshift__</h5><div>&gt;&gt;=</div><h5 id="blogTitle80">__iand__</h5><div>&amp;=</div><h5 id="blogTitle81">__ior__</h5><div>|=</div><h5 id="blogTitle82">__ixor__</h5></div><div>^=</div><h3 id="blogTitle83">非数学运算</h3><h4 id="blogTitle84">类的表示</h4><div>使用字符串来表示类是一个相当有用的特性。在 Python 中有一些内建方法可以返回类的表示，相对应的，也有一系列魔法方法可以用来自定义在使用这些内建函数时类的行为。</div><h5 id="blogTitle85">__repr__</h5><h5 id="blogTitle86">__str__</h5><h5 id="blogTitle87">__unicode__</h5><h5 id="blogTitle88">__format__</h5><h4 id="blogTitle89">集合、序列相关</h4><h5 id="blogTitle90">__len__</h5><h5 id="blogTitle91">__getitem__</h5><h5 id="blogTitle92">__setitem__</h5><h5 id="blogTitle93">__delitem__</h5><h5 id="blogTitle94">__contains__</h5><h4 id="blogTitle95">迭代相关</h4><h5 id="blogTitle96">__iter__</h5><h5 id="blogTitle97">__next__</h5><h4 id="blogTitle98">可调用</h4><h5 id="blogTitle99">__call__</h5><h4 id="blogTitle100">with 上下文管理器</h4><h5 id="blogTitle101">__enter__</h5><h5 id="blogTitle102">__exit__</h5><h4 id="blogTitle103">数值转换</h4><h5 id="blogTitle104">__abs__</h5><h5 id="blogTitle105">__bool__</h5><h5 id="blogTitle106">__int__</h5><h5 id="blogTitle107">__float__</h5><h5 id="blogTitle108">__hash__</h5><h5 id="blogTitle109">__index__</h5><h4 id="blogTitle110">元类相关</h4><h5 id="blogTitle111">__new__</h5><h5 id="blogTitle112">__init__</h5><h4 id="blogTitle113">属性相关</h4><h5 id="blogTitle114">__getattr__</h5><h5 id="blogTitle115">__setattr__</h5><h5 id="blogTitle116">__getattribute__</h5><h5 id="blogTitle117">__setattribute__</h5><h5 id="blogTitle118">__dir__</h5><h4 id="blogTitle119">属性描述符相关</h4><h5 id="blogTitle120">__set__</h5><h5 id="blogTitle121">__get__</h5><h5 id="blogTitle122">__delete__</h5><h4 id="blogTitle123">协程相关&nbsp;</h4><h5 id="blogTitle124">__await__</h5><h5 id="blogTitle125">__aiter__</h5><h5 id="blogTitle126">__anext__</h5><h5 id="blogTitle127">__aenter__</h5><h5 id="blogTitle128">__aexit__</h5><div><br></div><h2 id="blogTitle129">索引</h2><h3 id="blogTitle130">__abs__</h3><h3 id="blogTitle131">__add__</h3><div>算术运算符 '+' 会隐含的调用 __add__ 方法。</div><pre>class MyVector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other_instance):
        re_vector = MyVector(self.x + other_instance.x, self.y + other_instance.y)
        return re_vector

    def __str__(self):
        return "x: {x}, y: {y}".format(x=self.x, y=self.y)


first_vec = MyVector(1, 2)
second_vec = MyVector(2, 3)
print(first_vec + second_vec)  # 'x: 3, y: 5'<br></pre><div><br></div><h3 id="blogTitle132">__aenter__</h3><h3 id="blogTitle133">__aexit__</h3><h3 id="blogTitle134">__aiter__</h3><h3 id="blogTitle135">__and__</h3><h3 id="blogTitle136">__anext__</h3><h3 id="blogTitle137">__await__</h3><h3 id="blogTitle138">__bool__</h3><h3 id="blogTitle139">__bytes__</h3><h3 id="blogTitle140">__call__</h3><h3 id="blogTitle141">__ceil__</h3><h3 id="blogTitle142">__class_getitem__</h3><h3 id="blogTitle143">__cmp__</h3><h3 id="blogTitle144">__coerce__</h3><h3 id="blogTitle145">__complex__</h3><h3 id="blogTitle146">__contains__</h3><h3 id="blogTitle147">__copy__</h3><h3 id="blogTitle148">__deepcopy__</h3><h3 id="blogTitle149">__del__</h3><h3 id="blogTitle150">__delattr__</h3><h3 id="blogTitle151">__delete__</h3><h3 id="blogTitle152">__delitem__</h3><h3 id="blogTitle153">__delslice__</h3><h3 id="blogTitle154">__dir__</h3><h3 id="blogTitle155">__divmod__</h3><h3 id="blogTitle156">__enter__</h3><h3 id="blogTitle157">__eq__</h3><h3 id="blogTitle158">__exit__</h3><h3 id="blogTitle159">__float__</h3><h3 id="blogTitle160">__floor__</h3><h3 id="blogTitle161">__floordiv__</h3><h3 id="blogTitle162">__format__</h3><div>定义当类的实例用于新式字符串格式化时的行为，例如， “Hello, 0:abc!”.format(a) 会导致调用 a.__format__(“abc”) 。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个魔法方法会非常有用。<br></div><h3 id="blogTitle163">__fspath__</h3><h3 id="blogTitle164">__ge__</h3><h3 id="blogTitle165">__get__</h3><h3 id="blogTitle166">__getattr__</h3><h3 id="blogTitle167">__getattribute__</h3><h3 id="blogTitle168">__getinitargs__</h3><h3 id="blogTitle169">__getitem__</h3><h3 id="blogTitle170">__getnewargs__</h3><h3 id="blogTitle171">__getstate__</h3><h3 id="blogTitle172">__gt__</h3><h3 id="blogTitle173">__hash__</h3><h3 id="blogTitle174">__hex__</h3><h3 id="blogTitle175">__iadd__</h3><h3 id="blogTitle176">__iand__</h3><h3 id="blogTitle177">__idiv__</h3><h3 id="blogTitle178">__ifloordic__</h3><h3 id="blogTitle179">__ilshift__</h3><h3 id="blogTitle180">__imatmul__</h3><h3 id="blogTitle181">__imod__</h3><h3 id="blogTitle182">__imul__</h3><h3 id="blogTitle183">__index__</h3><h3 id="blogTitle184">__init_subclass__</h3><h3 id="blogTitle185">__instancecheck__</h3><h3 id="blogTitle186">__int__</h3><h3 id="blogTitle187">__invert__</h3><h3 id="blogTitle188">__ior__</h3><h3 id="blogTitle189">__ipow__</h3><h3 id="blogTitle190">__irshift__</h3><h3 id="blogTitle191">__isub____iter__</h3><h3 id="blogTitle192">__itruediv__</h3><h3 id="blogTitle193">__ixor__</h3><h3 id="blogTitle194">__le__</h3><h3 id="blogTitle195">__len__</h3><div>当使用 len 方法去获取一个对象长度的时候，Python 会尝试调用 __len__ 方法来获取它的返回结果。</div><div><br></div><div>len 方法的实现是相对比较复杂的，当对 Python 内置类型相关的对象使用 len 方法时，性能是非常高的。因为在 CPython 中的 Python 内置类型大多是由 c 语言实现的。</div><div><br></div><h3 id="blogTitle196">__long__</h3><h3 id="blogTitle197">__lshift__</h3><h3 id="blogTitle198">__lt__</h3><h3 id="blogTitle199">__matmul__</h3><h3 id="blogTitle200">__missing__</h3><h3 id="blogTitle201">__mod__</h3><h3 id="blogTitle202">__mro_entries__</h3><h3 id="blogTitle203">__mul__</h3><h3 id="blogTitle204">__ne__</h3><h3 id="blogTitle205">__neg__<br></h3><h3 id="blogTitle206">__new__</h3><h3 id="blogTitle207">__next__</h3><h3 id="blogTitle208">__oct__</h3><h3 id="blogTitle209">__or__</h3><h3 id="blogTitle210">__pos__</h3><h3 id="blogTitle211">__pow__</h3><h3 id="blogTitle212">__prepare__</h3><h3 id="blogTitle213">__radd__</h3><h3 id="blogTitle214">__rand__</h3><h3 id="blogTitle215">__rdiv__</h3><h3 id="blogTitle216">__rdivmod__</h3><h3 id="blogTitle217">__reduce__</h3><h3 id="blogTitle218">__reduce_ex__</h3><h3 id="blogTitle219">__repr__</h3><div>str() 和 repr() 最主要的差别在于“目标用户”。 repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的 Python 代码），而 str() 则产生人类可读的输出。<br></div><div><br></div><div>定义对类的实例调用 repr() 时的行为。<br></div><h3 id="blogTitle220">__reversed__</h3><h3 id="blogTitle221">__rfloordiv__</h3><h3 id="blogTitle222">__rlshift__</h3><h3 id="blogTitle223">__rmatmul__</h3><h3 id="blogTitle224">__rmod__</h3><h3 id="blogTitle225">__rmul__</h3><h3 id="blogTitle226">__ror__</h3><h3 id="blogTitle227">__round__</h3><h3 id="blogTitle228">__rpow__</h3><h3 id="blogTitle229">__rrshift__</h3><h3 id="blogTitle230">__rshift__</h3><h3 id="blogTitle231">__rsub__</h3><h3 id="blogTitle232">__rtruediv__</h3><h3 id="blogTitle233">__rxor__</h3><h3 id="blogTitle234">__set__</h3><h3 id="blogTitle235">__set_name__</h3><h3 id="blogTitle236">__setattr__</h3><h3 id="blogTitle237">__setitem__</h3><h3 id="blogTitle238">__setslice__</h3><h3 id="blogTitle239">__setstate__</h3><h3 id="blogTitle240">__sizeof__</h3><h3 id="blogTitle241">__str__</h3><div>str() 和 repr() 最主要的差别在于“目标用户”。 repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的 Python 代码），而 str() 则产生人类可读的输出。<br></div><div><br></div><div><div>定义对类的实例调用 str() 时的行为。<br></div><div><br></div><div>print 函数在执行时，会默认调用 str 方法</div><pre>a = object()
print(a) == print(str(a)) # True</pre><div><br></div><div>str 方法会尝试调用 mro 链上最近的 __str__ 或 __repr__ 方法，获取最终结果：</div><pre># company.py


class Company:
    def __init__(self, employee_list):
        self.employee = employee_list


company = Company(['tom', 'bom', 'jane'])

print(company) # &lt;company.Company object at 0x107d8ecf8&gt;<br></pre><div><br></div><pre># company.py


class Company:
    def __init__(self, employee_list):
        self.employee = employee_list

    def __str__(self):
        return ', '.join(self.employee)


company = Company(['tom', 'bom', 'jane'])

print(company) # 'tom, bom, jane'</pre><div><br></div><pre># company.py


class Company:
    def __str__(self):
        return 'Company'


class MyCompany(Company):
    def __init__(self, employee_list):
        self.employee = employee_list


company = MyCompany(['tom', 'bom', 'jane'])

print(company) # 'Company'</pre></div><h3 id="blogTitle242">__sub__</h3><h3 id="blogTitle243">__subclasscheck__</h3><h3 id="blogTitle244">__truediv__</h3><h3 id="blogTitle245">__trunc__</h3><h3 id="blogTitle246">__unicode__</h3><div>定义对类的实例调用 unicode() 时的行为。 unicode() 和 str() 很像，只是它返回 unicode 字符串。注意，如果调用者试图调用 str() 而你的类只实现了 __unicode__() ，那么类将不能正常工作。所有你应该总是定义 __str__() ，以防有些人没有闲情雅致来使用 unicode。<br></div><div><br></div><h3 id="blogTitle247">__xor__</h3><div><br></div><div><br></div><div><br></div><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><div><br></div>
</article>
{% endblock point1 %}

{% extends 'c-word.html' %}

{% block title %} code comment {% endblock title %}

{% block point1 %}
<article contenteditable="true">
  <p>Category: computer | software | code | comment</p>
  <h1 id="blogTitle0">Code Comment</h1><p>代码注释是架起程序设计者与程序阅读者之间的通信桥梁，最大限度的提高团队开发合作效率。也是程序代码可维护性的重要环节之一。所以我们不是为写注释而写注释。</p><blockquote>黄金定律 —— 不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。</blockquote><h2>Overview</h2><div><div><p>编码规范中有一条很重要---见名知意，有时候直白的函数名还不能表达完整的意思，这个时候注释就出场了，代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。</p>
<p><p>在写代码前就应该添加注释，这时在你的脑子里的是清晰完整的思路。</p><p>
如果在代码最后再添加注释，它将花费你双倍的时间。</p></p></div><br><br>作者：流星狂飙<br>链接：https://www.jianshu.com/p/822aa0077595<br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></div><h3>Definition</h3><p>注释就是让编码器不编译（不执行），在代码的编写过程中我们需要对一些程序进行注释，除了自己方便阅读，更为别人更好理解自己的程序，所以我们需要进行一些注释，可以是编程思路或者是程序的作用，总而言之就是方便自己他人更好的阅读。</p><h3>分类</h3><div><p>从用途上分，注释可以分为序言性注释和功能性注释。</p><div><ul><li>序言性注释：通称位于程序或者模块的开始部分。它给出了程序或模块的整体说明，这种描述不包括程序的执行过程细节。<br></li><li>功能性注释：一般嵌入在源程序体之中。其主要描述某个语句或程序段做什么，执行该语句或程序段会怎样，不是解释怎么做。只有复杂的执行细节才需要嵌入注释，描述其实现方法。<br></li></ul></div></div><h3>原则</h3><h4>注释形式统一</h4><p>在整个应用程序中，使用具有一致的标点和结构的样式来构造注释。如果在其它项目中发现它们的注释规范与这份文档的不同，按照这份规范写代码，不要试图在既成的规范系统中引入新的规范。</p><h4>注释内容准确简洁</h4><p>内容要简单、明了、含义准确，防止注释的多义性，错误的注释不但无益反而有害。<br></p><h3>注释条件</h3><h4>基本注释（必须加）</h4><p><ul><li>类（接口）的注释<br></li><li>构造函数的注释<br></li><li>方法的注释<br></li><li>全局变量的注释<br></li><li>字段/属性的注释<br></li></ul></p><p>备注：简单的代码做简单注释，注释内容不大于 10 个字即可，另外，持久化对象或 VO 对象的 getter、setter 方法不需加注释。具体的注释格式请参考下面举例。<br></p><h4>特殊必加注释（必须加）</h4><p><ul><li>典型算法必须有注释。<br></li><li>在代码不明晰处必须有注释。<br></li><li>在代码修改处加上修改标识的注释。<br></li><li>在循环和逻辑分支组成的代码中加注释。<br></li><li>为他人提供的接口必须加详细注释。<br></li></ul></p><p>&nbsp;备注：此类注释格式暂无举例。具体的注释格式自行定义，要求注释内容准确简洁。</p><h3>注释格式</h3><h4>单行(single-line)注释：“//……”</h4><p>// 注释一行&nbsp;</p><div><ul><li>双斜线后，必须跟注释内容保留一个空格<br></li><li>可独占一行, 前边不许有空行, 缩进与下一行代码保持一致<br></li><li>可位于一个代码行的末尾，注意这里的格式<br></li></ul><div><pre>// Good<br>if (condition) {<br>&nbsp; &nbsp; // if you made it here, then all security checks passed<br>&nbsp; &nbsp; allowed();<br>}<br>var zhangsan = "zhangsan";&nbsp; &nbsp; // 双斜线距离分号四个空格，双斜线后始终保留一个空格</pre></div></div><h4>块(block)注释：“/*……*/”</h4><p>/* ...... */ 注释若干行&nbsp;</p><div><ul><li>最少三行, 格式如下<br></li><li>前边留空一行<br></li></ul><div><pre>/*<br>&nbsp;* 注释内容与星标前保留一个空格<br>&nbsp;*/</pre></div></div><h4>文档注释：“/**……*/”</h4><p>/** ...... */ 注释若干行，并写入 javadoc 文档</p><p>文档注释的正文并不是直接复制到输出文件 (文档的 HTML 文件)，而是读取每一行后，删掉前导的 * 号及 * 号以前的空格，再输入到文档的。</p><pre>/**&nbsp;<br> * show 方法的简述.<br> * ＜p＞show 方法的详细说明第一行＜br＞<br> * show 方法的详细说明第二行<br> * @param b true 表示显示，false 表示隐藏<br> * @return 没有返回值<br> */
<br>public void show(boolean b) {<br>frame.show(b);<br>}</pre><p style="font-family: &quot;Times New Roman&quot;;"></p><p style=""><p>第一部分是简述，列表中属性名或者方法名后面那段说明就是简述。简述部分写在一段文档注释的最前面，第一个点号 (.) 之前 (包括点号)。换句话说，就是用第一个点号分隔文档注释，之前是简述，之后是第二部分和第三部分。如上例中的 “* show 方法的简述.”。</p><p>有时，即使正确地以一个点号作为分隔，javadoc 仍然会出错，把点号后面的部分也做为了第一部分。为了解决这个问题，我们可以使用一个 ＜p＞ 标志将第二分部分分开，如上例的“* ＜p＞show 方法的详细说明第一行 ....”。</p><p>第二部分是详细说明部分。该部分对属性或者方法进行详细的说明，在格式上没有什么特殊的要求，可以包含若干个点号。</p>第三部分是特殊说明部分。这部分包括版本说明、参数说明、返回值说明等。第三部分在上例中相应的代码是：&nbsp;<br><ul style=""><li style="">* @param b true 表示显示，false 表示隐藏&nbsp;<br></li><li style="">* @return 没有返回值<br></li><li style="">除了 @param 和 @return 之外，还有其它的一些特殊标记，分别用于对类、属性和方法的说明。<br></li></ul><font face="Microsoft YaHei"><span style="white-space: pre; font-size: 14px;"></span></font></p><div><h4>多人合作注释<br></h4><div><p>同一个文件的代码可能被多个人修改，这个时候需要标识出谁改动了哪些部分。</p><p>格式： // add begin by 作者名 ,一个分号;，再加上原因 Reason</p><p>代码添加的最后加上：//add end</p></div><div><pre>// add begin by liuxing ; Init post's id&nbsp;<br>var postId = 1;<br>//end add</pre><p>或者</p><pre>// add begin by liuxing&nbsp;<br>/**<br>&nbsp;* 多行注释来说明原因<br>&nbsp;*/<br>var postId = 1;<br>//end add</pre></div><h4>TODO 注释</h4></div><div><pre>@Override<br>public void submitOnly() {<br>  // TODO Auto-generated method stub<br>}</pre><div>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</div></div><h3>注释标记<br></h3><div><p>javadoc 标记是插入文档注释中的特殊标记，它们用于标识代码中的特殊引用。javadoc 标记由 “@” 及其后所跟的标记类型和专用注释引用组成。共三个部分 —— @、标记类型、专用注释引用。虽然 @ 和标记类型之间有时可以用空格符分隔，但是推荐将它们紧挨着写，以减少出错机会。</p><p>javadoc 标记有如下一些：&nbsp;</p></div><p><ul><li>@author&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 标明开发该类模块的作者 （对类的说明）<br></li><li>@version&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;标明该类模块的版本 （对类的说明）<br></li><li>@see&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;参考转向，也就是相关主题 （对类、方法、属性的说明）<br></li><ul><li>@see 类名&nbsp;</li><li>@see #方法名或属性名</li><li>@see 类名#方法名或属性名</li></ul><li>@param&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;对方法中某参数的说明 （对方法的说明）<br></li><ul><li>@param 参数名 参数说明</li><li>每一个 @param 只能描述方法的一个参数，所以，如果方法需要多个参数，就需要多次使用 @param 来描述<br></li></ul><li>@return&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对方法返回值的说明 （对方法的说明）<br></li><ul><li>@return 返回值说明</li><li>一个方法中只能用一个 @return，如果文档说明中列了多个 @return，则 javadoc 编译时会发出警告，且只有第一个 @return 在生成的文档中有效。<br></li></ul><li>@deprecated&nbsp; 引起不推荐使用的警告（对方法的说明）<br></li><li>@since&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 最早使用该方法/类/接口的 JDK 版本（对类的说明）<br></li><li>@exception&nbsp; &nbsp; &nbsp;对方法可能抛出的异常进行说明 （对方法的说明）<br></li><ul><li>@exception 异常类名 说明</li><li>方法可能抛出的异常应当用 @exception 描述。</li><li>由于一个方法可能抛出多个异常，所以可以有多个 @exception。</li><li>每个 @exception 后面应有简述的异常类名，说明中应指出抛出异常的原因。需要注意的是，异常类名应该根据源文件的 import 语句确定是写出类名还是类全名。<br></li></ul></ul></p><ul></ul><ul></ul><p><p>其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 指明的版本号,也可以使用多次，只有第一次有效 。</p><h4>@see 的三种句法使用&nbsp;</h4></p><p><h4>@author、@version 说明类</h4><p><br></p></p><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>何时使用注释</h3><div><div><ul><li>难于理解的代码段<br></li><li>可能存在错误的代码段<br></li><li>浏览器特殊的 HACK 代码<br></li><li>想吐槽的产品逻辑, 合作同事<br></li><li>业务逻辑强相关的代码<br></li></ul></div></div><h3>参考举例</h3><h4>类接口注释</h4><pre>/**<br> * 类的描述<br> * @author Administrator<br> * @Time 2012-11-2014:49:01<br> *<br> */<br>public class Test extends Button {<br>&nbsp;  ……<br>}</pre><pre>/**
 * 类 &lt;code&gt;{类名称}&lt;/code&gt;{此类功能描述}
 * @author   {作者}
 * @version {版本,常用时间代替}
 * @see      java.lang.Class
 * @since    JDK{jdk版本} 或者编辑日期
 */  
public class Object {}
</pre><h4>类变量</h4><div><pre>/** The value is used for character storage. */  
  private char value[];   
  注释结构: 
/** {此值是用来存储/记录什么的}*/  

</pre></div><h4>方法注释</h4><div><p>使用 @param、@return 和 @exception 说明方法&nbsp;</p><p>方法注释采用 /** … */，描述部分注明方法的功能，块标记部分注明方法的参数，返回值，异常等信息</p><p>这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下：&nbsp;</p><div><ul><li>@param 参数名 参数说明&nbsp;</li><li>@return 返回值说明&nbsp;</li><li>@exception 异常类名 说明&nbsp;<br></li></ul></div><div>注释结构:&nbsp;</div><pre>/**<br>&nbsp;* {方法的功能/动作描述}<br>&nbsp;* @param&nbsp; &nbsp; &nbsp;  &nbsp;{引入参数名}&nbsp; &nbsp; {引入参数说明}<br>&nbsp;* @return&nbsp; &nbsp; &nbsp; &nbsp;{返回参数名}&nbsp; &nbsp; {返回参数说明}<br>&nbsp;* @exception&nbsp; &nbsp; {说明在某情况下,将发生什么异常}<br>&nbsp;*/&nbsp;&nbsp;
<br>public String substring(int beginIndex) {&nbsp; &nbsp;<br>  return substring(beginIndex, count);&nbsp; &nbsp;<br>}&nbsp;
<br>import java.lang.*;<br>/** commnet for class */<br>public class Test { ...... }</pre><div>上例中的两处注释就是分别对类、属性和方法的文档注释。它们生成的文档分别是说明紧接其后的类、属性、方法的。“紧接”二字尤其重要，如果忽略了这一点，就很可能造成生成的文档错误</div></div><h4>构造方法注释</h4><pre>public class Test extends Button {<br>&nbsp; /**<br>&nbsp; &nbsp;* 构造方法的描述<br>&nbsp; &nbsp;* @param name<br>&nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp;*/<br>&nbsp; public Test(String name) {<br>&nbsp; &nbsp; &nbsp;……<br>&nbsp; }<br>}
</pre><h4>方法注释</h4><pre>public class Test extends Button {
  /**
   * 为按钮添加颜色
   * @param color
   * @return
   * @exception  (方法有异常的话加)
   * @author Administrator
   * @Time 2012-11-20 15:02:29
  */

  public voidaddColor(String color){
     ……
  }

</pre><h4>全局变量注释</h4><pre>public final class String
implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
   /** The value is used for characterstorage. */
   private final char value[];
   /** The offset is the first index of thestorage that is used. */
   private final int offset;
   /** The count is the number of charactersin the String. */
   private final int count;
   /** Cache the hash code for the string */
   private int hash; // Default to 0
   ……
}
</pre><h4>字段/属性注释</h4><pre>public class EmailBody implements Serializable{
   private String id;
   private String senderName;//发送人姓名
   private String title;//不能超过120个中文字符
   private String content;//邮件正文
   private String attach;//附件，如果有的话
   private String totalCount;//总发送人数
   private String successCount;//成功发送的人数
   private Integer isDelete;//0不删除 1删除
   private Date createTime;//目前不支持定时 所以创建后即刻发送
   privateSet&lt;EmailList&gt; EmailList;
   ……
}</pre><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>
</article>
{% endblock point1 %}

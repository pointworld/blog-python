{% extends 'c-word.html' %}

{% block title %} ES Obj - Web | JS {% endblock title %}

{% block point1 %}
<article contenteditable="true">
<p><span style="background-color: yellow;">Category:&nbsp;</span><span style="font-weight: 700; background-color: yellow;"><a href="url(http://)">computer</a> | <a href="url(http://)">web</a> | </span><span style="font-weight: 700; background-color: yellow;"><a href="url(http://)">ECMAScript</a></span></p><div><h1 style="margin-top: 25px;" id="blogTitle0">ES Object</h1></div><div><h2 id="blogTitle1"><b>Overview</b></h2><h3 id="blogTitle2"><b>Description</b></h3><p><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">尽管 ES 包含 class 的语法，但 ES 中的对象根本上不是基于类的，基于类的语言有 C++, Smalltalk, or Java。ES 中的对象可以通过多种方式创建，如通过对象的字面量表示法或通过</span><i style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">构造器</i><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">（用于创建对象），每个</span><a href="file:///C:/Users/Administrator/Desktop/ecma262-cn/index.html#constructor" style="text-decoration-line: none; color: rgb(32, 108, 167); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">构造器</a><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">都是一个函数，都有一个叫做 “</span><span style="color: rgb(17, 17, 17); font-size: 18px; font-family: Consolas, Monaco, monospace; font-weight: 700; white-space: pre;">prototype</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">” 的属性（用于实现</span><i style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">基于原型的继承</i><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">和</span><i style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">共享属性</i><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">）。</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">对象可以通过对构造器使用&nbsp;</span><b style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">new</b><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;表达式来创建。例如，</span><span style="color: rgb(17, 17, 17); font-size: 18px; font-family: Consolas, Monaco, monospace; font-weight: 700; white-space: pre;">new Date(2009,11)</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;会创建一个新的日期对象。调用一个未使用&nbsp;</span><b style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">new</b><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp; 关键字的结果，依赖于构造器本身。例如，调用&nbsp;</span><span style="color: rgb(17, 17, 17); font-size: 18px; font-family: Consolas, Monaco, monospace; font-weight: 700; white-space: pre;">Date()</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;会产生一个代表当前日期和时间的字符串表示，而不是创建一个新的对象。</span><b><br></b></p><p><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">每个由</span><a href="file:///C:/Users/Administrator/Desktop/ecma262-gh-pages-cn/index.html#constructor" style="text-decoration-line: none; color: rgb(32, 108, 167); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">构造器</a><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">创建的对象都有一个隐式引用（叫做对象的</span><i style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">原型</i><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">）指向它的</span><a href="file:///C:/Users/Administrator/Desktop/ecma262-gh-pages-cn/index.html#constructor" style="text-decoration-line: none; color: rgb(32, 108, 167); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">构造器</a><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">的 “</span><span style="color: rgb(17, 17, 17); font-size: 18px; font-family: Consolas, Monaco, monospace; font-weight: 700; white-space: pre;">prototype</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">” 属性。此外，原型自身可能也有一个非空隐式引用指向到它自己的原型，以此类推，这就是</span><i style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">原型链</i><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">。当一个引用链接到对象的属性上时，该引用会指向原型链中包含此属性名的第一个对象对应的属性。换句话说，首先检查对象直接的同名属性，如果对象包含同名的属性，引用即指向此属性，如果该对象不包含同名的属性，则下一步检查对象的原型，以此类推。</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><br></span></p><p><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">通常在基于类的面向对象语言中，实例拥有状态，类拥有方法，继承针对的是结构和行为。在 ES 中，对象拥有状态和方法，并且结构，行为，状态全都可继承。</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><br></span></p><p><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">尽管 ES 对象内部并不是基于类的，但基于一个拥有共同的</span><a href="file:///C:/Users/Administrator/Desktop/ecma262-cn/index.html#constructor" style="text-decoration-line: none; color: rgb(32, 108, 167); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">构造器</a><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">函数、原型对象和方法的模式来定义一个类似 class 抽象操作也是很容易的。ES 内置对象本身遵循了这样一个 class-like 的模式。ES 2015 已经实现了 class 的语法定义，方便程序员精确地定义一个和内置对象一样的基于相同的 class-like 的模式的对象。</span><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><br></span></p><h3 id="blogTitle3"><b>Definition</b></h3><div><div><ul><li>对象是数据的一种抽象表示方法。</li><li>ES 对象是由若干<b>属性（键-值对）</b>组成的无序集合。</li><li>一个 ES 对象就是键和值之间的映射。键是一个字符串（或者&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" title="Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。" style="margin: 0px; padding: 0px; border: 0px;"><span style="border-style: initial; border-color: initial;">Symbol</span></a>） ，值可以是任意类型的值。&nbsp;</li></ul></div><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="background-color: yellow;">在计算机科学中, 对象是指内存中的可以被&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier" class="glossaryLink" title="标识符: A sequence of characters in the code that identifies a variable, function, or property." style="cursor: help; margin: 0px; padding: 0px; border-width: 0px 0px 1px; border-top-style: initial; border-right-style: initial; border-bottom-style: dashed; border-left-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: rgb(170, 170, 170); border-left-color: initial; border-image: initial;">标识符</a>&nbsp;引用的一块区域.</span></p></div></div><h3 id="blogTitle4"><b>ES 语言如何实现对象</b></h3><h4 id="blogTitle5"><b>ES 中对象是通过函数是实现的，对象本身就是一个函数</b></h4></div><h3 id="blogTitle6"><b>ES 对象的两种类型</b></h3><div>ES 对象是由两个对象组成的，这两种对象是相互独立的，即 JS 对象有两种实现方式</div><h4 id="blogTitle7"><b>构造函数对象</b></h4><p>构造函数方式创建对象</p><h4 id="blogTitle8"><b>原型对象</b></h4><p>原型方式创建对象</p><h2 id="blogTitle9"><span style="font-weight: 700;">ES 对象分类</span></h2><h3 id="blogTitle10"><b>Ordinary Objects（</b><b>普通/本地对象</b><b>）</b></h3><h3 id="blogTitle11"><b>Exotic Objects（</b><b>外来对象</b><b>）</b></h3><h2 id="blogTitle12"><span style="font-weight: 700;">ES 对象属性</span></h2><div><span style="font-weight: 700;">在一个对象中绑定属性，称为这个对象的属性。</span></div><div><h3 id="blogTitle13" style=""><b>对象属性 --&nbsp;万物皆属性 --&nbsp;万物皆变量 -- 面向内存编程</b></h3><div>对象中的变量称之为属性<b><br></b></div><div><br></div><div><div><span style="font-weight: 700;"><font color="#ff0000">万物皆属性</font></span><br></div><div>对象的方法从定义，使用等各种角度都和属性的使用方法类似<br></div><div><br></div><div><span style="font-weight: 700;"><font color="#ff0000">万物皆变量 - 一切数据都是通过变量来统一管理的</font></span></div><div><font color="#000000"><b>定义变量的过程其实就是内存分配的工程</b></font></div><div><b>所以本质上一切变量都是存放在内存中的，对象也不例外</b></div></div></div><div><h3 id="blogTitle14"><b>属性的表示</b><br></h3><h4 id="blogTitle15"><b>属性的简写形式</b></h4><div><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p><pre class=" language-javascript" style="padding-left: 0.7rem; border-radius: 5px; line-height: 1.2; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; margin: 0.5em auto;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">const obj = {
  * m() {
    yield 'hello world';
  }
};</span></pre><h4 style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;" id="blogTitle16">属性<span style="font-size: 14.336px;">赋值器和取值器的简写形式</span></h4><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p></div></div><h3 id="blogTitle17"><b>属性分类</b></h3><div><h4 id="blogTitle18"><b>静态属性（构造函数对象属性）</b></h4><div><div><ul><li><b>只能以&nbsp;<span style="background-color: white;">构造函数名.属性名</span>&nbsp;形式使用</b></li><li><b>不能被实例对象继承</b><br></li></ul></div></div><h4 id="blogTitle19"><b>原型对象属性</b></h4><div><ul><li>只能以&nbsp;<span style="font-weight: 700; background-color: white;">构造函数名.prototype.属性名</span><span style="font-weight: 700;">&nbsp;形式使用</span><br></li><li><b>能被实例对象继承</b><br></li></ul></div><h4 id="blogTitle20"><b>实例对象属性</b></h4><div><span style="font-weight: bold;">只能以&nbsp;<span style="background-color: white;">实例对象</span></span><span style="font-weight: bold; background-color: white;">名.</span><span style="font-weight: bold; background-color: white;">属性名</span><span style="font-weight: bold;">&nbsp;</span><span style="font-weight: bold;">形式使用</span><b><br></b></div><h4 id="blogTitle21"><b>公有属性</b></h4><h4 id="blogTitle22"><b>私有属性</b></h4><h4 id="blogTitle23"><b>动态属性</b></h4></div><h3 id="blogTitle24"><b>属性组成</b></h3><div><ul><li>属性名 - 键名：&nbsp;<var style="color: rgb(42, 161, 152); transition: background-color 0.25s ease; cursor: pointer; font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">P</var><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;is a property key value</span><br></li><li>属性值 - 键值：<var style="color: rgb(42, 161, 152); transition: background-color 0.25s ease; cursor: pointer; font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">V</var><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;is any&nbsp;</span><emu-xref href="#sec-ecmascript-language-types" id="_ref_2036" style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><a href="file:///C:/Users/Administrator/Desktop/ecma262-cn/index.html#sec-ecmascript-language-types" style="text-decoration-line: none; color: rgb(32, 108, 167);">ECMAScript language value</a></emu-xref><br></li><li>描述对象 - 控制该属性的行为：<var style="color: rgb(42, 161, 152); transition: background-color 0.25s ease; cursor: pointer; font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">Desc</var><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;is a&nbsp;</span><emu-xref href="#sec-property-descriptor-specification-type" id="_ref_2037" style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><a href="file:///C:/Users/Administrator/Desktop/ecma262-cn/index.html#sec-property-descriptor-specification-type" style="text-decoration-line: none; color: rgb(32, 108, 167);">Property Descriptor</a></emu-xref><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">&nbsp;record</span></li></ul></div><h4 id="blogTitle25">P: property key value</h4><div><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;"><span style="font-weight: 700;">一个对象的属性名可以是任何有效的 JavaScript 字符串或</span><b>&nbsp;symbol 符号</b><span style="font-weight: 700;">，或者可以被转换为字符串的任何类型，包括空字符串</span>。然而，<span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;">一个属性的名称如果不是一个有效的 ES 标识符（例如，一个由空格或连字符，或者以数字开头的属性名），就只能通过方括号标记访问。</font></span>这个标记法在属性名称是动态判定（属性名只有到运行时才能判定）时非常有用。例如：</p><pre style="margin-top: 0px; margin-bottom: 20px; padding: 15px; line-height: 19px; border-width: 0px; border-style: initial; border-color: initial;">// 同时创建四个变量，用逗号分隔
var myObj = new Object(),
    str = "myString",
    rand = Math.random(),
    obj = new Object();

myObj.type              = "Dot syntax";
myObj["date created"]   = "String with space";
myObj[str]              = "String value";
myObj[rand]             = "Random Number";
myObj[obj]              = "Object";
myObj[""]               = "Even an empty string";

console.log(myObj);
</pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;"><span id="result_box" lang="zh-CN" style="margin: 0px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px;">请注意，<span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;">方括号中的所有键都将转换为字符串类型</font></span>。</span>&nbsp;<span style="margin: 0px; padding: 0px; border: 0px;">例如，在上面的代码中，当将键 obj 添加到 myObj 时，JavaScript 将调用 obj.toString() 方法，并将此结果字符串用作新键。</span></span></p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">你也可以通过存储在变量中的字符串来访问属性：</p><div style="margin: 0px; padding: 0px; border: 0px; width: auto;"><pre class="brush: js line-numbers  language-js" style="margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var propertyName = "make";
myCar[propertyName] = "Ford";

propertyName = "model";
myCar[propertyName] = "Mustang";</span></pre></div></div><div><h5 style="margin-top: 25px;" id="blogTitle26"><span style="font-weight: 700;">重复属性名</span></h5><div><p style="">属性使用了同样的名称时，后面的属性会覆盖前面的属性。</p><pre class="brush: js line-numbers  language-js" style=""><span style="">var a = {x: 1, x: 2};
console.log(a); // { x: 2}</span></pre><p style="">在 ECMAScript 5 严格模式的代码中， 重复的属性名会被当做<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" title="SyntaxError&nbsp;对象代表尝试解析语法上不合法的代码的错误。" style="margin: 0px; padding: 0px; border: 0px;"><span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">SyntaxError</span></a>。引入计算的属性名以后，属性名会在运行时出现重复。ECMAScript 2015&nbsp;移除了这个限制。</p><pre class="brush: js line-numbers  language-js" style=""><span style="">function haveES6DuplicatePropertySemantics(){
  "use strict";
  try {
    ({ prop: 1, prop: 2 });

    // No error thrown, duplicate property names allowed in strict mode
    return true;
  } catch (e) {
    // Error thrown, duplicates prohibited in strict mode
    return false;
  }
}</span></pre></div><div><h5 style="margin-top: 25px;" id="blogTitle27"><span style="font-weight: 700;">计算属性名（</span><b>属性名表达式</b>）</h5><div><p style="">从ECMAScript 2015开始，对象初始化语法开始支持计算属性名。其允许在 [] 中放入表达式，计算结果可以当做属性名。这种用法和用方括号访问<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors" style="margin: 0px; padding: 0px; border: 0px;">属性</a>非常类似，也许你已经用来读取和设置属性了。现在同样的语法也可以用于对象字面值了：</p><p style="">JavaScript 定义对象的属性，有两种方法。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;</span></pre><p style="">上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p><p style="">但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var obj = {
  foo: true,
  abc: 123
};</span></pre><p style="">ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是另一个例子。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"</span></pre><p style="">表达式还可以用于定义方法名。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi</span></pre><p style="">注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><b>注意</b>，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[object Object]</code>，这一点要特别小心。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[keyA]</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[keyB]</code>得到的都是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[object Object]</code>，所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[keyB]</code>会把<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[keyA]</code>覆盖掉，而<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">myObject</code>最后只有一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[object Object]</code>属性。</p><h4 style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;" id="blogTitle28">V: ECMAScript language value</h4></div></div></div><div>属性值可以是任何 ES 数据类型，包括函数和对象。属性值为函数的属性也叫做对象的方法。</div><div><h4 id="blogTitle29">Desc: Property Descriptor record</h4><div><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><pre class=" language-javascript" style="padding-left: 0.7rem; border-radius: 5px; line-height: 1.2; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; margin: 0.5em auto;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">let obj = { foo: 123 }
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }</span></pre></div><div><div><p style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">Attributes are used in this specification to define and explain the state of Object properties. A data property associates a key value with the attributes listed in&nbsp;<emu-xref href="#table-2" id="_ref_30"><a href="https://pointworld.github.io/ecma262-cn/#table-2" style="text-decoration-line: none; color: rgb(32, 108, 167);">Table 2</a></emu-xref>&nbsp;.</p><emu-table id="table-2" caption="Attributes of a Data Property" style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><figure style="display: flex; margin: 1em 0px 3em; flex-direction: column; align-items: center;"><figcaption style="color: rgb(85, 85, 85); font-weight: bold; text-align: center;">Table 2: Attributes of a Data Property</figcaption><table style="width: 556px; margin: 0px auto;"><tbody><tr><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Attribute Name</th><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Value Domain</th><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Description</th></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Value]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Any&nbsp;<emu-xref href="#sec-ecmascript-language-types" id="_ref_842"><a href="https://pointworld.github.io/ecma262-cn/#sec-ecmascript-language-types" style="text-decoration-line: none; color: rgb(32, 108, 167);">ECMAScript language type</a></emu-xref></td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">The value retrieved by a get access of the property.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Writable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Boolean</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If&nbsp;<emu-val style="font-weight: bold;">false</emu-val>, attempts by ECMAScript code to change the property's [[Value]] attribute using [[Set]] will not succeed.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Enumerable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Boolean</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If&nbsp;<emu-val style="font-weight: bold;">true</emu-val>, the property will be enumerated by a for-in enumeration (see&nbsp;<emu-xref href="#sec-for-in-and-for-of-statements" id="_ref_31"><a href="https://pointworld.github.io/ecma262-cn/#sec-for-in-and-for-of-statements" style="text-decoration-line: none; color: rgb(32, 108, 167);">13.7.5</a></emu-xref>&nbsp;). Otherwise, the property is said to be non-enumerable.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Configurable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Boolean</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If&nbsp;<emu-val style="font-weight: bold;">false</emu-val>, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to&nbsp;<emu-val style="font-weight: bold;">false</emu-val>) will fail.</td></tr></tbody></table></figure></emu-table><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"></span><p style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">An accessor property associates a key value with the attributes listed in&nbsp;<emu-xref href="#table-3" id="_ref_32"><a href="https://pointworld.github.io/ecma262-cn/#table-3" style="text-decoration-line: none; color: rgb(32, 108, 167);">Table 3</a></emu-xref>&nbsp;.</p><emu-table id="table-3" caption="Attributes of an Accessor Property" style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><figure style="display: flex; margin: 1em 0px 3em; flex-direction: column; align-items: center;"><figcaption style="color: rgb(85, 85, 85); font-weight: bold; text-align: center;">Table 3: Attributes of an Accessor Property</figcaption><table style="width: 556px; margin: 0px auto;"><tbody><tr><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Attribute Name</th><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Value Domain</th><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Description</th></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Get]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Object | Undefined</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If the value is an Object it must be a&nbsp;<emu-xref href="#function-object" id="_ref_843"><a href="https://pointworld.github.io/ecma262-cn/#function-object" style="text-decoration-line: none; color: rgb(32, 108, 167);">function object</a></emu-xref>. The function's [[Call]] internal method (&nbsp;<emu-xref href="#table-6" id="_ref_33"><a href="https://pointworld.github.io/ecma262-cn/#table-6" style="text-decoration-line: none; color: rgb(32, 108, 167);">Table 6</a></emu-xref>&nbsp;) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Set]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Object | Undefined</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If the value is an Object it must be a&nbsp;<emu-xref href="#function-object" id="_ref_844"><a href="https://pointworld.github.io/ecma262-cn/#function-object" style="text-decoration-line: none; color: rgb(32, 108, 167);">function object</a></emu-xref>. The function's [[Call]] internal method (&nbsp;<emu-xref href="#table-6" id="_ref_34"><a href="https://pointworld.github.io/ecma262-cn/#table-6" style="text-decoration-line: none; color: rgb(32, 108, 167);">Table 6</a></emu-xref>&nbsp;) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Enumerable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Boolean</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If&nbsp;<emu-val style="font-weight: bold;">true</emu-val>, the property is to be enumerated by a for-in enumeration (see&nbsp;<emu-xref href="#sec-for-in-and-for-of-statements" id="_ref_35"><a href="https://pointworld.github.io/ecma262-cn/#sec-for-in-and-for-of-statements" style="text-decoration-line: none; color: rgb(32, 108, 167);">13.7.5</a></emu-xref>&nbsp;). Otherwise, the property is said to be non-enumerable.</td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Configurable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">Boolean</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">If&nbsp;<emu-val style="font-weight: bold;">false</emu-val>, attempts to delete the property, change the property to be a data property, or change its attributes will fail.</td></tr></tbody></table></figure></emu-table><span style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"></span><p style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;">If the initial values of a property's attributes are not explicitly specified by this specification, the default value defined in&nbsp;<emu-xref href="#table-4" id="_ref_36"><a href="https://pointworld.github.io/ecma262-cn/#table-4" style="text-decoration-line: none; color: rgb(32, 108, 167);">Table 4</a></emu-xref>&nbsp;is used.</p><emu-table id="table-4" caption="Default Attribute Values" style="color: rgb(17, 17, 17); font-family: Cambria, &quot;Palatino Linotype&quot;, Palatino, &quot;Liberation Serif&quot;, serif; font-size: 18px;"><figure style="display: flex; margin: 1em 0px 3em; flex-direction: column; align-items: center;"><figcaption style="color: rgb(85, 85, 85); font-weight: bold; text-align: center;">Table 4: Default Attribute Values</figcaption><table style="width: 556px; margin: 0px auto;"><tbody><tr><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Attribute Name</th><th style="border-color: black; background-color: rgb(238, 238, 238); border-top-width: 1px; border-top-style: solid; border-right-width: 1px; border-right-style: solid; border-left-width: 1px; border-left-style: solid; border-image: initial; padding: 0.4em; vertical-align: baseline;">Default Value</th></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Value]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">undefined</emu-val></td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Get]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">undefined</emu-val></td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Set]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">undefined</emu-val></td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Writable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">false</emu-val></td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Enumerable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">false</emu-val></td></tr><tr><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;">[[Configurable]]</td><td style="border-width: 1px; border-style: solid; border-color: black; padding: 0.4em; vertical-align: baseline;"><emu-val style="font-weight: bold;">false</emu-val></td></tr></tbody></table></figure></emu-table></div><h5 id="blogTitle30">属性描述对象的设置</h5><div><pre>Object.defineProperty(a, b, c)</pre><div><b>参数介绍：</b></div><div><ul><li>a: 待设置属性的对象<br></li><li>b: 需要设置的属性名（键）<br></li><li>c: 是一个用于描述属性值的 json 数据。这个 json 数据由&nbsp;configurable，eumerable，writable，value 构成</li></ul></div></div></div><div><div><h5 id="blogTitle31">属性的读写权限</h5></div><div><span style="font-weight: 700;">给属性添加权限的必要性</span><br></div><div>-- 比如 文件系统 我们可以设置只允许访问，不可以修改</div><div><h5 id="blogTitle32" style="margin-top: 25px;">属性的访问权限</h5></div></div></div><h3 id="blogTitle33"><span style="font-weight: 700;">属性访问</span></h3><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">一个 ES 对象有很多属性。一个对象的属性可以被解释成一个附加到对象上的变量。<span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;">对象的属性和普通的 ES 变量基本没什么区别，仅仅是属性属于某个对象。</font></span>属性定义了对象的特征</span></p><p style="">创建对象后，可以读取或者修改它。对象属性可以用下标小圆点标记或者方括号标记访问。参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors" style="margin: 0px; padding: 0px; border: 0px;">属性访问</a>&nbsp;获取更多信息。</p><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></span></p><pre class="syntaxbox" style="">object.property
object["property"]</pre><p style="">我们可以将对象看做是一个关联数组，或映射，字典，哈希表，查找表。这个数组中的键就是这个对象中属性的名称。通常，当我们提及一个对象的属性时，会对属性与方法之间做个对比。然而，属性与方法之间的区别并不大。一个方法就是一个可以被调用的属性而已，例如一个指向<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Function" style="margin: 0px; padding: 0px; border: 0px;">Function</a>实例的引用可以作为对象属性的值。</p><p style=""></p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px; box-sizing: border-box; max-width: 42rem;">访问对象属性有两种方式：点号表示法和方括号表示法。</p><h4 style="" id="blogTitle34"><span style=""><b>点号表示法</b></span></h4><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></span></p><pre class="brush: js line-numbers  language-js" style=""><span style="">get = object.property;
object.property = set;</span></pre><p style="">以上代码中，<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">property</span>必须是一个有效的 JavaScript 标识符，例如，一串字母数字字符，也包括下划线及美元符号，但不能以数字作为开头。比如，<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">object.$1</span>是合法的，而&nbsp;<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">object.1</span>是无效不合法的。</p><pre class="brush: js line-numbers  language-js" style=""><span style="">document.createElement('pre');</span></pre><p style="">在上述代码块中，<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">document</span>中存在一个名为"createElement"的方法并且被调用了。</p><p style="">如果对数字字面量使用方法，并且数字文字没有指数且没有小数点，请在方法调用之前的点之前留出空格，以防止点被解释为小数点。</p><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></span></p><pre class="brush: js line-numbers  language-js" style=""><span style="">77 .toExponential();
// or
77
.toExponential();
// or
(77).toExponential();
// or
77..toExponential();
// or
77.0.toExponential();
// because 77. === 77.0, no ambiguity</span></pre><div class="note" style="margin: 0px 0px 20px; padding: 10px 10px 10px 30px; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-left-style: solid; border-color: rgb(255, 226, 115); border-image: initial; overflow: hidden; clear: none; background: rgb(255, 245, 204); color: rgb(59, 60, 64); font-family: &quot;Open Sans&quot;, arial, sans-serif;"><p style="margin-bottom: 0px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; font-weight: 700;">注意：</span>从 EcmaScript 5 开始，预留关键字可以作为对象的属性名（reserved words may be used as object property names "in the buff"）。&nbsp;这意味着当定义对象字面量时不需要用双引号了。参见&nbsp;ES5&nbsp;<a href="http://es5.github.io/#x7.6.1" class="external external-icon" style="color: rgb(33, 122, 192); margin: 0px; padding: 0px; border: 0px; white-space: pre-line;">Spec</a>.</p></div><h4 id="blogTitle35"><b>方括号表示法</b></h4><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;"><span style="font-weight: 700;">通过方括号访问或者设置对象属性</span></p><pre class="brush: js line-numbers  language-js" style=""><span style="">get = object[property_name];
object[property_name] = set;</span></pre><p style=""><span style="">property_name</span>&nbsp;是一个字符串。该字符串不一定是一个合法的标识符；它可以是任意值，例如，"1foo"，"!bar!"，&nbsp;甚至是一个空格。</p><pre class="brush: js line-numbers  language-js" style=""><span style="">document['createElement']('pre');</span></pre><p style="">这里的代码的功能跟上一个列子的作用是相同的。</p><p style="">括号之前允许有空格。</p><pre class="brush: js" style=""><span style="">document ['createElement']('pre');</span></pre></div><h3 id="blogTitle36"><span style="font-weight: 700;">属性赋值和删除</span></h3><div><div>由于 ES 的对象是动态类型，你可以自由地给一个对象添加或删除属性：</div><pre style="font-size: 15px;">var xiaoming = {<br>&nbsp; &nbsp; name: '小明'<br>};<br>xiaoming.age; // undefined<br>xiaoming.age = 18; // 新增一个age属性<br>xiaoming.age; // 18<br>delete xiaoming.age; // 删除age属性<br>xiaoming.age; // undefined<br>delete xiaoming['name']; // 删除name属性<br>xiaoming.name; // undefined<br>delete xiaoming.school; // 删除一个不存在的school属性也不会报错</pre></div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">你可以用&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" style="margin: 0px; padding: 0px; border: 0px;">delete</a>&nbsp;操作符删除一个不是继承而来的属性。下面的例子说明如何删除一个属性：</p><pre class="brush: js line-numbers  language-js" style=""><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">//Creates a new object, myobj, with two properties, a and b.
var myobj = new Object;
myobj.a = 5;
myobj.b = 12;

//Removes the a property, leaving myobj with only the b property.
delete myobj.a;</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">如果一个全局变量不是用&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-size: 15px;">var</span></font>&nbsp;关键字声明的话，你也可以用&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit; font-size: 15px;">delete</span></font>&nbsp;删除它（window 对象的动态属性）：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">g = 17;
delete g;</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">参见&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_operators#delete" style="word-wrap: break-word; margin: 0px; padding: 0px; border: 0px;">delete</a><span style="border-style: initial; border-color: initial;">&nbsp;以获取更多信息。</span></p><h3 id="blogTitle37"><span style="font-weight: 700;">为对象类型定义属性</span></h3><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">你可以通过&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">prototype</span></font>&nbsp;属性为之前定义的对象类型增加属性。这为该类型的所有对象，而不是仅仅一个对象增加了一个属性。下面的代码为所有类型为&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">car</span></font>&nbsp;的对象增加了&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">color</span></font>&nbsp;属性，然后为对象&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">car1</span></font>&nbsp;的&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">color</span></font>&nbsp;属性赋值：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">Car.prototype.color = null;
car1.color = "black";</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">参见<span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">&nbsp;</span><a title="zh-CN/docs/JavaScript/Reference" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">JavaScript Reference</a><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">&nbsp;中</span><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">&nbsp;Function 对象的&nbsp;</span><a title="zh-CN/docs/JavaScript/Reference/Global Objects/Function/prototype" class="new" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Function/prototype" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"><font face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; font-weight: inherit; font-style: inherit;">prototype</span></font>&nbsp;属性</a><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">&nbsp;。</span></p></div><h3 id="blogTitle38"><span style="font-weight: 700;">属性的取值器（getters）与设置器（</span>setters）</h3><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">一个&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" style="margin: 0px; padding: 0px; border: 0px;">getter</a>&nbsp;是一个获取某个特定属性的值的方法。一个&nbsp;&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" style="margin: 0px; padding: 0px; border: 0px;">setter</a>&nbsp;是一个设定某个属性的值的方法。你可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性。定义 getter 和 setter 的语法采用对象字面量语法。</p><div><span style="font-weight: 700;">作用</span></div><div><ul><li>对属性封装一些操作: 比如判断,校验,默认值等等<br></li><li>保护某些属性<br></li><li>双校验（后台开发校验、前端开发也校验）</li></ul><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">function </span><span style="color: rgb(166, 226, 46);">Product</span>(<span style="color: rgb(253, 151, 31); font-style: italic;">name</span><span style="color: rgb(92, 122, 184);">, </span><span style="color: rgb(253, 151, 31); font-style: italic;">price</span>) {<br>    <span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">属性 行为 可以为空或者给默认值</span><span style="color: rgb(9, 125, 36);">*/<br></span><span style="color: rgb(9, 125, 36);">    </span><span style="color: rgb(249, 38, 114);">this</span>.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">name<br></span><span style="color: rgb(253, 151, 31); font-style: italic;">    </span><span style="color: rgb(249, 38, 114);">this</span>.price <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">0</span><span style="color: rgb(230, 219, 116);"><br></span><span style="color: rgb(230, 219, 116);">    </span><span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">我们的需求：自动计算打折后的价格</span><span style="color: rgb(9, 125, 36);">*/<br></span><span style="color: rgb(9, 125, 36);">    /*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">形象的理解：属性包装</span><span style="color: rgb(9, 125, 36);">*/<br></span><span style="color: rgb(9, 125, 36);">    </span>Object.<span style="color: rgb(166, 226, 46);">defineProperty</span>(<span style="color: rgb(249, 38, 114);">this</span><span style="color: rgb(92, 122, 184);">, </span><span style="color: rgb(230, 219, 116);">"price"</span><span style="color: rgb(92, 122, 184);">, </span>{<br>        <span style="color: rgb(166, 226, 46);">get</span><span style="color: rgb(249, 38, 114);">: function </span>() {<br>            <span style="color: rgb(249, 38, 114);">return </span><span style="color: rgb(253, 151, 31); font-style: italic;">price </span><span style="color: rgb(249, 38, 114);">* </span><span style="color: rgb(174, 129, 255);">0.9</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">        </span>}<span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">        </span><span style="color: rgb(166, 226, 46);">set</span><span style="color: rgb(249, 38, 114);">: function </span>(<span style="color: rgb(253, 151, 31); font-style: italic;">value</span>) {<br>            <span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">大概普通产品的价格都在</span><span style="color: rgb(9, 125, 36);">0--1</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">万</span><span style="color: rgb(9, 125, 36);">*/<br></span><span style="color: rgb(9, 125, 36);">            </span><span style="color: rgb(249, 38, 114);">if </span>(<span style="color: rgb(253, 151, 31); font-style: italic;">value </span><span style="color: rgb(249, 38, 114);">&gt; </span><span style="color: rgb(174, 129, 255);">10000</span>) {<br>                <span style="color: rgb(166, 226, 46);">alert</span>(<span style="color: rgb(230, 219, 116);">'</span><span style="color: rgb(230, 219, 116); font-family: SimSun;">产品价格必须在</span><span style="color: rgb(230, 219, 116);">0--1</span><span style="color: rgb(230, 219, 116); font-family: SimSun;">万之间</span><span style="color: rgb(230, 219, 116);">'</span>)<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">            </span>} <span style="color: rgb(249, 38, 114);">else </span>{<br>                <span style="color: rgb(253, 151, 31); font-style: italic;">price </span><span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">value</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">            </span>}<br>        }<br>    })<span style="color: rgb(92, 122, 184);">;<br></span>}<br><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(166, 226, 46);">Product</span>.prototype <span style="color: rgb(249, 38, 114);">= </span>{<br>    <span style="color: rgb(166, 226, 46);">getPrice</span><span style="color: rgb(249, 38, 114);">: function </span>() {<br>        <span style="color: rgb(249, 38, 114);">return this</span>.price<br>    }<br>}<br><br><span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">搭积木开发</span><span style="color: rgb(9, 125, 36);"> -- </span><span style="color: rgb(9, 125, 36); font-family: SimSun;">代码可读性极高</span><span style="color: rgb(9, 125, 36);">*/<br></span>window.<span style="color: rgb(166, 226, 46);">onload </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    <span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">实例化</span><span style="color: rgb(9, 125, 36);"> -- </span><span style="color: rgb(9, 125, 36); font-family: SimSun;">实例</span><span style="color: rgb(9, 125, 36);"> -- </span><span style="color: rgb(9, 125, 36); font-family: SimSun;">具体</span><span style="color: rgb(9, 125, 36);">*/</span><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;">  </span><span style="color: rgb(249, 38, 114);">var </span>iphone <span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Product</span>()<br><br>    <span style="color: rgb(9, 125, 36);">/*</span><span style="color: rgb(9, 125, 36); font-family: SimSun;">给对象的赋值赋值，也可以新增属性</span><span style="color: rgb(9, 125, 36);">*/<br></span><span style="color: rgb(9, 125, 36);">    </span>iphone.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'iphone7'<br></span><span style="color: rgb(230, 219, 116);">    </span>iphone.price <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">6000

</span>    alert(iphone.price) // 5400<br>}</pre></div></div><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">下面例子描述了getters 和 setters 是如何为用户定义的对象<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; background-color: rgb(255, 255, 255); font-weight: inherit; font-style: inherit;">&nbsp;o&nbsp;</span></font>工作的。</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var o = {
  a: 7,
  get b() {
    return this.a + 1
  },
  set c(x) {
    this.a = x / 2
  }
}

console.log(o.a) // 7
console.log(o.b) // 8
o.c = 50
console.log(o.a) // 25</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;"><span style="border-style: initial; border-color: initial;">o</span>&nbsp;对象的属性如下：</p><ul style="margin-top: 0px; margin-bottom: 24px; padding: 0px 0px 0px 40px; list-style-position: initial; list-style-image: initial; border: 0px;"><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><span style="border-style: initial; border-color: initial;">o.a</span>&nbsp;— 数字</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><font face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; font-style: inherit; font-weight: inherit;">o.b</span></font>&nbsp;— 返回&nbsp;<font face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; font-style: inherit; font-weight: inherit;">o.a</span></font>&nbsp;+ 1 的 getter</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgb(255, 255, 255); border-style: initial; border-color: initial; font-style: inherit; font-weight: inherit;">o.c</span></font>&nbsp;— 由&nbsp;&nbsp;<font color="#3b3c40" face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgb(255, 255, 255); border-style: initial; border-color: initial; font-style: inherit; font-weight: inherit;">o.c 的值所设置&nbsp;</span></font><font face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; font-style: inherit; font-weight: inherit;">o.a</span></font>&nbsp;值的&nbsp;setter</li></ul><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">请注意在一个对象字面量语法中定义 getter 和 setter 使用 "[gs]et property()" 的方式（相比较于 __define[GS]etter__) 时，并不是获取和设置某个属性自身，容易让人误以为是 "[gs]et propertyName(){ }" 这样错误的使用方法。定义一个 getter 或 setter 函数使用语法 "[gs]et property()"，定义一个已经声明的函数作为的 getter 和 setter 方法，使用&nbsp;<a title="zh-CN/docs/Core JavaScript 1.5 Reference/Global
Objects/Object/defineProperty" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/defineProperty" style="word-wrap: break-word; margin: 0px; padding: 0px; border: 0px;">Object.defineProperty</a><span style="word-wrap: break-word; margin: 0px; padding-right: 0px; padding-left: 0px; border-width: 0px; border-style: initial; border-color: initial;">(或者&nbsp;</span><a title="zh-CN/docs/Core JavaScript 1.5 Reference/Global
Objects/Object/defineGetter" class="new" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/defineGetter" style="word-wrap: break-word; margin: 0px; padding: 0px; border: 0px;">Object.prototype.__defineGetter__</a><span style="word-wrap: break-word; margin: 0px; padding-right: 0px; padding-left: 0px; border-width: 0px; border-style: initial; border-color: initial;">&nbsp;旧语法回退)</span></p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">下面这个例子展示使用 getter 和 setter 方法扩展&nbsp;<font face="consolas, Liberation Mono, courier, monospace" style="margin: 0px; padding: 0px; border: 0px;"><span style="border-style: initial; border-color: initial; font-weight: inherit; font-style: inherit;"><a title="此页面仍未被本地化, 期待您的翻译!" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Date" style="margin: 0px; padding: 0px; border: 0px;">Date</a>&nbsp;</span></font>原型，为预定义好的 Date 类添加一个 year 的属性。定义属性 year 的 getter 和 setter 方法用到了 Date 类中已存在的 getFullYear 和 setFullYear 方法。</p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">定义属性 year 的 getter 和 setter：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var d = Date.prototype;
Object.defineProperty(d, "year", {
  get: function() { return this.getFullYear() },
  set: function(y) { this.setFullYear(y) }
});</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">通过一个 Date 对象使用 getter 和 setter:</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var now = new Date();
console.log(now.year); // 2000
now.year = 2001; // 987617605170
console.log(now);
// Wed Apr 18 11:13:25 GMT-0700 (Pacific Daylight Time) 2001</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">原则上，getter 和 setter 既可以：</p><ul style="margin-top: 0px; margin-bottom: 24px; padding: 0px 0px 0px 40px; list-style-position: initial; list-style-image: initial; border: 0px;"><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;">使用&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#Using_object_initializers" style="margin: 0px; padding: 0px; border: 0px;">object initializers</a>&nbsp;定义</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;">也可以之后随时使用 getter 和 setter 添加方法添加到任何对象</li></ul><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">当使用&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#Using_object_initializers" style="margin: 0px; padding: 0px; border: 0px;">object initializers</a>&nbsp;的方式定义 getter 和 setter 时，只需要在 getter 方法前加 get，在 setter 方法前加 set，当然，getter 方法必须是无参数的，setter方法只接受一个参数(设置为新值），例如：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var o = {
  a: 7,
  get b() { return this.a + 1; },
  set c(x) { this.a = x / 2; }
};</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">使用 Object.defineProperties 的方法，同样也可以对一个已创建的对象在任何时候为其添加 getter 或 setter 方法。这个方法的第一个参数是你想定义 getter 或 setter 方法的对象，第二个参数是一个对象，这个对象的属性名用作 getter 或 setter 的名字，属性名对应的属性值用作定义 getter 或 setter 方法的函数，下面是一个例子定义了和前面例子一样的 getter 和 setter 方法：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var o = { a: 0 }

Object.defineProperties(o, {
    "b": { get: function () { return this.a + 1; } },
    "c": { set: function (x) { this.a = x / 2; } }
});

o.c = 10 // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(o.b) // Runs the getter, which yields a + 1 or 6</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">这两种定义方式的选择取决于你的编程风格和手头的工作量。当你定义一个原型准备进行初始化时，可以选择第一种方式，这种方式更简洁和自然。但是，当你需要添加getter 和 setter 方法 ——&nbsp;因为并没有编写原型或者特定的对象 ——使用第二种方式更好。第二种方式可能更能表现 JavaScript 语法的动态特性——但也会使代码变得难以阅读和理解。</p></div><h3 id="blogTitle39"><b>属性的可枚举性和遍历</b></h3><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">从&nbsp;<a title="zh-CN/docs/JavaScript/ECMAScript 5 support in Mozilla" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/ECMAScript_5_support_in_Mozilla" style="margin: 0px; padding: 0px; border: 0px;">ECMAScript 5</a>&nbsp;开始，有三种原生的方法用于列出或枚举对象的属性：</p><ul style="margin-top: 0px; margin-bottom: 24px; padding: 0px 0px 0px 40px; list-style-position: initial; list-style-image: initial; border: 0px;"><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><a title="zh-CN/docs/JavaScript/Reference/Statements/for...in" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Statements/for...in" style="margin: 0px; padding: 0px; border: 0px;">for...in</a>&nbsp;循环<br>该方法依次访问一个对象及其原型链中所有可枚举的属性。</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><a title="zh-CN/docs/JavaScript/Reference/Global Objects/Object/keys" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/keys" style="margin: 0px; padding: 0px; border: 0px;">Object.keys(o)</a><br>该方法返回一个对象&nbsp;<span style="border-style: initial; border-color: initial;">o</span>&nbsp;自身包含（不包括原型中）的所有属性的名称的数组。</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;"><a title="zh-CN/docs/JavaScript/Reference/Global Objects/Object/getOwnPropertyNames" href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" style="margin: 0px; padding: 0px; border: 0px;">Object.getOwnPropertyNames(o)</a><br>该方法返回一个数组，它包含了对象&nbsp;<span style="border-style: initial; border-color: initial;">o</span>&nbsp;所有拥有的属性（无论是否可枚举）的名称的数组。</li></ul><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">在 ECMAScript 5 之前，没有原生的方法枚举一个对象的所有属性。然而，可以通过以下函数完成：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">function listAllProperties(o){
    var objectToInspect;
    var result = [];

    for(objectToInspect = o; objectToInspect !== null; objectToInspect = Object.getPrototypeOf(objectToInspect)){
        result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    }

    return result;
}</span></pre></div><div>这在展示 “隐藏”（在原型中的不能通过对象访问的属性，因为另一个同名的属性存在于原型链的早期）的属性时很有用。可以通过在数组中去除同名元素即可轻松地列出访问的属性。</div><div><h4 style="margin-top: 25px;" id="blogTitle40"><span style="font-weight: 700;">可枚举性</span></h4></div><div><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">描述对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</code>属性，称为”可枚举性“，如果该属性为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">false</code>，就表示某些操作会忽略当前属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">目前，有四个操作会忽略<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</code>为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">false</code>的属性。</p><ul><li>for...in&nbsp;<span style="text-indent: -5px;">循环：只遍历对象自身的和继承的可枚举的属性。</span><br></li><li>Object.keys()<span style="text-indent: -5px;">：返回对象自身的所有可枚举的属性的键名。</span><br></li><li>JSON.stringify()<span style="text-indent: -5px;">：只串行化对象自身的可枚举的属性。</span><br></li><li>Object.assign()<span style="text-indent: -5px;">： 忽略</span><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-indent: -5px; border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</span><span style="text-indent: -5px;">为</span><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-indent: -5px; border-radius: 2px; padding-left: 3px; padding-right: 3px;">false</span><span style="text-indent: -5px;">的属性，只拷贝对象自身的可枚举的属性。</span><br></li></ul><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这四个操作之中，前三个是 ES5 就有的，最后一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.assign()</code>是 ES6 新增的。其中，只有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，<b style="background-color: yellow;">引入“可枚举”（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>方法，以及数组的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px; padding-left: 3px; padding-right: 3px;">length</code>属性，就通过“可枚举性”，从而避免被<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>遍历到。</b></p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false

Object.getOwnPropertyDescriptor([], 'length').enumerable
// false</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">length</code>属性的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</code>都是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">false</code>，因此<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>不会遍历到这两个继承自原型的属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>循环，而用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.keys()</code>代替。</p></div><h4 id="blogTitle41"><b>属性的遍历</b></h4><div><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 一共有 5 种方法可以遍历对象的属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（1）for...in</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（2）Object.keys(obj)</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getOwnPropertyNames</code>返回一个数组，包含对象自身<span style="font-size: 14.336px;">（不含继承的）</span><span style="font-size: 14.336px;">的所有属性（不含 Symbol 属性，但是<b style="background-color: yellow;">包括不可枚举属性</b>）的键名。</span></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（5）Reflect.ownKeys(obj)</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p style=""><span style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">以上</span>的 5 种方法遍历对象的键名，都遵守同样的<b style="background-color: yellow;">属性遍历的次序规则</b>。</p><ul><li>首先遍历所有数值键，按照数值升序排列。<br></li><li>其次遍历所有字符串键，按照加入时间升序排列。<br></li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。<br></li></ul><pre class=" language-javascript" style="text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; line-height: 1.2;"><span style="background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; tab-size: 4; border-radius: 2px;">Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]</span></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">2</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">10</code>，其次是字符串属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">b</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>，最后是 Symbol 属性。</p></div><h3 id="blogTitle42"><b>检测</b><b>属性是否存在</b></h3><div><div>如果我们要检测 xiaoming 是否拥有某一属性，可以用&nbsp;<span style="background-color: white;">in&nbsp;</span>操作符：</div><pre style="font-size: 15px;">var xiaoming = {<br>&nbsp; &nbsp; name: '小明',<br>&nbsp; &nbsp; birth: 1990,<br>&nbsp; &nbsp; school: 'No.1 Middle School',<br>&nbsp; &nbsp; height: 1.70,<br>&nbsp; &nbsp; weight: 65,<br>&nbsp; &nbsp; score: null<br>};<br>'name' in xiaoming; // true<br>'grade' in xiaoming; // false</pre><div>不过要小心，如果&nbsp;<span style="background-color: white;">in&nbsp;</span>判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：</div><pre style="font-size: 15px;">'toString' in xiaoming; // true</pre><div>因为 toString 定义在 object 对象中，而所有对象最终都会在原型链上指向 object，所以 xiaoming 也拥有 toString 属性。</div><div><br></div><div>要判断一个属性是否是 xiaoming 自身拥有的，而不是继承得到的，可以用&nbsp;<span style="background-color: white;">hasOwnProperty()</span>方法：</div><p style="margin-bottom: 24px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></span></p><pre style="font-size: 15px;">var xiaoming = {<br>&nbsp; &nbsp; name: '小明'<br>};<br>xiaoming.hasOwnProperty('name')       // true<br>xiaoming.hasOwnProperty('toString')   // false</pre></div><h3 id="blogTitle43"><b>检测</b><b>属性来源</b></h3><div><p style="margin-top: 25px;"><span style="font-weight: 700;">原型中被屏蔽掉的属性</span></p><div>方法一：使用 delete，删除构造函数中与原型对象同名的属性，再用简化的点语法格式访问该属性</div><div>方法二：直接用原型对象属性的完整写法来获取，如：实例名.prototype.属性或方法名</div><div><br></div><div><div><b>hasOwnProperty() 方法 -- 判断实例属性和继承属性（原型属性或构造属性）</b></div><div>可以判定一个属性是存在于构造对象的实例上还是原型对象或构造函数上。该方法继承自 Object。</div><div>如果是实例对象 - true</div><div>如果是原型对象 - false</div></div><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);">let <span style="color: rgb(166, 226, 46);">Person </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">1<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(166, 226, 46);">Person</span>.prototype <span style="color: rgb(249, 38, 114);">= </span>{<br>    name<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'foo'<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span>let <span style="font-style: italic;">xiaowang </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Person</span>()<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">"name"</span>))<span style="color: rgb(92, 122, 184);">;</span><span style="color: rgb(11, 139, 21);">//false --</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">不是实例自定义的属性，而是原型对象属性<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">"age"</span>))<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(11, 139, 21);">//false --</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">不是实例自定义的属性，而是构造函数内定义的属性<br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(11, 139, 21);">//</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">当定义一个实例化属性之后，会自动屏蔽原型属性<br></span><span style="font-style: italic;">xiaowang</span>.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'foo'<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">'name'</span>)) <span style="color: rgb(11, 139, 21);">//true<br></span><span style="color: rgb(11, 139, 21);"><br></span><span style="font-style: italic;">xiaowang</span>.sex <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'nan'<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">'sex'</span>)) <span style="color: rgb(11, 139, 21);">//true</span></pre></div></div><h3 id="blogTitle44"><b>扩展属性</b></h3><p style="">ECMAScript 提案（第3阶段）的<a href="https://github.com/tc39/proposal-object-rest-spread" class="external external-icon" rel="noopener" style="margin: 0px; padding: 0px; border: 0px;">剩余/扩展属性</a>将<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator" style="margin: 0px; padding: 0px; border: 0px;">扩展</a>属性添加到对象文字。它将自己提供的对象的枚举属性复制到一个新的对象上。</p><p style="">使用比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" title="Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。" style="margin: 0px; padding: 0px; border: 0px;"><span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">Object.assign()</span></a>更短的语法，可以轻松克隆（不包括原型）或合并对象。</p><pre class="brush: js line-numbers  language-js" style=""><span style="">var obj1 = { foo: 'bar', x: 42 };
var obj2 = { foo: 'baz', y: 13 };

var clonedObj = { ...obj1 };
// Object { foo: "bar", x: 42 }

var mergedObj = { ...obj1, ...obj2 };
// Object { foo: "baz", x: 42, y: 13 }</span></pre><p style="">请注意，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" title="Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。" style="margin: 0px; padding: 0px; border: 0px;"><span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">Object.assign()</span></a>会触发<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" style="margin: 0px; padding: 0px; border: 0px;">setter</a>，而展开操作符则不会。</p><h3 style="" id="blogTitle45">变更原型</h3><p style="">定义属性为<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">"__proto__": 值</span>&nbsp;时，不会创建名为<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">__proto__</span>属性。如果给出的值是对象或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" style="margin: 0px; padding: 0px; border: 0px;"><span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">null</span></a>，那么对象的<span style="padding-right: 2px; padding-left: 2px; border-style: initial; border-color: initial; border-image: initial; border-radius: 2px;">[[Prototype]]</span>会被设置为给出的值。（如果给出的值不是对象也不是null，那么对象的原型不会改变。）</p><pre class="brush: js line-numbers  language-js" style=""><span style="border-style: initial; border-color: initial; border-image: initial; border-radius: 2px; line-height: 1.5; tab-size: 4; position: relative;">var obj1 = {};
assert(Object.getPrototypeOf(obj1) === Object.prototype); // ture

var obj2 = { __proto__: null };
assert(Object.getPrototypeOf(obj2) === null); // true

var protoObj = {};
var obj3 = { "__proto__": protoObj };
assert(Object.getPrototypeOf(obj3) === protoObj); // true

var obj4 = { __proto__: "not an object or null" };
assert(Object.getPrototypeOf(obj4) === Object.prototype); // true
assert(!obj4.hasOwnProperty("__proto__")); // true</span></pre><p style="">在对象字面值中，仅有一次变更原型的机会；多次变更原型，会被视为语法错误。</p><p style="">不使用冒号标记的属性定义，不会变更对象的原型；而是和其他具有不同名字的属性一样是普通属性定义。</p><pre class="brush: js line-numbers  language-js" style=""><span style="border-style: initial; border-color: initial; border-image: initial; border-radius: 2px; line-height: 1.5; tab-size: 4; position: relative;">var __proto__ = "variable";

var obj1 = { __proto__ };
assert(Object.getPrototypeOf(obj1) === Object.prototype);
assert(obj1.hasOwnProperty("__proto__"));
assert(obj1.__proto__ === "variable");

var obj2 = { __proto__() { return "hello"; } };
assert(obj2.__proto__() === "hello");

var obj3 = { ["__prot" + "o__"]: 17 };
assert(obj3.__proto__ === 17);</span></pre><div><div><div><h3 id="blogTitle46">公有属性和私有属性</h3></div><div><b>JS 中的对象本身就是由函数实现的，所以函数有的一切特性 JS 对象都有。</b></div><div><ul><li><b>私有属性：</b>利用函数作用域中定义的变量只能在该函数内部访问，来实现对象的私有属性。函数外部不能访问，即对象的使用者无法使用到对象内部定义的私有属性，只能在构造函数内部使用。<br></li><li><b>公有属性：</b>即用 this 语法定义的属性，可以在构造函数内部或对象实例化后使用。</li></ul><h3 id="blogTitle47">属性搜索机制</h3></div></div><h2 id="blogTitle48"><b>对象的扩展运算符</b></h2><div><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES2017 将这个运算符<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" style="background-position: initial; color: rgb(70, 130, 190);">引入</a>了对象。</p><h3 style="" id="blogTitle49"><b>（1）解构赋值</b></h3><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }
x // 1
y // 2
z // { a: 3, b: 4 }</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，变量<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">b</code>），将它们连同值一起拷贝过来。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">undefined</code>或<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">null</code>，就会报错，因为它们无法转为对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">解构赋值必须是最后一个参数，否则会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let { ...x, y, z } = obj; // 句法错误
let { x, ...y, ...z } = obj; // 句法错误</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，解构赋值不是最后一个参数，所以会报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>是解构赋值所在的对象，拷贝了对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">obj</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>属性。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o3</code>复制了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o2</code>，但是只复制了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o2</code>自身的属性，没有复制它的原型对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o1</code>的属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是另一个例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...{ y, z } } = o;
x // 1
y // undefined
z // 3</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，变量<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>是单纯的解构赋值，所以可以读取对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o</code>继承的属性；变量<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">y</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">z</code>是扩展运算符的解构赋值，只能读取对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">o</code>自身的属性，所以变量<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">z</code>可以赋值成功，变量<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">y</code>取不到值。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用x和y参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，原始函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">baseFunction</code>接受<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">b</code>作为参数，函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">wrapperFunction</code>在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><h3 style="" id="blogTitle50"><b>（2）扩展运算符</b></h3><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">扩展运算符（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这等同于使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.assign</code>方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，写法一的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">扩展运算符可以用于合并两个对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>属性和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">y</code>属性，拷贝到新对象后会被覆盖掉。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这用来修改现有对象部分的属性就很方便了。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">newVersion</code>对象自定义了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">name</code>属性，其他属性全部复制自<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">previousVersion</code>对象。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const obj = {
  ...(x &gt; 1 ? {a: 1} : {}),
  b: 2,
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果扩展运算符后面是一个空对象，则没有任何效果。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">{...{}, a: 1}
// { a: 1 }</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果扩展运算符的参数是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">null</code>或<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">undefined</code>，这两个值会被忽略，不会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let emptyObject = { ...null, ...undefined }; // 不报错</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">扩展运算符的参数对象之中，如果有取值函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">get</code>，这个函数是会执行的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// 并不会抛出错误，因为 x 属性只是被定义，但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throw new Error('not throw yet');
  }
};

// 会抛出错误，因为 x 属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throw new Error('throw now');
    }
  }
};</code></pre></div><h2 id="blogTitle51">函数调用时的 this 指向</h2><div><b><font color="#000000" style="background-color: yellow;">本质：在函数调用中 this 永远指向当前调用的对象</font></b></div><h3 id="blogTitle52"><b>函数调用模式</b></h3><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">//</span><span style="color:#75715e;font-family:'SimSun';">第一种：函数调用模式<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">add</span>(<span style="color:#fd971f;font-style:italic;">a</span><span style="color:#5c7ab8;">, </span><span style="color:#fd971f;font-style:italic;">b</span>) {<br>    console.<span style="color:#a6e22e;">log</span>(<span style="color:#f92672;">this</span>)<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">    </span><span style="color:#f92672;">return </span><span style="color:#fd971f;font-style:italic;">a </span><span style="color:#f92672;">+ </span><span style="color:#fd971f;font-style:italic;">b</span><span style="color:#5c7ab8;">;<br></span>}<br><br><span style="color:#a6e22e;">add</span>()<span style="color:#5c7ab8;">;</span><span style="color:#75715e;">// 若函数在全局作用域中定义，则调用时 函数内的 this === window // true<br></span><span style="color:#75715e;"><br></span></pre></div><div><b>在全局中定义函数，相当于给 window 对象动态添加一个方法，故 add = window.add</b></div><div><b>故：</b></div><div><b>当调用该函数时，函数中的 this 会指向当前调用的对象 window，即 this === window</b></div><h3 id="blogTitle53"><b>对象方法调用模式</b></h3><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">// </span><span style="color:#75715e;font-family:'SimSun';">第二种：对象方法调用模式<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">Cat</span>() {<br>    <span style="color:#f92672;">this</span>.<span style="color:#a6e22e;">show </span><span style="color:#f92672;">= function </span>() {<br>        console.<span style="color:#a6e22e;">log</span>(<span style="color:#f92672;">this</span>)<span style="color:#75715e;"><br></span><span style="color:#75715e;">    </span>}<span style="color:#5c7ab8;"><br></span>}
<br><span style="color:#f92672;">var </span><span style="font-style:italic;">cat </span><span style="color:#f92672;">= new </span><span style="color:#a6e22e;">Cat</span>()<span style="color:#75715e;"><br></span><span style="font-style:italic;">cat</span>.<span style="color:#a6e22e;">show</span>()<span style="color:#5c7ab8;"> </span><span style="color:#75715e;">// </span><span style="color:#75715e;font-family:'SimSun';">对象调用自己的方法，</span><span style="color:#75715e;">// this === cat;<br></span><span style="color:#75715e;"><br></span><span style="color:#75715e;">// </span><span style="color:#75715e;font-family:'SimSun';">所有的事件响应的方法都是 对象方法调用模式。</span></pre></div><h3 id="blogTitle54"><b>构造器调用模式</b></h3><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">//</span><span style="color:#75715e;font-family:'SimSun';">第三种：构造器调用模式<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">Person</span>() {<br>    <span style="color:#f92672;">this</span>.name <span style="color:#f92672;">= </span><span style="color:#e6db74;">"123"</span><span style="color:#5c7ab8;"><br></span><span style="color:#5c7ab8;">    </span><span style="color:#f92672;">this</span>.age <span style="color:#f92672;">= </span><span style="color:#ae81ff;">19</span><span style="color:#5c7ab8;"><br></span><span style="color:#5c7ab8;">    </span><span style="color:#f92672;">this</span>.<span style="color:#a6e22e;">show </span><span style="color:#f92672;">= function </span>() {<br>        console.<span style="color:#a6e22e;">log</span>(<span style="color:#f92672;">this</span>)<span style="color:#5c7ab8;"><br></span><span style="color:#5c7ab8;">    </span>}<span style="color:#5c7ab8;"><br></span>}<br><br><span style="color:#f92672;">var </span><span style="font-style:italic;">p </span><span style="color:#f92672;">= new </span><span style="color:#a6e22e;">Person</span>()<span style="color:#5c7ab8;"> </span><span style="color:#75715e;">// 若没有 new 关键字，则为一般的普通函数<br></span><span style="color:#75715e;"><br></span></pre><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">// 执行构造器函数时，会在该函数内部代码执行前新创建一个空对象，并用 this 指向该对象<br></span></pre><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">故 this 指向该对象，若将该对象（即 this）赋值给 变量 p，即创建了一个 p 实例对象，此时 this 指向 p </span></pre></div><h3 id="blogTitle55"><b>call 和 apply 调用模式</b></h3><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:13.5pt;"><span style="color:#75715e;">// call </span><span style="color:#75715e;font-family:'SimSun';">和 </span><span style="color:#75715e;">apply </span><span style="color:#75715e;font-family:'SimSun';">调用模式<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">add</span>(<span style="color:#fd971f;font-style:italic;">a</span><span style="color:#5c7ab8;">, </span><span style="color:#fd971f;font-style:italic;">b</span>) {<br>    <span style="color:#f92672;">this</span>.result <span style="color:#f92672;">= </span><span style="color:#fd971f;font-style:italic;">a </span><span style="color:#f92672;">+ </span><span style="color:#fd971f;font-style:italic;">b</span><span style="color:#5c7ab8;"><br></span>}<br><br><span style="color:#f92672;">var </span><span style="font-style:italic;">p </span><span style="color:#f92672;">= </span>{}<span style="color:#5c7ab8;">                  </span><span style="color:#75715e;">// </span><span style="color:#75715e;font-family:'SimSun';">定义一个空对象<br></span><span style="color:#a6e22e;">add</span>.<span style="color:#a6e22e;">call</span>(<span style="font-style:italic;">p</span><span style="color:#5c7ab8;">, </span><span style="color:#ae81ff;">3</span><span style="color:#5c7ab8;">, </span><span style="color:#ae81ff;">4</span>)     <span style="color:#5c7ab8;">    </span><span style="color:#75715e;">// </span><span style="color:#75715e;font-family:'SimSun';">在这个方法调用的时候，</span><span style="color:#75715e;">this </span><span style="color:#75715e;font-family:'SimSun';">指向了 </span><span style="color:#75715e;">p<br></span>console.<span style="color:#a6e22e;">log</span>(<span style="font-style:italic;">p</span>.result)<span style="color:#5c7ab8;"> </span><span style="color:#75715e;">// 7<br></span><span style="color:#75715e;">// apply </span><span style="color:#75715e;font-family:'SimSun';">和 </span><span style="color:#75715e;">call </span><span style="color:#75715e;font-family:'SimSun';">是一样的用法，只不过 </span><span style="color:#75715e;">apply </span><span style="color:#75715e;font-family:'SimSun';">第二个参数用数组进行传递</span></pre></div><div><h2 id="blogTitle56" style=""><span style="font-weight: 700;">对象的相互比较</span></h2><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">在 JavaScript 中 objects 是一种引用类型。两个独立声明的对象永远也不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回 true.</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; overflow-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">// Two variables, two distinct objects with the same properties
var fruit = {name: "apple"}
var fruitbear = {name: "apple"}

fruit == fruitbear // return false
fruit === fruitbear // return false</span></pre><div class="note" style="margin: 0px 0px 20px; padding: 10px 10px 10px 30px; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-left-style: solid; border-color: rgb(255, 226, 115); border-image: initial; overflow: hidden; clear: none; background: rgb(255, 245, 204); color: rgb(59, 60, 64); font-family: &quot;Open Sans&quot;, arial, sans-serif;"><p style="margin-bottom: 0px; padding: 0px; border: 0px;"><span style="margin: 0px; padding: 0px; border: 0px; font-weight: 700;">注意:</span>&nbsp;"===" 运算符用来检查数值和类型是否相等: <br>1 === "1" // return false <br>1 == "1"&nbsp; &nbsp;// return true</p></div><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; overflow-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">// Two variables, a single object
var fruit = {name: "apple"}
var fruitbear = fruit  // assign fruit object reference to fruitbear

// here fruit and fruitbear are pointing to same object
fruit == fruitbear     // return true
fruit === fruitbear    // return true</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">了解更多关于比较操作符的用法，查看&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" style="margin: 0px; padding: 0px; border: 0px;">Comparison operators</a>.</p></div></div><div><span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;">计算机在创建对象的时候，会为每一个对象随机划分一块内存区间，然后用一个变量去指向这块内存区间。因为每次创建对象时分配的内存空间是不一样的，所以 JS 中的对象比较永远为 false。</font></span></div><div><img src="data:image/png;base64,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"><br></div><div><h2 style="margin-top: 25px;" id="blogTitle57"><span style="font-weight: 700;">ES 面向对象编程</span></h2></div><h3 id="blogTitle58"><span style="font-weight: 700;">要点</span></h3><div><ul><li><b>ES 语言和其他语言不同的地方之一：</b></li><ul><li><b><font color="#ff0000" style="background-color: yellow;">ES&nbsp;的对象就是用函数实现的。</font></b></li><li><font color="#ff0000"><b style="background-color: yellow;">ES 的面向对象编程是基于原型（prototype）的，不是基于类的。</b></font></li></ul><li><b>万物皆对象</b><br></li><ul><li>在 JavaScript 中，大多数事物都是对象, 从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API。你甚至可以自己创建对象，将相关的函数和变量封装打包成便捷的数据容器。理解这种面向对象 (object-oriented, OO) 的特性对于进一步学习 JavaScript 语言知识是必不可少的。</li><li>明白你所使用过的一些功能实际上是由对象提供的。</li></ul></ul></div><div><h3 id="blogTitle59" style="margin-top: 25px;">搭积木编程</h3><div><div><span style="font-weight: 700;">面向对象编程&nbsp;</span>就是先把工具包开发出来，这些工具包中包含很多小工具。</div><div>然后我们使用一个一个工具将整体功能就像搭积木一样搭建出来，而不是一句一句的，一坨一坨的毫无组织，毫无纪律的编写代码。</div></div><div><h3 id="blogTitle60"><b>解耦合</b></h3><div style=""><ul style=""><li style="">分开的好处：假设将来我们换一个新的插件，我们只需要更改这一个函数，而其他部分都不用修改<br></li><li style="">修改代码：直接找到某个对象，然后定位到某个方法，这样代码维护起来非常方便，其实代码量比这个大 1000 倍也轻松维护<br></li><li style="">当你辞职了，你的后继者也很容易学习你的代码，寻找代码</li></ul></div></div><h3 id="blogTitle61">语法规范</h3><div><div>我们一般将属性放在上面，方法放在下面。这个是固定用法</div><div>上面的这个容器叫构造函数，又叫构造对象，专门放置属性</div><div>下面的这种写法叫原型对象，专门放置方法</div></div></div><h2 id="blogTitle62"><b>ES 面向对象开发</b></h2><h3 id="blogTitle63"><b>开发过程</b></h3><div><b>如何将现实世界的实体抽象成编程世界的对象</b><br></div><div><h4 style="font-weight: bold;" id="blogTitle64"><b>分析需要的对象</b></h4><div><div><div><ul><li>面向对象编程语法规范不重要，重要的是编程思维<br></li><li>给你任何一个物体，你能用对象思维分析出来<br></li><li>按需分析，而不是乱分析<br></li></ul></div></div></div><h4 style="font-weight: bold;" id="blogTitle65"><b>分析每个对象需要的属性和方法</b></h4><div><div><ul><li>面向对象编程重要的是如何提取属性和方法<br></li><li>提取的目的是封装细节和复杂性，方便别人使用</li></ul></div></div><h4 style="font-weight: bold;" id="blogTitle66"><b>依次实现每个对象</b></h4><h4 style="font-weight: bold;" id="blogTitle67"><b>面向对象编程（直接使用封装好的对象）</b></h4><div style="font-weight: bold;"><div style="font-weight: normal;"><span style="font-weight: 700;">如何使用我们定义好的对象</span><br></div><div style="font-weight: normal;"><div><ul><li>先实例后使用<br></li><li>访问成员（属性，方法）点语法</li></ul></div></div></div></div><h3 id="blogTitle68"><b>传统开发与面向对象开发的区别</b></h3><div><div><span style="background-color: yellow;"><div><span style="font-weight: 700;">学习 JS&nbsp;</span><span style="font-weight: 700;">其实</span><span style="font-weight: 700;">就是学习各种工具包，然后使用工具包开发。</span></div></span></div><h4 id="blogTitle69"><span style="font-weight: 700;">传统开发四要素</span></h4><div><div><ul><li>定义变量保存数据<br></li><li>获取元素<br></li><li>绑定元素<br></li><li>绑定事件</li></ul></div></div><h4 id="blogTitle70"><span style="font-weight: 700;">传统方式开发存在的缺点</span></h4><div>将代码都写在一起，一坨一坨的，如果代码量很庞大，每次修改都要先读懂整个代码。维护起来很麻烦。</div><h4 id="blogTitle71"><span style="font-weight: 700;">对象方式开发思路</span></h4><div><ul><li>先思考需要几个工具包<br></li><li>开发工具包（就是开发一个一个小函数）<br></li><li>使用工具包中的工具组织代码</li></ul><div><h4 id="blogTitle72">面向对象开发的优点</h4><div><div><ul><li>将代码分类管理<br></li><ul><li>将产品相关代码放在一起</li><li>将购物车相关代码放在一起</li><li>使用的时候只需要使用某个工具即可</li><li>将一坨代码用函数包装起来，看做一个整理</li></ul><li>代码清晰<br></li><li>容易维护<br></li><li>容易发现问题<br></li><li>代码可读性好<br></li><li>易于团队化作战 – 一个制造工具，一个使用工具</li></ul></div></div></div></div><h4 id="blogTitle73"><span style="font-weight: 700;">两种开发方式比较</span></h4><div><ul><li>传统方式：<br></li><ul><li>直接写细节</li><li>整个代码就是一坨坨的，不可分割</li></ul><li>对象方式：<br></li><ul><li>宏观思考，再写细节</li><li>对象方式主张先生产一个一个的零件，然后基于这些零件组装产品</li></ul></ul></div></div><div><br></div><h3 id="blogTitle74"><b>对象的三个作用</b></h3><div><div><b>封装</b></div><div><div><ul><li>把和某个主题有关的功能等放在一起，统一管理<br></li><li>比如浏览器分成 window 对象，document 对象<br></li><li>分别放置了和这个对象有关的一些操作<br></li><li>我们不用关心实现细节，直接使用</li></ul></div></div><div><b>描述数据</b></div><div><div><ul><li>使用构造 原型方式描述数据<br></li><li>使用 json 描述数据 – 更常用</li></ul></div></div><div><b>面向对象编程</b></div></div><div><div><ul><li>原型对象一般用于封装组件，封装一个功能点的属性和方法。<br></li><li>我们一般将我们需要开发的页面或者某个功能相关的代码都放在一个对象中统一管理<br></li><li>我们在开发网页的时候一般定义一个bindEvent 方法专门放置绑定事件的代码<br></li><li>我们在开发网页时候一般定义一个bindDOM 或者 bindData 专门负责将后台的数据和前端的 html 进行绑定<br></li><li>我们一般定义一个 init 方法，用于某模块初次加载的时候做的事情<br></li><li>比较常用，我们经常需要将后台传递的字符串转换成 json 对象，然后绑定到前端</li></ul></div></div><h3 id="blogTitle75"><b>JS 与其他面向对象</b><b>语言</b><b>的区别</b></h3><div>JavaScript 的面向对象编程和大多数其他语言如 Java、C# 的面向对象编程都不太一样。如果你熟悉 Java 或 C#，很好，你一定明白面向对象的两个基本概念：</div><div><ul><li><b>类</b>：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；</li><li><b>实例</b>：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。</li></ul></div><div>所以，<b>类和实例是大多数面向对象编程语言的基本概念。</b></div><div><br></div><div>不过，在 JavaScript 中，这个概念需要改一改。<b><font color="#ff0000">JavaScript 不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</font></b></div><p>JavaScript 的原型链和 Java 的 Class 区别就在，它没有 “Class” 的概念，所有对象都是实例，<span style="background-color: yellow;">所谓继承关系不过是把一个对象的原型指向另一个对象而已。</span></p><h2 id="blogTitle76"><span style="font-weight: 700;">ES 面向对象技术</span></h2><div><h4 style="margin-top: 25px;" id="blogTitle77">两个概念</h4><div><h5 id="blogTitle78">一切数据通过变量来管理</h5><div>数据通过变量来管理，不管是字符串，数字，还是复杂的对象，都是存放在变量中的</div><h5 id="blogTitle79"><span style="font-weight: 700;">定义变量的过程其实就是内存分配的过程</span></h5><div><span style="font-weight: 700;"><font color="#ff0000"><span style="line-height: 0; position: relative; vertical-align: baseline; top: -0.5em;">所以本质上一切数据都是存放在内存中的</span></font></span></div></div><div>当打开浏览器的时候，系统先把我们开发的代码放到内存中。然后解析成我们看到的绚丽的页面。</div></div><h3 id="blogTitle80"><span style="font-weight: 700;">ES 面向对象术语</span></h3><div>ECMAScript 并没有正式的类。相反，ECMA-262 把对象定义描述为对象的配方。这是 ECMAScript 逻辑上的一种折中方案，因为对象定义实际上是对象自身。即使类并不真正存在，我们也把对象定义叫做类，因为大多数开发者对此术语更熟悉，而且从功能上说，两者是等价的。</div><h4 id="blogTitle81">对象</h4><div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。</p></div><h4 id="blogTitle82"><b>实例</b></h4><h4 id="blogTitle83"><b>实例化</b></h4><div><div><div>理解变量是如何存储的</div><div>了解实例化的过程 -- 就是拷贝构造函数中的属性的过程</div></div></div><div><br></div><div>实例也是一个变量，也是存放在内存中的</div><div><br></div><div><span style="background-color: red;"><font color="#ffff00">当我们实例化对象时，其实就是将构造函数的所有属性（包括隐藏属性）拷贝一份并赋予新值或默认值，同时在内存中开辟两段区域，一段区域用来保存这些值，另一段区域用来保存实例名称。拷贝完成后构造函数与实例之间就没有任何关系了。</font></span></div><div><span style="background-color: red;"><font color="#ffff00"><br></font></span></div><div><font color="#ffff00"><span style="background-color: rgb(255, 0, 0);">定义构造函数的时候是不会分配内存的，只有在实例化后在会分配内存。</span></font></div><div><br></div><div><b>实例化的过程除了拷贝属性以外，还会自动生成一个 constructor 属性（</b><span style="font-weight: bold;">constructor 是构造函数的一个隐藏属性</span><b>），用于识别该实例是根据那个构造函数创建的</b></div><div><b><br></b></div><div><b>constructor 属性其实就是 Function 对象的一个属性。</b></div><div><b><br></b></div><div><b>对象其实就是 Function 的一个实例。</b></div><div><h4 id="blogTitle84"><b>双对象法则&nbsp;</b></h4><h5 id="blogTitle85">构造函数对象</h5><div>构造对象属性和方法<br></div><h5 id="blogTitle86">原型对象</h5><div>原型对象属性和方法</div></div><h4 id="blogTitle87"><b>数据绑定</b></h4><div><div>在开发中，数据一般是从后台开发人员从数据库读取出来，封装成一个 json 字符串返回给你，然后我们需要将前端写的假数据编程真数据，这个过程就是数据绑定。</div></div><div><h4 style="margin-top: 25px;" id="blogTitle88"><span style="font-weight: 700;">高级开发人员和接口</span></h4><div><ul><li>其实 init 就有点类似接口<br></li><li>当你写好代码之后，为了方便使用者，我们一般只需要告诉使用者简单的接口就可以了<br></li><li>对方不用了解其他任何信息</li><li>还可以防止其他人员访问核心代码，以后我们对这个代码加密，别人就只能使用而无法了解代码是如何编写的了<br></li></ul></div><h4 id="blogTitle89"><span style="font-weight: 700;">config 对象</span></h4><div><div>我们定义一个 config 对象来保存当前对象的临时变量，这样其他所有成员都可以访问</div><div><ul><li>统一管理<br></li><li>方便内存回收<br></li><li>解决代码重复性问题：一定要保证你写的代码不要有重复的<br></li><li>如何避免重复：利用函数来解决代码的复用性<br></li><li>重复性带来的危害：一旦需求变更，需要更改代码，那么所有重复的地方都需要更改</li></ul></div></div></div><h3 style="" id="blogTitle90"><span style="font-weight: 700;">面向对象语言的特性</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">一种面向对象语言需要向开发者提供四种基本能力：</p><ol style="margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding: 0px; border: 0px;"><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;"><b>封装</b> - 把相关的信息（无论数据或方法）存储在对象中的能力</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;"><b>聚集</b> - 把一个对象存储在另一个对象内的能力</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;"><b>继承</b> - 由另一个类（或多个类）得来类的属性和方法的能力</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;"><b>多态</b> - 编写能以多种方法运行的函数或方法的能力（多态是指两个或多个属于不同类的对象，对于同一个消息（方法调用）作出不同响应的方式）</li></ol><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">ECMAScript 支持这些要求，因此可被是看做面向对象的。</p><h3 id="blogTitle91"><span style="font-weight: 700;">ES 对象作用域</span></h3><div><p style=""><span style="margin: 0px; padding: 0px; border: 0px;"><span style="font-weight: 700;">作用域指的是变量的适用范围。</span></span></p><h4 style="" id="blogTitle92"><span style="font-weight: 700;">公用、私有和受保护作用域</span></h4><h5 style="" id="blogTitle93"><span style="font-weight: 700;">概念</span></h5><p style="">在传统的面向对象程序设计中，主要关注于公用和私有作用域。公用作用域中的对象属性可以从对象外部访问，即开发者创建对象的实例后，就可使用它的公用属性。而私有作用域中的属性只能在对象内部访问，即对于外部世界来说，这些属性并不存在。这意味着如果类定义了私有属性和方法，则它的子类也不能访问这些属性和方法。</p><h5 style="" id="blogTitle94"><span style="font-weight: 700;"><font color="#ff0000">ECMAScript 只有公用作用域</font></span></h5><p style="">对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！</p><h5 style="" id="blogTitle95"><span style="font-weight: 700;">建议性的解决方法</span></h5><p style="">许多开发者都在网上提出了有效的属性作用域模式，解决了 ECMAScript 的这种问题。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线：</p><pre>obj._color_ = "blue";</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这段代码中，属性 color 是私有的。注意，下划线并不改变属性是公用属性的事实，它只是告诉其他开发者，应该把该属性看作私有的。</p><p style="">有些开发者还喜欢用单下划线说明私有成员，例如：obj._color。</p><h4 id="blogTitle96">静态作用域</h4><p style="">静态作用域定义的属性和方法任何时候都能从同一位置访问。在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 java.net.URLEncoder 类，它的函数 encode() 就是静态方法。</p><h5 style="" id="blogTitle97">ECMAScript 没有静态作用域</h5><p style="">严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数。函数是对象，对象可以有属性和方法。例如：</p><pre>function sayHello() {
  alert("hello");
}

sayHello.alternate = function() {
  alert("hi");
}

sayHello();     <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "hello"</span>
sayHello.alternate();   <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "hi"</span></pre><p style="">这里，方法 alternate() 实际上是函数 sayHello 的方法。可以像调用常规函数一样调用 sayHello() 输出 "hello"，也可以调用 sayHello.alternate() 输出 "hi"。即使如此，alternate() 也是 sayHello() 公用作用域中的方法，而不是静态方法。</p></div><h2 id="blogTitle98"><span style="font-weight: 700;">ES 创建</span><b>对象</b></h2><p style="">使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="margin: 0px; padding: 0px; border: 0px;"><span style="font-weight: 700;">ECMAScript 拥有很多创建对象或类的方法。</span></span></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"></p><ul><li>对象字面量 -- 只能创建单个实例<br></li><li>Object &nbsp;--- 只能创建单个实例<br></li><li>内置对象<br></li><li>构造函数<br></li><li>原型对象<br></li><li>拷贝<br></li><li>工厂 --- 为设计模式做铺垫<br></li><ul><li>本质：</li><ul><li>其实就是封装性，隐藏细节</li><li>让我们可以拿来即用</li><li>就像现实的工厂一样，生产出手机，我们可以直接使用</li></ul><li>构造函数与工厂函数不同之处：</li><ul><li>没有显式的创建对象&nbsp;&nbsp;</li><li>不需要 new</li><li>没有return 语句</li></ul></ul><li>第三方框架<br></li></ul><p></p>JavaScript 拥有一系列预定义的对象。<div>另外，你可以创建你自己的对象。可以通过对象初始化器（Object Initializer）创建对象。或者可以创建一个构造函数并使用该函数和 new 操作符初始化对象。<br></div><div><br></div><div><div>JavaScript 对每个创建的对象都会设置一个原型，指向它的原型对象。</div><div><br></div><div>当我们用 obj.xxx 访问一个对象的属性时，JavaScript 引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到 Object.prototype 对象，最后，如果还没有找到，就只能返回 undefined。</div><div><br></div><div>例如，创建一个 Array 对象：</div><pre>var arr = [1, 2, 3];</pre><div>其原型链是：</div><pre>arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</pre><div>Array.prototype 定义了 indexOf()、shift() 等方法，因此你可以在所有的 Array 对象上直接调用这些方法。</div><div><br></div><div>当我们创建一个函数时：</div><pre>function foo() {<br>&nbsp; &nbsp; return 0;<br>}</pre><div>函数也是一个对象，它的原型链是：</div><pre>foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</pre><div>由于 Function.prototype 定义了 apply() 等方法，因此，所有函数都可以调用 apply() 方法。</div><div><br></div><div>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</div></div><h3 id="blogTitle99"><span style="font-weight: 700;">对象初始化器（字面量）- 等同于内置对象 Object</span></h3><div><span style="font-weight: bold;">使用对象初始化器也被称作通过字面值创建对象。对象初始化器与 C++ 术语相一致。</span><span style="font-weight: 700;"><br></span></div><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt;"><span style="color: rgb(117, 113, 94); font-family: &quot;Source Code Pro&quot;;">//</span><font color="#75715e" face="SimSun">推荐使用的场合： 作为函数的参数，临时只用一次的场景。比如设置函数原型对象。
</font><font color="#f8f8f2" face="Source Code Pro">// 缺点： 不能作为对象创建的模板，也就是不能用 new 进行构造新对象。</font></pre></div><div><br></div><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">通过对象初始化器创建对象的语法如下：</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var obj = { property_1:   value_1,   // property_# may be an identifier...
            2:            value_2,   // or a number...
            // ...,
            "property n": value_n }; // or a string</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">这里&nbsp;<span style="border-style: initial; border-color: initial;">obj</span>&nbsp;是新对象的名称，每一个&nbsp;<span style="border-style: initial; border-color: initial;">property_</span><span style="border-style: initial; border-color: initial; border-image: initial;">i</span>&nbsp;是一个标识符（可以是一个名称、数字或字符串字面量），并且每个&nbsp;<span style="border-style: initial; border-color: initial;">value_</span><span style="border-style: initial; border-color: initial; border-image: initial;">i</span>&nbsp;是一个其值将被赋予&nbsp;<span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">property_</span><span style="border-style: initial; border-color: initial; border-image: initial;">i</span>&nbsp;<span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">的表达式。</span><span style="border-style: initial; border-color: initial; line-height: 1.5;">obj</span><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;">&nbsp;与赋值是可选的；如果你不需要在其他地方引用对象，你就不需要将它赋给一个变量。（注意在接受一条语句的地方，你可能需要将对象字面量括在括号里，从而避免将字面量与块语句相混淆）</span></p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">如果一个对象是通过在顶级脚本的对象初始化器创建的，则 JavaScript 在每次遇到包含该对象字面量的表达式时都会创建对象。同样的，在函数中的初始化器在每次函数调用时也会被创建。</p><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">下面的语句只有当&nbsp;<span style="border-style: initial; border-color: initial;">cond</span>&nbsp;表达式的值为&nbsp;<span style="border-style: initial; border-color: initial;">true</span>&nbsp;时创建对象并将其赋给变量&nbsp;<span style="border-style: initial; border-color: initial;">x</span>。</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">if (cond) var x = {hi: "there"};</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">下例创建了有三个属性的&nbsp;<span style="border-style: initial; border-color: initial;">myHonda</span>&nbsp;对象。注意它的&nbsp;<span style="border-style: initial; border-color: initial;">engine</span>&nbsp;属性也是一个拥有自己属性的对象。</p><pre class="brush: js line-numbers  language-js" style=""><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">var myHonda = {color: "red", wheels: 4, engine: {cylinders: 4, size: 2.2}};</span></pre><h3 id="blogTitle100">Object.create 方法</h3><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt;"><span style="color: rgb(117, 113, 94); font-family: &quot;Source Code Pro&quot;;">// new Object() </span><font color="#75715e" face="SimSun">的方式 - 不推荐使用。
</font><font color="#f8f8f2" face="Source Code Pro">// 跟字面量一样，只能临时用一下这个对象，不想作为 new 的构造模板是可以的。</font></pre></div><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">对象也可以用&nbsp;<a title="Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象。" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" style="margin: 0px; padding: 0px; border: 0px;"><font face="consolas, Liberation Mono, courier, monospace"><span style="border-style: initial; border-color: initial; font-weight: inherit; font-style: inherit;">Object.create()</span></font></a>&nbsp;方法创建。该方法非常有用，因为它允许你为创建的对象选择其原型对象，而不用定义一个构造函数。</p><pre class="brush: js line-numbers  language-js" style="margin-top: 0px; margin-bottom: 20px; padding: 1em 1em 1em 3.8em; background-image: url(&quot;../../img/blueprint-dark.fd85a7a074ae.png&quot;); background-position: center top; line-height: 1.5; border-width: 0px 0px 0px 5px; border-top-style: initial; border-right-style: initial; border-bottom-style: initial; border-top-color: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: rgb(85, 138, 187); text-shadow: none; direction: ltr; word-break: normal; word-wrap: normal; hyphens: none; position: relative; counter-reset: linenumber 0;"><span style="border-style: initial; border-color: initial; border-image: initial; line-height: 1.5; tab-size: 4; position: relative;">// Animal properties and method encapsulation
var Animal = {
  type: "Invertebrates", // Default value of properties
  displayType : function() {  // Method which will display type of Animal
    console.log(this.type);
  }
}

// Create new animal type called animal1
var animal1 = Object.create(Animal);
animal1.displayType(); // Output:Invertebrates

// Create new animal type called Fishes
var fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Output:Fishes</span></pre><p style="margin-top: 0px; margin-bottom: 24px; padding: 0px; border: 0px;">该函数更多的信息及详细用法，参见&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/create" style="margin: 0px; padding: 0px; border: 0px;">Object.create method</a></p></div><h3 id="blogTitle101" style=""><span style="font-weight: 700;">工厂模式&nbsp;-- 解决问题的一种思路</span></h3><div><b>本质就是封装性 -- 隐藏细节 -- 可以模拟现实世界里的工厂</b></div><h4 style="" id="blogTitle102"><span style="font-weight: 700;">原始的方式 - Object</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">因为对象的属性可以在对象创建后动态定义，所有许多开发者都在 JavaScript 最初引入时编写类似下面的代码：</p><pre>var oCar = new Object;
oCar.color = "blue";
oCar.doors = 4;
oCar.mpg = 25;
oCar.showColor = function() {
  alert(this.color);
};</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在上面的代码中，创建对象 car。然后给它设置几个属性：它的颜色是蓝色，有四个门，每加仑油可以跑 25 英里。最后一个属性实际上是指向函数的指针，意味着该属性是个方法。执行这段代码后，就可以使用对象 car。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">不过这里有一个问题，就是可能需要创建多个 car 的实例。</p><h4 id="blogTitle103"><span style="font-weight: 700;">解决方案：工厂方式</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">要解决该问题，开发者创造了能创建并返回特定类型的对象的工厂函数（factory function）。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">例如，函数 createCar() 可用于封装前面列出的创建 car 对象的操作：</p><pre>function createCar() {
  var oTempCar = new Object;
  oTempCar.color = "blue";
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() {
    alert(this.color);
  };
  return oTempCar;
}

var oCar1 = createCar();
var oCar2 = createCar();</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在这里，第一个例子中的所有代码都包含在 createCar() 函数中。此外，还有一行额外的代码，返回 car 对象（oTempCar）作为函数值。调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p><h4 style="" id="blogTitle104"><span style="font-weight: 700;">为函数传递参数</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">我们还可以修改 createCar() 函数，给它传递各个属性的默认值，而不是简单地赋予属性默认值：</p><pre>function createCar(sColor,iDoors,iMpg) {
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = function() {
    alert(this.color);
  };
  return oTempCar;
}

var oCar1 = createCar("red",4,23);
var oCar2 = createCar("blue",3,25);

oCar1.showColor();      <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "red"</span>
oCar2.showColor();      <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "blue"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">给 createCar() 函数加上参数，即可为要创建的 car 对象的 color、doors 和 mpg 属性赋值。这使两个对象具有相同的属性，却有不同的属性值。</p><h4 id="blogTitle105"><span style="font-weight: 700;">在工厂函数外定义对象的方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p><pre><font color="#0000dd" face="Consolas, Courier New, Courier, monospace">function showColor() {
  alert(this.color);
}</font>

function createCar(sColor,iDoors,iMpg) {
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  <font color="#0000dd" face="Consolas, Courier New, Courier, monospace">oTempCar.showColor = showColor;</font>
  return oTempCar;
}

var oCar1 = createCar("red",4,23);
var oCar2 = createCar("blue",3,25);

oCar1.showColor();      <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "red"</span>
oCar2.showColor();      <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "blue"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在上面这段重写的代码中，在函数 createCar() 之前定义了函数 showColor()。在 createCar() 内部，赋予对象一个指向已经存在的 showColor() 函数的指针。从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">所有这些问题都引发了<span style="margin: 0px; padding: 0px; border: 0px;">开发者定义</span>的构造函数的出现。</p><div><span style="font-weight: 700;"><br></span></div><h3 id="blogTitle106" style=""><span style="font-weight: 700;">构造函数</span><b>创建对象</b></h3></div><div><div><pre style="background-color: rgb(39, 40, 34);"><font color="#75715e" face="SimSun"><span style="font-size: 14px;">// 优点： 通过构造函数创建的对象，形式上解决工厂模式中的函数不像对象的方法的问题</span></font></pre></div><div><pre style="background-color: rgb(39, 40, 34);"><font color="#75715e" face="SimSun"><span style="font-size: 14px;">// 缺点： 对象的内部的函数和属性会在每个实例中都存一份，如果创建的实例很多，会很浪费内存。</span></font></pre></div></div><div><h4 id="blogTitle107"><span style="font-weight: 700;">构造函数定义</span></h4><div>如果一个函数用于创建对象，我们一般称之为构造函数。<br></div><h4 id="blogTitle108"><span style="font-weight: 700;">构造函数和普通函数的区别</span></h4><div><div>对象本身就是一个函数。</div><div>构造函数与普通函数并无区别。</div><div>如果一个函数用于创建对象，我们一般称之为<span style="font-weight: 700;">构造函数</span>。</div></div><div>JavaScript 中的对象是由函数（this + new）实现的</div><h4 id="blogTitle109"><span style="font-weight: 700;">构造函数扩展</span></h4><pre><b>let a = {}          // 其实是 let a = new Object() 的语法糖&nbsp;<br></b><b>let a = []          // 其实是 let a = new Array() 的语法糖<br></b><b>function fn() {...} // 其实是 let fn = new Function() 语法糖</b></pre><h4 id="blogTitle110"><span style="font-weight: 700;">js 历史 -- 理解 js 对象为什么是函数</span></h4><div>诞生本无对象概念&nbsp;</div><div>JS 语言一开始被设计的时候并不支持面向对象，只是后来面向对象编程非常的火，所以 JS 后面也慢慢开始支持面向对象的写法，即 JS 利用函数来实现了面向对象。</div></div><h4 id="blogTitle111"><b>创建过程</b></h4><p style="margin-bottom: 24px; padding: 0px; border: 0px;">作为另一种方式，你可以通过两步来创建对象：</p><ol style="margin-top: 0px; margin-bottom: 24px; padding: 0px 0px 0px 40px; border: 0px; color: rgb(59, 60, 64); font-family: &quot;Open Sans&quot;, arial, sans-serif; background-color: rgb(255, 255, 255);"><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;">通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。</li><li style="margin: 0px 0px 6px; padding: 0px; border: 0px;">通过&nbsp;<code style="font-family: consolas, &quot;Liberation Mono&quot;, courier, monospace; padding-right: 0px; padding-left: 0px; border-width: 0px; border-style: initial; border-color: initial; word-wrap: break-word; margin: 0px; font-style: inherit; font-weight: inherit;">new 创建对象实例。</code></li></ol><p class="MsoNormal"><span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;"><span lang="EN-US">new</span><span lang="ZH-CN">运算符的作用是创建一个对象实例。这个对象可以是用户自定义的，也可以是带构造函数的一些系统自带的对象。</span><span lang="EN-US"><o:p></o:p></span></font></span></p><p class="MsoNormal"><span style="font-weight: 700;"><font color="#ff0000" style="background-color: yellow;"><span lang="EN-US">new&nbsp;</span><span lang="ZH-CN">关键字可以让构造函数中的</span><span lang="EN-US">&nbsp;this&nbsp;</span><span lang="ZH-CN">指向新的对象。</span></font></span></p><p class="MsoNormal"><span style="font-weight: 700;"><font style="background-color: yellow;"><font color="#000000"><span lang="ZH-CN">所谓</span><span lang="EN-US">"</span><span lang="ZH-CN">构造函数</span><span lang="EN-US">"</span></font><span lang="ZH-CN"><font color="#000000">，其实就是一个普通函数</font><font color="#ff0000">，但是内部使用了&nbsp;</font></span><span lang="EN-US" style="color: rgb(255, 0, 0);">this&nbsp;</span><span lang="ZH-CN" style="color: rgb(255, 0, 0);">变量。对构造函数使用&nbsp;</span><span lang="EN-US" style="color: rgb(255, 0, 0);">new&nbsp;</span><span lang="ZH-CN" style="color: rgb(255, 0, 0);">运算符，就能生成实例，并且&nbsp;</span><span lang="EN-US" style="color: rgb(255, 0, 0);">this&nbsp;</span><span lang="ZH-CN" style="color: rgb(255, 0, 0);">变量会绑定在实例对象上。</span></font></span></p><div><h4 id="blogTitle112"><span style="font-weight: 700;">构造函数面试题</span></h4><div><pre style="background-color: rgb(39, 40, 34); font-size: 12.8pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">var </span><span style="color: rgb(166, 226, 46);">fn1 </span><span style="color: rgb(249, 38, 114);">= function</span>(){<br>    <span style="color: rgb(249, 38, 114);">this</span>.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'peter'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span><span style="color: rgb(249, 38, 114);">return </span>{<br>        name<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'jack'<br></span><span style="color: rgb(230, 219, 116);">    </span>}<span style="color: rgb(92, 122, 184);">;<br></span>}<br><span style="color: rgb(249, 38, 114);">var </span><span style="font-style: italic;">p1 </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">fn1</span>()<span style="color: rgb(92, 122, 184);">;<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">p1</span>.name) <span style="color: rgb(11, 139, 21);">// jack</span></pre></div><div><br></div><div><pre style="background-color: rgb(39, 40, 34); font-size: 12.8pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">var </span><span style="color: rgb(166, 226, 46);">fn2 </span><span style="color: rgb(249, 38, 114);">= function</span>(){<br>    <span style="color: rgb(249, 38, 114);">this</span>.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'peter'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span><span style="color: rgb(249, 38, 114);">return </span><span style="color: rgb(230, 219, 116);">'jack'</span><span style="color: rgb(92, 122, 184);">;<br></span>}<br><span style="color: rgb(249, 38, 114);">var </span><span style="font-style: italic;">p2 </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">fn2</span>()<span style="color: rgb(92, 122, 184);">;<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">p2</span>.name) <span style="color: rgb(11, 139, 21);">// peter</span></pre></div><div><div><div>高级语言构造函数是没有 return 的</div><div>而 js 比较特殊，js 构造函数本身就是一个函数，所以拥有函数的一切的特性</div><div>如果 return 一个对象，则 new 的时候返回的是 return 的对象</div></div><div>如果 return 返回的不是一个对象或没有 return 语句，则构造函数默认返回 this 指向的对象</div></div></div><div><h3 id="blogTitle113" style=""><span style="font-weight: 700;">原型方式</span><b>创建对象</b></h3><div><div><div>理解原型对象中的属性和方法被所有实例共享<br></div><div><br></div><div>既然我们可以使用构造函数就可以定义属性和方法，为什么还要原型呢？？ -- 提高性能和减少内存空间。</div><h4 id="blogTitle114"><span style="font-weight: 700;">构造函数创建对象存在的问题</span></h4><div><span style="font-weight: 700;">只用构造函数创建对象存在的缺点<br></span></div><div><ul><li>每次实例化都需要分配内存存储这些数据，如果实例很多，那就要分配很多内存存储<br></li><li>一般每个实例的属性是不一样的，而行为一般都是一样的，所以我们希望每次实例化的时候，只分配内存保存不一样的数据<br></li><li>而像方法，可以只分配一次空间，所有的实例共享这些方法，那就需要原型对象</li></ul></div><h4 id="blogTitle115"><b>优点</b></h4><div>原型对象不管实例化多少次，都只分配一次内存</div><h4 id="blogTitle116"><b>原理</b></h4><div><span style="font-weight: 700;">实例化 的时候只拷贝构造函数中的属性，而不会拷贝原型对象中的属性，那为什么我们能使用原型对象的定义的属性呢？</span></div><div>-- 是因为构造函数中有一个隐藏属性 __proto__，专门用来指向原型对象所在的地址，虽然对象在实例化时没有直接拷贝原型对象的属性，但间接拷贝的原型对象的指向 - 即 __proto__ 属性。</div><div><br></div><div><div>原型对象的属性和方法可以被所有实例共享</div><div>这样，如果我们需要修改所有实例中的属性或者方法，就只需要修改一处，就能够影响到所有实例了</div></div><div><br></div><div><div><span style="font-weight: 700;">原型对象 prototype 实际上是 对象 Object 上的一个属性，该属性指向一个对象：</span></div><pre><span style="font-weight: 700;">console.log(Object.prototype)<br></span>// {__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}constructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()}</pre><div><span style="font-weight: 700;"><div>Function 对象是 Object 的实例：</div><pre>console.log(Function instanceof Object) //true</pre><div>我们定义的构造函数是 Function 对象的实例：</div><pre>console.log(构造函数名 instanceof Function) //true</pre></span></div><div><span style="font-weight: 700;">通过实例化得到的对象是构造函数的实例：</span></div><pre><span style="font-weight: 700;">console.log(实例名 instanceof 构造函数名) //true</span></pre><div><span style="font-weight: 700; background-color: red;"><font color="#ffff00">实例对象的 __proto__ 属性与构造函数的 prototype 属性全等</font></span></div><div><font color="#ffff00"><span style="background-color: rgb(255, 0, 0);"><span style="font-weight: 700;">这就是实例化对象时 new 关键字的其中一个作用：让实例对象中的 __proto__ 属性指向 构造函数对象中的 prototype 属性，该属性的值为一个对象</span></span></font></div><pre><span style="font-weight: 700;">console.log(实例名.__proto__ === 构造函数名.prototype) //true</span></pre><div><span style="font-weight: 700; color: rgb(255, 255, 0); background-color: red;">当我们定义完一个函数后，该函数就自动拥有了一个 prototype 属性，该属性的值为一个对象，对象里面一开始只有一些预定义的隐藏属性。</span><span style="font-weight: 700;"><br></span></div><div><font color="#ffff00"><span style="background-color: rgb(255, 0, 0);"><span style="font-weight: 700;"><br></span></span></font></div><div><font color="#ffff00"><span style="background-color: rgb(255, 0, 0);"><span style="font-weight: 700;">这就是为什么我们可以直接在 构造函数名.prototype 上定义属性、方法或重新赋值一个对象的原因。</span></span></font></div><pre><span style="font-weight: 700;">function CC() {}<br></span><span style="font-weight: 700;">console.log(CC.prototype)<br></span><span style="font-weight: 700;">//{constructor: ƒ () __proto__: Object}

//定义属性
CC.prototype.name = ''
//定义方法
CC.prototype.run = function () {}
//重新赋值一个对象
CC.prototype = {}</span></pre><div><span style="font-weight: 700;"><br></span></div><div><span style="font-weight: 700;">故基于原型对象创建构造函数对象实例的机制就是：</span></div><div><span style="font-weight: 700;">当我们定义了一个函数（不管是不是构造函数），该函数就会自动拥有一个 prototype 属性（内部机制），指向一个对象，所以我们可以在该 prototype 属性上定义属性、方法或者重新赋值一个对象；当用 new 关键字创建一个对象实例的时候，会自动将该实例对象中的 __proto__ 属性与构造函数对象中的 prototype 相关联（即 实例名.__proto__ === 构造函数名.prototype），这样实例就会通过属性访问机制来查找到实例自身没有但原型对象上定义了的属性。</span></div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">原型对象创建实例利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。</p></div><h4 id="blogTitle117"><span style="font-weight: 700;">经验</span></h4><div><div>一般将大家都公有的东西放在原型对象中</div><div>每个实例独特的不一样的属性放在构造函数中</div></div></div><h4 id="blogTitle118"><span style="font-weight: 700;">面试题</span></h4><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);">let <span style="color: rgb(166, 226, 46);">fun </span><span style="color: rgb(249, 38, 114);">= function</span>(){}<br><span style="color: rgb(166, 226, 46);">fun</span>.prototype <span style="color: rgb(249, 38, 114);">= </span>{<br>    name<span style="color: rgb(249, 38, 114);">:</span><span style="color: rgb(230, 219, 116);">'1'</span><span style="color: rgb(92, 122, 184);">, </span><span style="color: rgb(11, 139, 21);">//</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">值类型<br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;">    </span>info <span style="color: rgb(249, 38, 114);">: </span>{  <span style="color: rgb(11, 139, 21);">//</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">引用类型<br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;">        </span>name <span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'peter'</span><span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">        </span>age <span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(174, 129, 255);">25<br></span><span style="color: rgb(174, 129, 255);">    </span>}<br>}<br><br>let <span style="font-style: italic;">a </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">fun</span>()<span style="color: rgb(92, 122, 184);">;<br></span>let <span style="font-style: italic;">b </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">fun</span>()<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">a</span>.info.name) <span style="color: rgb(11, 139, 21);">//peter<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">b</span>.info.name) <span style="color: rgb(11, 139, 21);">//peter<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">a</span>.name) <span style="color: rgb(11, 139, 21);">//1<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">b</span>.name) <span style="color: rgb(11, 139, 21);">//1<br></span><span style="color: rgb(11, 139, 21);"><br></span><span style="font-style: italic;">a</span>.info.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'jack'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="font-style: italic;">b</span>.info.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'tom'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="font-style: italic;">a</span>.name<span style="color: rgb(249, 38, 114);">=</span><span style="color: rgb(230, 219, 116);">'foo'<br></span><span style="font-style: italic;">b</span>.name<span style="color: rgb(249, 38, 114);">=</span><span style="color: rgb(230, 219, 116);">'bar'<br></span><span style="color: rgb(230, 219, 116);"><br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">a</span>.info.name) <span style="color: rgb(11, 139, 21);">//tom<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">b</span>.info.name) <span style="color: rgb(11, 139, 21);">//tom<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">a</span>.name) <span style="color: rgb(11, 139, 21);">//foo<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">b</span>.name) <span style="color: rgb(11, 139, 21);">//bar</span></pre></div><div><div><span style="font-weight: 700;">知识点考察：</span></div><div>原型属性为所有实例共享</div><div>当原型对象属性为值类型时，不同实例继承原型对象上的属性时会分配独立的内存空间</div><div>当原型对象属性为引用类型时，他们修改的都是同一片内存空间</div></div></div><div><span style="font-weight: 700;"><br></span></div><div><b>原型对象的属性和方法可以被所有的实例共享，不管是值类型属性还是引用类型属性，只要不被实例的属性覆写。</b></div></div><h3 id="blogTitle119"><b>混合模式 - 构造函数 + 原型对象</b></h3><h4 style="" id="blogTitle120"><span style="font-weight: 700;">原型方式的问题</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p><ul><li>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值<br></li><li>很多值类型的数据不应该被共享，每个实例应该有自己的特性<br></li></ul><p></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><b>请思考下面的例子：</b></p><pre>function Car() {}

Car.prototype.color = "blue";
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
<font color="#0000dd" face="Consolas, Courier New, Courier, monospace">Car.prototype.drivers = new Array("Mike","John");</font>
<font color="#ff0000">Car.prototype.showColor = function() {
  alert(this.color);
};</font>

var oCar1 = new Car();
var oCar2 = new Car();

<font color="#0000dd" face="Consolas, Courier New, Courier, monospace">oCar1.drivers.push("Bill");</font>

<font color="#ff0000">oCar1.showColor = function() {
  alert(this.doors)
}</font>

alert(oCar1.drivers);   <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "Mike,John,Bill"</span>
alert(oCar2.drivers);   <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "Mike,John,Bill"

alert(oCar1.showColor()) //4
alert(oCar2.showColor()) //blue</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 "Mike" 和 "John"。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 "Bill"，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 "Mike,John,Bill"。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="font-weight: 700;">这里原型上的函数也是引用类型</span>。但在实例上复写原型对象对应的属性，不会影响到其他实例，即不会影响到原型。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="background-color: red;"><span style="font-weight: 700;">注意这里是复写（或者说屏蔽更确切）原型对象属性，并不是重写，并未对原型对象做任何操作，所谓的复写只是针对实例，给实例动态添加一个属性，根据属性搜索机制会覆盖掉原型上相同的属性。</span></span></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="font-weight: 700;">？？？？如何解释呢？？让我们一起来分析一下关键的代码：</span></p><pre><font color="#0000dd" face="Consolas, Courier New, Courier, monospace">oCar1.drivers.push("Bill");</font></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">首先这行代码是针对 oCar1.drivers 指向的数据进行操作，并不是创建一个属性； drivers 属性是原型上的，实例 oCar1 上并没有定义，根据属性搜索机制，oCar1.drivers 得到的是 原型上的 drivers 属性，对应的值是一个 new 出来的数组对象实例，即保存的数据类型是引用类型，.push() 方法是数组原型对象上的方法，这里是对原型属性&nbsp;drivers 指向的数组实例进行操作，并未更改 原型属性 drivers 和这个数组实例之间的指向关系。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">而</p><pre><font color="#ff0000">oCar1.showColor = function() {
  alert(this.doors)
}</font></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里是动态为 实例 oCar1 增加了一个 showColor 属性，和原型并没有什么关系。</p><pre><span style="margin: 0px; padding: 0px; border: 0px;">alert(oCar1.showColor()) //4</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里调用的是 实例 oCar1 上动态定义的方法</p><pre><span style="margin: 0px; padding: 0px; border: 0px;">alert(oCar2.showColor()) //blue</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里调用的是 实例 原型对象上的定义的方法</p><h4 style="" id="blogTitle121"><b>混合模式创建对象的过程</b></h4><div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">我们重写了前面的例子，代码如下：</p><pre>function Car(sColor,iDoors,iMpg) {
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array("Mike","John");
}

Car.prototype.showColor = function() {
  alert(this.color);
};

var oCar1 = new Car("red",4,23);
var oCar2 = new Car("blue",3,25);

oCar1.drivers.push("Bill");

alert(oCar1.drivers);   <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "Mike,John,Bill"</span>
alert(oCar2.drivers);   <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "Mike,John"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 "Bill" 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 "Mike,John,Bill"，而 oCar2.drivers 显示的是 "Mike,John"。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p></div><h4 id="blogTitle122"><span style="font-weight: 700;">升级版1</span></h4><div><pre style="background-color: rgb(39, 40, 34); font-size: 13.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">升级版</span><span style="color: rgb(117, 113, 94);"> 1<br></span><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">把 共用的 函数和属性 放到构造函数的原型对象里面</span><span style="color: rgb(117, 113, 94);">,</span><span style="color: rgb(117, 113, 94); font-family: SimSun;">可以节省内存
</span>// 函数的行为是所有对象可以共有，不需要每个对象都保存一份。<br></pre><pre style="background-color: rgb(39, 40, 34); font-size: 13.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">function </span><span style="color: rgb(166, 226, 46);">Cat</span>() {<br>    <span style="color: rgb(249, 38, 114);">this</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">18</span><span style="color: rgb(92, 122, 184);">;<br></span>}<br><br><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.species <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'animal'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.<span style="color: rgb(166, 226, 46);">show </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="color: rgb(249, 38, 114);">this</span>.age)<span style="color: rgb(92, 122, 184);">;<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>()<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat1 </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>()<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="font-style: italic;">cat</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">20</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="font-style: italic;">cat1</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">23</span><span style="color: rgb(92, 122, 184);">;<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">cat</span>.species)<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// animal<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">cat1</span>.species)<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// animal<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">cat</span>.species<span style="color: rgb(249, 38, 114);">===</span><span style="font-style: italic;">cat1</span>.species)<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// true<br></span><span style="color: rgb(117, 113, 94);"><br></span><span style="font-style: italic;">cat</span>.<span style="color: rgb(166, 226, 46);">show</span>()<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// 20<br></span><span style="font-style: italic;">cat1</span>.<span style="color: rgb(166, 226, 46);">show</span>()<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// 23<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">cat</span>.<span style="color: rgb(166, 226, 46);">show</span><span style="color: rgb(249, 38, 114);">===</span><span style="font-style: italic;">cat1</span>.<span style="color: rgb(166, 226, 46);">show</span>)<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// true</span></pre></div><h4 id="blogTitle123"><span style="font-weight: 700;">升级版2</span></h4><div><pre style="background-color: rgb(39, 40, 34);"><span style="color: rgb(117, 113, 94); font-family: &quot;Source Code Pro&quot;; font-size: 13.5pt;">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun; font-size: 13.5pt;">升级版</span><span style="color: rgb(117, 113, 94); font-family: &quot;Source Code Pro&quot;; font-size: 13.5pt;">2<br></span><span style="color: rgb(117, 113, 94); font-family: &quot;Source Code Pro&quot;; font-size: 13.5pt;">// </span><font color="#75715e" face="SimSun"><span style="font-size: 18px;">把属性的设置参数化</span></font></pre><pre style="background-color: rgb(39, 40, 34);"><font color="#75715e" face="SimSun"><span style="font-size: 18px;">//问题： 1、调用者如果传递参数的顺序发生变化，那么废了
//问题： 2、参数增减都会导致函数声明变化，调用的地方也可能发生变化。<br></span></font></pre><pre style="background-color: rgb(39, 40, 34); font-size: 13.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">function </span><span style="color: rgb(166, 226, 46);">Cat</span>(<span style="color: rgb(253, 151, 31); font-style: italic;">age</span><span style="color: rgb(92, 122, 184);">, </span><span style="color: rgb(253, 151, 31); font-style: italic;">color</span>) {<br>    <span style="color: rgb(249, 38, 114);">this</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">age</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span><span style="color: rgb(249, 38, 114);">this</span>.color <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">color</span><span style="color: rgb(92, 122, 184);">;<br></span>}<br><br><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.species <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'animal'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.<span style="color: rgb(166, 226, 46);">show </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="color: rgb(249, 38, 114);">this</span>.age)<span style="color: rgb(92, 122, 184);">;<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>(<span style="color: rgb(174, 129, 255);">16</span><span style="color: rgb(92, 122, 184);">,</span><span style="color: rgb(230, 219, 116);">'black'</span>)<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat1 </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>(<span style="color: rgb(174, 129, 255);">17</span><span style="color: rgb(92, 122, 184);">,</span><span style="color: rgb(230, 219, 116);">'white'</span>)<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="font-style: italic;">cat</span>.<span style="color: rgb(166, 226, 46);">show</span>()<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// 16<br></span><span style="font-style: italic;">cat1</span>.<span style="color: rgb(166, 226, 46);">show</span>()<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(117, 113, 94);">// 17</span></pre></div><h4 id="blogTitle124"><span style="font-weight: 700;">升级版3</span></h4><div><pre style="background-color: rgb(39, 40, 34); font-size: 14.3pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">升级版</span><span style="color: rgb(117, 113, 94);">3<br></span><span style="color: rgb(117, 113, 94);">// 将</span><span style="color: rgb(117, 113, 94); font-family: SimSun;">参数改造为对象，参数可以以任意顺序传递</span></pre><pre style="background-color: rgb(39, 40, 34); font-size: 14.3pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">function </span><span style="color: rgb(166, 226, 46);">Cat</span>(<span style="color: rgb(253, 151, 31); font-style: italic;">option</span>) {<br>    <span style="color: rgb(249, 38, 114);">this</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">option</span>.age<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span><span style="color: rgb(249, 38, 114);">this</span>.color <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">option</span>.color<span style="color: rgb(92, 122, 184);">;<br></span>}<br><br><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.species <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'animal'</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(166, 226, 46);">Cat</span>.prototype.<span style="color: rgb(166, 226, 46);">show </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="color: rgb(249, 38, 114);">this</span>.age)<span style="color: rgb(92, 122, 184);">;<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>({<br>    color<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'black'</span><span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">    </span>age<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(174, 129, 255);">18<br></span>})<span style="color: rgb(92, 122, 184);">;</span></pre></div><h4 id="blogTitle125"><span style="font-weight: 700;">升级版4</span></h4><div><pre style="background-color: rgb(39, 40, 34); font-size: 14.3pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">升级版</span><span style="color: rgb(117, 113, 94);">4<br></span><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">将构造函数原型上的方法和属性集中写在原型对象上<br></span><span style="color: rgb(117, 113, 94);">// </span><span style="color: rgb(117, 113, 94); font-family: SimSun;">将构造函数里的属性以函数的形式封装到原型对象上</span></pre><pre style="background-color: rgb(39, 40, 34); font-size: 14.3pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);"><span style="color: rgb(249, 38, 114);">function </span><span style="color: rgb(166, 226, 46);">Cat</span>(<span style="color: rgb(253, 151, 31); font-style: italic;">option</span>) {<br>    <span style="color: rgb(249, 38, 114);">this</span>.<span style="color: rgb(166, 226, 46);">_init</span>(<span style="color: rgb(253, 151, 31); font-style: italic;">option</span>)<span style="color: rgb(92, 122, 184);">;<br></span>}<br><br><span style="color: rgb(166, 226, 46);">Cat</span>.prototype <span style="color: rgb(249, 38, 114);">= </span>{<br>    <span style="color: rgb(166, 226, 46);">_init</span><span style="color: rgb(249, 38, 114);">: function </span>(<span style="color: rgb(253, 151, 31); font-style: italic;">option</span>) {<br>        <span style="color: rgb(249, 38, 114);">this</span>.age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">option</span>.age <span style="color: rgb(249, 38, 114);">|| </span><span style="color: rgb(230, 219, 116);">''</span><span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">        </span><span style="color: rgb(249, 38, 114);">this</span>.color <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(253, 151, 31); font-style: italic;">option</span>.color<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span>}<span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">    </span>species<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'animal'</span><span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">    </span><span style="color: rgb(166, 226, 46);">show</span><span style="color: rgb(249, 38, 114);">: function </span>() {<br>        console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="color: rgb(249, 38, 114);">this</span>.age)<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);">    </span>}<br>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(249, 38, 114);">let </span><span style="font-style: italic;">cat </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Cat</span>({<br>    age<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(174, 129, 255);">18</span><span style="color: rgb(92, 122, 184);">,<br></span><span style="color: rgb(92, 122, 184);">    </span>color<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'black'<br></span>})<span style="color: rgb(92, 122, 184);">;</span></pre></div><h3 id="blogTitle126"><b>例</b></h3><div>先定义一个构造函数：</div><pre>function Student(name) {<br>&nbsp; &nbsp; this.name = name;<br>&nbsp; &nbsp; this.hello = function () {<br>&nbsp; &nbsp; &nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>&nbsp; &nbsp; }<br>}</pre><div>用关键字new来调用这个函数，并返回一个对象：<br></div><pre>var xiaoming = new Student('小明');<br>xiaoming.name; // '小明'<br>xiaoming.hello(); // Hello, 小明!</pre><div style="text-align: left;"><span style="font-weight: 700;"><font color="#000000" style="background-color: yellow;">注意，如果不写 new，这就是一个普通函数，它返回 undefined。但是，如果写了 new，它就变成了一个构造函数，它绑定的 this 指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</font></span></div><div><br></div><div>新创建的xiaoming的原型链是：</div><pre>xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</pre><div>也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：</div><pre>xiaoming ↘<br>xiaohong → Student.prototype ----&gt; Object.prototype ----&gt; null<br>xiaojun &nbsp;↗</pre><div>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：</div><pre>xiaoming.constructor === Student.prototype.constructor; // true<br>Student.prototype.constructor === Student; // true<br>Object.getPrototypeOf(xiaoming) === Student.prototype; // true<br>xiaoming instanceof Student; // true</pre><div>看晕了吧？用一张图来表示这些乱七八糟的关系就是：</div><div><br></div><div><img src="data:image/png;base64,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xl3snd32JUEkccsdvAi1wa1ana7NG59KCAEhIASEgBAQAv0QuCzJo8cNMXj2sadlcyQv1kbIu9dPhf1blievP8bqQQgIASEgBIRAawSiJA+nTD/5zDP30pC07rxXe7FbLkJ/x99++av370RBTj2f287X2dJGr3GOapdb2MgFeJbcf6OwUz9CQAgIASEgBI5CIEnyIJTPAXeUoOr3OASwLY1HJO84HahnISAEhIAQEAK1CARJHhrRwl4L5TnLw3MJr64I/zn1q1EJASEgBITAeRGIkjzFYZ1X6TUj4/2+f/rZP1ly675mrCorBISAEBACQuBMCERJnhb3M6l5+1hE9rdjp5pCQAgIASEgBI5EIErytGV7pFrm6FtbtXPoQVIIASEgBISAENiCQJLk0Yujrbot0K5fR/pfX4cagRAQAkJACFwXgSTJkzfvuobB7fpPPP2UTlhf1ww0ciEgBISAEFgYgSzJs4u9UmgsrOkK0e02rXReAZyKCgEhIASEgBCYCIEsyYOs3LaDV0eL/kTa6yAKCd6vP/r4pm36DgCrSSEgBISAEBACgxAoInkieoO0cXA3IngHK0DdCwEhIASEgBBoiEAxybNED/+Glyd0DVhD2dTUIAR4tds77753g7d21evsBsGlboSAEBACQkAILIFAFcnDiKy3h4QAZA+P7jVdQud3QkKPeHBv74cPH96wPavt+HX0J0mFgBAQAkJACOQQqCZ5bJCX1oMc4AFBwAMvkJ65EQCpw2N1p1jLuXUm6YSAEBACQkAI1CKwmeSxI271kThY8lArjMr3R4BknIRcW+79MVcPQkAICAEhIASOQGA3ybNCcwvwiIGoz3IEtK1ejpVKCgEhIASEgBBYFYGmJG9VECS3EBACQkAICAEhIATOhoBI3tk0qvEIASEgBISAEBACQuB2u4nkyQyEgBAQAkJACAgBIXBCBETyTqhUDUkICAEhIASEgBAQAiJ5sgEhIASEgBAQAkJACJwQAZG8EypVQxICQkAICAEhIASEgEiebEAICAEhIASEgBAQAidEQCTvhErVkISAEBACQkAICAEh8P8ByXXub7iR4nIAAAAASUVORK5CYII="><br></div><div><br></div><div>红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。</div><div><br></div><div>另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用__proto__这个非标准用法来查看。</div><div><br></div><div>现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。</div><div><br></div><div>不过还有一个小问题，注意观察：</div><pre>xiaoming.name; // '小明'<br>xiaohong.name; // '小红'<br>xiaoming.hello; // function: Student.hello()<br>xiaohong.hello; // function: Student.hello()<br>xiaoming.hello === xiaohong.hello; // false</pre><div>xiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。</div><div><br></div><div>xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</div><div><br></div><div>如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。</div><div><br></div><div>要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype：</div><div><img src="data:image/png;base64,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"><br></div><div><br></div><div>修改代码如下：</div><pre>function Student(name) {<br>&nbsp; &nbsp; this.name = name;<br>}<br>Student.prototype.hello = function () {<br>&nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>};</pre><div>用new创建基于原型的JavaScript的对象就是这么简单！</div><div><br></div><div>忘记写new怎么办</div><div><br></div><div>如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写new怎么办？</div><div><br></div><div>在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。</div><div><br></div><div>所以，调用构造函数千万不要忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。</div><div><br></div><div>最后，我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样：</div><pre>function Student(props) {<br>&nbsp; &nbsp; this.name = props.name || '匿名'; // 默认值为'匿名'<br>&nbsp; &nbsp; this.grade = props.grade || 1; // 默认值为1<br>}<br>Student.prototype.hello = function () {<br>&nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>};<br>function createStudent(props) {<br>&nbsp; &nbsp; return new Student(props || {})<br>}</pre><div>这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传：</div><pre>var xiaom<font color="#000000">ing = createStudent({<br>&nbsp; &nbsp; name: '小明'<br>});<br>xiaoming.gra</font>de; // 1</pre><div>如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。</div><div><br></div><div>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。<br></div><div><br></div><div><h3 id="blogTitle127" style="margin-bottom: 0px; padding: 0px; border: 0px;"><span style="font-weight: 700;">动态原型方法</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装。请考虑下面的 Java 类：</p><pre>class Car {
  public String color = "blue";
  public int doors = 4;
  public int mpg = 25;

  public Car(String color, int doors, int mpg) {
    this.color = color;
    this.doors = doors;
    this.mpg = mpg;
  }

  public void showColor() {
    System.out.println(color);
  }
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">Java 很好地打包了 Car 类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数/原型方式的人认为，在构造函数内部找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p><pre>function Car(sColor,iDoors,iMpg) {
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array("Mike","John");

  if (<font color="#0000dd" face="Consolas, Courier New, Courier, monospace">typeof Car._initialized == "undefined"</font>) {
    Car.prototype.showColor = function() {
      alert(this.color);
    };

    <font color="#0000dd" face="Consolas, Courier New, Courier, monospace">Car._initialized = true;</font>
  }
}</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">直到检查 typeof Car._initialized 是否等于 "undefined" 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p><h3 style="" id="blogTitle128"><b>拷贝方式创建对象</b></h3></div><h4 id="blogTitle129"><b>单个对象的拷贝</b></h4><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:10.5pt;"><span style="color:#0b8b15;">//-------------------------</span><span style="color:#0b8b15;font-family:'SimSun';">拷贝创建对象核心代码</span><span style="color:#0b8b15;">--------------------------<br></span><span style="color:#0b8b15;"><br></span><span style="color:#097d24;">/*</span><span style="color:#097d24;font-family:'SimSun';">封装框架的六大神器之一</span><span style="color:#097d24;"> - </span><span style="color:#097d24;font-family:'SimSun';">对象拷贝</span><span style="color:#097d24;">*/<br></span><span style="color:#097d24;"><br></span><span style="color:#097d24;">/*</span><span style="color:#097d24;font-family:'SimSun';">函数的用处：就是将一个</span><span style="color:#097d24;"> json </span><span style="color:#097d24;font-family:'SimSun';">对象的所有属性拷贝给另外一个对象</span><span style="color:#097d24;">*/<br></span><span style="color:#097d24;">/*source</span><span style="color:#097d24;font-family:'SimSun';">：原始对象</span><span style="color:#097d24;">*/<br></span><span style="color:#097d24;">/*target</span><span style="color:#097d24;font-family:'SimSun';">：目标对象</span><span style="color:#097d24;">*/<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">extend</span>(<span style="color:#fd971f;font-style:italic;">target</span><span style="color:#5c7ab8;">, </span><span style="color:#fd971f;font-style:italic;">source</span>) {<br>    <span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">遍历对象<br></span><span style="color:#0b8b15;font-family:'SimSun';">    </span><span style="color:#f92672;">for </span>(let i <span style="color:#f92672;">in </span><span style="color:#fd971f;font-style:italic;">source</span>) {<br>        <span style="color:#fd971f;font-style:italic;">target</span>[i] <span style="color:#f92672;">= </span><span style="color:#fd971f;font-style:italic;">source</span>[i]<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">    </span>}<br>    <span style="color:#f92672;">return </span><span style="color:#fd971f;font-style:italic;">target</span><span style="color:#5c7ab8;">;<br></span>}<br><br><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">游戏随机生成名字<br></span>let <span style="font-style:italic;">boy </span><span style="color:#f92672;">= </span>{<br>    name<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">郭靖</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>image<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">男性头像</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>age<span style="color:#f92672;">: </span><span style="color:#ae81ff;">20<br></span><span style="color:#ae81ff;">    </span><span style="color:#5c7ab8;">, </span>sex<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">男</span><span style="color:#e6db74;">'<br></span>}<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span>let <span style="font-style:italic;">girl </span><span style="color:#f92672;">= </span>{<br>    name<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">黄蓉</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>age<span style="color:#f92672;">: </span><span style="color:#ae81ff;">18<br></span><span style="color:#ae81ff;">    </span><span style="color:#5c7ab8;">, </span>image<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">女性头像</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>sex<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">女</span><span style="color:#e6db74;">'<br></span>}<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span>let <span style="font-style:italic;">guojing </span><span style="color:#f92672;">= </span><span style="color:#a6e22e;">extend</span>({}<span style="color:#5c7ab8;">, </span><span style="font-style:italic;">boy</span>)<span style="color:#5c7ab8;">;<br></span>let <span style="font-style:italic;">huangrong </span><span style="color:#f92672;">= </span><span style="color:#a6e22e;">extend</span>({}<span style="color:#5c7ab8;">, </span><span style="font-style:italic;">girl</span>)<br><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">guojing</span>.name)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">guojing</span>.sex)<span style="color:#5c7ab8;">;<br></span><span style="font-style:italic;">console</span>.<span style="color:#a6e22e;">log</span>(<span style="font-style:italic;">huangrong</span>.name)</pre></div><h4 id="blogTitle130"><b>多个对象的拷贝</b></h4><div><b>使用 arguments 对象的时候函数定义时可以不使用参数</b></div><div><pre style="background-color:#272822;color:#f8f8f2;font-family:'Source Code Pro';font-size:10.5pt;"><span style="color:#0b8b15;">//extend </span><span style="color:#0b8b15;font-family:'SimSun';">实现的功能：</span><span style="color:#0b8b15;">extend(target, obj1, obj2, obj3, ...)<br></span><span style="color:#097d24;">/*</span><span style="color:#097d24;font-family:'SimSun';">功能：将多个</span><span style="color:#097d24;"> json </span><span style="color:#097d24;font-family:'SimSun';">拷贝给目标对象</span><span style="color:#097d24;">*/<br></span><span style="color:#097d24;">/*</span><span style="color:#097d24;font-family:'SimSun';">原理：</span><span style="color:#097d24;">*/<br></span><span style="color:#097d24;">/*</span><span style="color:#097d24;font-family:'SimSun';">首先找到 </span><span style="color:#097d24;">target  -- arguments[0]*/<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">extend</span>() {<br>    let key<span style="color:#5c7ab8;">, </span>i <span style="color:#f92672;">= </span><span style="color:#ae81ff;">0</span><span style="color:#5c7ab8;">, </span>len <span style="color:#f92672;">= </span>arguments.length<span style="color:#5c7ab8;">, </span>target <span style="color:#f92672;">= null</span><span style="color:#5c7ab8;">, </span>copy<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span><span style="color:#5c7ab8;">    </span><span style="color:#f92672;">if </span>(len <span style="color:#f92672;">=== </span><span style="color:#ae81ff;">0</span>) {<br>        <span style="color:#f92672;">return</span><span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">    </span>} <span style="color:#f92672;">else if </span>(len <span style="color:#f92672;">=== </span><span style="color:#ae81ff;">1</span>) {<br>        target <span style="color:#f92672;">= this</span><span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">    </span>} <span style="color:#f92672;">else </span>{<br>        i<span style="color:#f92672;">++</span><span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">        </span>target <span style="color:#f92672;">= </span>arguments[<span style="color:#ae81ff;">0</span>]<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">    </span>}<br>    <br>    <span style="color:#f92672;">for </span>(<span style="color:#5c7ab8;">; </span>i <span style="color:#f92672;">&lt; </span>len<span style="color:#5c7ab8;">; </span>i<span style="color:#f92672;">++</span>) {<br>        <span style="color:#f92672;">for </span>(key <span style="color:#f92672;">in </span>arguments[i]) {<br>            copy <span style="color:#f92672;">= </span>arguments[i][key]<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">            </span>target[key] <span style="color:#f92672;">= </span>copy<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">        </span>}<br>    }<br>    <span style="color:#f92672;">return </span>target<span style="color:#5c7ab8;">;<br></span>}<br><br><span style="color:#097d24;">/*hasOwnProperty*/<br></span><span style="color:#f92672;">function </span><span style="color:#a6e22e;">extend2</span>() {<br>    <span style="color:#f92672;">for </span>(let p <span style="color:#f92672;">in </span>source) {<br>        <span style="color:#f92672;">if </span>(source.<span style="color:#a6e22e;">hasOwnProperty</span>(p)) {<br>            target[p] <span style="color:#f92672;">= </span>source[p]<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;">        </span>}<br>    }<br><br>    <span style="color:#f92672;">return </span>target<span style="color:#5c7ab8;">;<br></span>}<br><br><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">游戏随机生成名字<br></span>let <span style="font-style:italic;">boy </span><span style="color:#f92672;">= </span>{<br>    name<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">无忌</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>image<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">男性头像</span><span style="color:#e6db74;">'<br></span><span style="color:#e6db74;">    </span><span style="color:#5c7ab8;">, </span>age<span style="color:#f92672;">: </span><span style="color:#ae81ff;">20<br></span><span style="color:#ae81ff;">    </span><span style="color:#5c7ab8;">, </span>sex<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">男</span><span style="color:#e6db74;">'<br></span>}<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">技能名称，等级，伤害值，需要的魔法<br></span>let <span style="font-style:italic;">technology </span><span style="color:#f92672;">= </span>{tname<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">亡灵复活</span><span style="color:#e6db74;">'</span><span style="color:#5c7ab8;">, </span>tlevel<span style="color:#f92672;">: </span><span style="color:#ae81ff;">10</span><span style="color:#5c7ab8;">, </span>tstrength<span style="color:#f92672;">: </span><span style="color:#ae81ff;">3000</span><span style="color:#5c7ab8;">, </span>tmagic<span style="color:#f92672;">: </span><span style="color:#ae81ff;">30</span>}<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span>let <span style="font-style:italic;">shenqi </span><span style="color:#f92672;">= </span>{sname<span style="color:#f92672;">: </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">霜之哀伤</span><span style="color:#e6db74;">'</span><span style="color:#5c7ab8;">, </span>slevel<span style="color:#f92672;">: </span><span style="color:#ae81ff;">30</span><span style="color:#5c7ab8;">, </span>sstrength<span style="color:#f92672;">: </span><span style="color:#ae81ff;">3000</span>}<br><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">当这个人有了穿上盔甲，圣衣，六神合体，戴上魔法戒指之后，自动也拥有一个技能<br></span><span style="color:#0b8b15;font-family:'SimSun';"><br></span><span style="color:#0b8b15;font-family:'SimSun';"><br></span><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">第一种用法<br></span>let <span style="font-style:italic;">zuixiake </span><span style="color:#f92672;">= </span><span style="color:#a6e22e;">extend</span>({}<span style="color:#5c7ab8;">, </span><span style="font-style:italic;">technology</span><span style="color:#5c7ab8;">, </span><span style="font-style:italic;">shenqi</span>)<span style="color:#5c7ab8;">;<br></span><span style="font-style:italic;">zuixiake</span>.name <span style="color:#f92672;">= </span><span style="color:#e6db74;">'</span><span style="color:#e6db74;font-family:'SimSun';">醉侠客</span><span style="color:#e6db74;">'</span><span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">zuixiake</span>.name)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">zuixiake</span>.tname)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">zuixiake</span>.sname)<span style="color:#5c7ab8;">;<br></span><span style="color:#5c7ab8;"><br></span><span style="color:#0b8b15;">//</span><span style="color:#0b8b15;font-family:'SimSun';">第二种用法<br></span><span style="color:#a6e22e;">extend</span>(<span style="font-style:italic;">boy</span><span style="color:#5c7ab8;">, </span><span style="font-style:italic;">technology</span><span style="color:#5c7ab8;">, </span><span style="font-style:italic;">shenqi</span>)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">boy</span>.name)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">boy</span>.tname)<span style="color:#5c7ab8;">;<br></span><span style="color:#a6e22e;">alert</span>(<span style="font-style:italic;">boy</span>.sname)<span style="color:#5c7ab8;">;<br></span></pre></div><h3 id="blogTitle131"><span style="font-weight: 700;">原型继承</span></h3><div><div>在传统的基于 Class 的语言如 Java、C++ 中，继承的本质是扩展一个已有的 Class，并生成新的Subclass。</div><div><br></div><div>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript 由于采用原型继承，我们无法直接扩展一个 Class，因为根本不存在 Class 这种类型。</div><div><br></div><div>但是办法还是有的。我们先回顾 Student 构造函数：</div><pre>function Student(props) {<br>&nbsp; &nbsp; this.name = props.name || 'Unnamed';<br>}<br>Student.prototype.hello = function () {<br>&nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>}</pre><div>以及Student的原型链：</div><div><img src="data:image/png;base64,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"><br></div><div><br></div><div>现在，我们要基于 Student 扩展出 PrimaryStudent，可以先定义出 PrimaryStudent：</div><pre>function PrimaryStudent(props) {<br>&nbsp; &nbsp; // 调用Student构造函数，绑定this变量:<br>&nbsp; &nbsp; Student.call(this, props);<br>&nbsp; &nbsp; this.grade = props.grade || 1;<br>}</pre><div>但是，调用了 Student 构造函数不等于继承了 Student，PrimaryStudent 创建的对象的原型是：</div><pre>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null</pre><div>必须想办法把原型链修改为：</div><pre>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</pre><div>这样，原型链对了，继承关系就对了。新的基于 PrimaryStudent 创建的对象不但能调用 PrimaryStudent.prototype 定义的方法，也可以调用 Student.prototype 定义的方法。</div><div><br></div><div>如果你想用最简单粗暴的方法这么干：</div><pre>PrimaryStudent.prototype = Student.prototype;</pre><div>是不行的！如果这样的话，PrimaryStudent 和 Student 共享一个原型对象，那还要定义 PrimaryStudent 干啥？</div><div><br></div><div>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向 Student.prototype。为了实现这一点，参考道爷（就是发明 JSON 的那个道格拉斯）的代码，中间对象可以用一个空函数 F 来实现：</div><pre>// PrimaryStudent构造函数:<br>function PrimaryStudent(props) {<br>&nbsp; &nbsp; Student.call(this, props);<br>&nbsp; &nbsp; this.grade = props.grade || 1;<br>}<br>// 空函数F:<br>function F() {<br>}<br>// 把F的原型指向Student.prototype:<br>F.prototype = Student.prototype;<br>// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:<br>PrimaryStudent.prototype = new F();<br>// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:<br>PrimaryStudent.prototype.constructor = PrimaryStudent;<br>// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：<br>PrimaryStudent.prototype.getGrade = function () {<br>&nbsp; &nbsp; return this.grade;<br>};<br>// 创建xiaoming:<br>var xiaoming = new PrimaryStudent({<br>&nbsp; &nbsp; name: '小明',<br>&nbsp; &nbsp; grade: 2<br>});<br>xiaoming.name; // '小明'<br>xiaoming.grade; // 2<br>// 验证原型:<br>xiaoming.__proto__ === PrimaryStudent.prototype; // true<br>xiaoming.__proto__.__proto__ === Student.prototype; // true<br>// 验证继承关系:<br>xiaoming instanceof PrimaryStudent; // true<br>xiaoming instanceof Student; // true</pre><div>用一张图来表示新的原型链：</div><div><img src="data:image/png;base64,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"><br></div><div><br></div><div>注意，函数F仅用于桥接，我们仅创建了一个 new F() 实例，而且，没有改变原有的 Student 定义的原型链。</div><div><br></div><div>如果把继承这个动作用一个 inherits() 函数封装起来，还可以隐藏 F 的定义，并简化代码：</div><pre>function inherits(Child, Parent) {<br>&nbsp; &nbsp; var F = function () {};<br>&nbsp; &nbsp; F.prototype = Parent.prototype;<br>&nbsp; &nbsp; Child.prototype = new F();<br>&nbsp; &nbsp; Child.prototype.constructor = Child;<br>}</pre><div>这个 inherits() 函数可以复用：</div><pre>function Student(props) {<br>&nbsp; &nbsp; this.name = props.name || 'Unnamed';<br>}<br>Student.prototype.hello = function () {<br>&nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>}<br>function PrimaryStudent(props) {<br>&nbsp; &nbsp; Student.call(this, props);<br>&nbsp; &nbsp; this.grade = props.grade || 1;<br>}<br>// 实现原型继承链:<br>inherits(PrimaryStudent, Student);<br>// 绑定其他方法到PrimaryStudent原型:<br>PrimaryStudent.prototype.getGrade = function () {<br>&nbsp; &nbsp; return this.grade;<br>};</pre><div><b>小结</b></div><div><br></div><div>JavaScript的原型继承实现方式就是：</div><div><br></div><div>定义新的构造函数，并在内部用 call() 调用希望“继承”的构造函数，并绑定 this；</div><div>借助中间函数 F 实现原型链继承，最好通过封装的 inherits 函数完成；</div><div>继续在新的构造函数的原型上定义新方法。</div></div><h3 id="blogTitle132"><span style="font-weight: 700;">class 继承</span></h3><div><div>在上面的章节中我们看到了JavaScript 的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</div><div><br></div><div>有没有更简单的写法？有！</div><div><br></div><div>新的关键字 class 从 ES6 开始正式被引入到 JavaScript 中。class 的目的就是让定义类更简单。</div><div><br></div><div>我们先回顾用函数实现 Student 的方法：</div><pre>function Student(name) {<br>&nbsp; &nbsp; this.name = name;<br>}<br>Student.prototype.hello = function () {<br>&nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>}</pre><div>如果用新的 class 关键字来编写 Student，可以这样写：</div><pre>class Student {<br>&nbsp; &nbsp; constructor(name) {<br>&nbsp; &nbsp; &nbsp; &nbsp; this.name = name;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; hello() {<br>&nbsp; &nbsp; &nbsp; &nbsp; alert('Hello, ' + this.name + '!');<br>&nbsp; &nbsp; }<br>}</pre><div>比较一下就可以发现，class 的定义包含了构造函数 constructor 和定义在原型对象上的函数 hello()（注意没有 function 关键字），这样就避免了 Student.prototype.hello = function () {...} 这样分散的代码。</div><div><br></div><div>最后，创建一个 Student 对象代码和前面章节完全一样：</div><pre>var xiaoming = new Student('小明');<br>xiaoming.hello();</pre><div><b>class继承</b></div><div><br></div><div>用 class 定义对象的另一个巨大的好处是继承更方便了。想一想我们从 Student 派生一个 PrimaryStudent 需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过 extends 来实现：</div><pre>class PrimaryStudent extends Student {<br>&nbsp; &nbsp; constructor(name, grade) {<br>&nbsp; &nbsp; &nbsp; &nbsp; super(name); // 记得用super调用父类的构造方法!<br>&nbsp; &nbsp; &nbsp; &nbsp; this.grade = grade;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; myGrade() {<br>&nbsp; &nbsp; &nbsp; &nbsp; alert('I am at grade ' + this.grade);<br>&nbsp; &nbsp; }<br>}</pre><div>注意 PrimaryStudent 的定义也是 class 关键字实现的，而 extends 则表示原型链对象来自 Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent 需要 name 和 grade 两个参数，并且需要通过 super(name) 来调用父类的构造函数，否则父类的 name 属性无法正常初始化。</div><div><br></div><div>PrimaryStudent 已经自动获得了父类 Student 的 hello 方法，我们又在子类中定义了新的 myGrade 方法。</div><div><br></div><div>ES6 引入的 class 和原有的 JavaScript 原型继承有什么区别呢？实际上它们没有任何区别，class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。</div><div><br></div><div>你一定会问，class 这么好用，能不能现在就用上？</div><div><br></div><div>现在用还早了点，因为不是所有的主流浏览器都支持 ES6 的 class。如果一定要现在就用上，就需要一个工具把 class 代码转换为传统的 prototype 代码，可以试试 Babel 这个工具。</div></div><div><br></div><h3 style="" id="blogTitle133"><span style="font-weight: 700;">混合工厂方式</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">目的是创建假构造函数，只返回另一种对象的新实例。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这段代码看起来与工厂函数非常相似：</p><pre>function Car() {
  <font color="#0000dd" face="Consolas, Courier New, Courier, monospace"><span style="border-style: initial; border-color: initial; border-image: initial;">var oTempCar = new Object;</span></font>
  oTempCar.color = "blue";
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() {
    alert(this.color);
  };

  return oTempCar;
}</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p><pre>var car = <span style="margin: 0px; padding: 0px; border: 0px;">new</span> Car();</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。</p><div style="margin: 0px 0px 0px 15px; padding: 20px 0px; border-width: 1px 0px; border-top-style: solid; border-right-style: initial; border-bottom-style: solid; border-left-style: initial; border-top-color: rgb(170, 170, 170); border-right-color: initial; border-bottom-color: rgb(170, 170, 170); border-left-color: initial; border-image: initial;"><h3 style="margin-bottom: 0px; padding: 0px; border: 0px;" id="blogTitle134"><span style="font-weight: 700;">采用哪种方式</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。</p></div><h2 style="" id="blogTitle135"><b>应用</b></h2><h3 style="" id="blogTitle136"><b>利用 JS 对象解决字符串连接时的性能问题</b></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">对象令人感兴趣的一点是用它们解决问题的方式。ECMAScript 中最常见的一个问题是字符串连接的性能。与其他语言类似，ECMAScript 的字符串是不可变的，即它们的值不能改变。请考虑下面的代码：</p><pre>var str = "hello ";
str += "world";
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">实际上，这段代码在幕后执行的步骤如下：</p><ol style="margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding: 0px; border: 0px;"><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">创建存储 "hello " 的字符串。</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">创建存储 "world" 的字符串。</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">创建存储连接结果的字符串。</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">把 str 的当前内容复制到结果中。</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">把 "world" 复制到结果中。</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">更新 str，使它指向结果。</li></ol><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：</p><pre>var arr = new Array();
arr[0] = "hello ";
arr[1] = "world";
var str = arr.join("");
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这样，无论数组中引入多少字符串都不成问题，因为只在调用 join() 方法时才会发生连接操作。此时，执行的步骤如下：</p><ol style="margin-top: 10px; margin-bottom: 0px; margin-left: 35px; padding: 0px; border: 0px;"><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">创建存储结果的字符串</li><li style="margin: 3px 0px 0px; padding: 0px; border: 0px;">把每个字符串复制到结果中的合适位置</li></ol><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：</p><pre>function StringBuffer () {
  this._strings_ = new Array();
}

StringBuffer.prototype.append = function(str) {
  this._strings_.push(str);
};

StringBuffer.prototype.toString = function() {
  return this._strings_.join("");
};
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这段代码首先要注意的是 strings 属性，本意是私有属性。它只有两个方法，即 append() 和 toString() 方法。append() 方法有一个参数，它把该参数附加到字符串数组中，toString() 方法调用数组的 join 方法，返回真正连接成的字符串。要用 StringBuffer 对象连接一组字符串，可以用下面的代码：</p><pre>var buffer = new StringBuffer ();
buffer.append("hello ");
buffer.append("world");
var result = buffer.toString();</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">可用下面的代码测试 StringBuffer 对象和传统的字符串连接方法的性能：</p><pre>var d1 = new Date();
var str = "";
for (var i=0; i &lt; 10000; i++) {
    str += "text";
}
var d2 = new Date();

document.write("Concatenation with plus: "
 + (d2.getTime() - d1.getTime()) + " milliseconds");

var buffer = new StringBuffer();
d1 = new Date();
for (var i=0; i &lt; 10000; i++) {
    buffer.append("text");
}
var result = buffer.toString();
d2 = new Date();

document.write("&lt;br /&gt;Concatenation with StringBuffer: "
 + (d2.getTime() - d1.getTime()) + " milliseconds");</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这段代码对字符串连接进行两个测试，第一个使用加号，第二个使用 StringBuffer 类。每个操作都连接 10000 个字符串。日期值 d1 和 d2 用于判断完成操作需要的时间。请注意，创建 Date 对象时，如果没有参数，赋予对象的是当前的日期和时间。要计算连接操作历经多少时间，把日期的毫秒表示（用 getTime() 方法的返回值）相减即可。这是衡量 JavaScript 性能的常见方法。该测试的结果可以帮助您比较使用 StringBuffer 类与使用加号的效率差异。</p><div><span style="font-weight: 700;"><br></span></div><h2 id="blogTitle137"><span style="font-weight: 700;">ES 修改对象</span></h2><div><div style="margin: 0px 0px 0px 15px; padding: 20px 0px; border-width: 1px 0px; border-top-style: solid; border-right-style: initial; border-bottom-style: solid; border-left-style: initial; border-top-color: rgb(170, 170, 170); border-right-color: initial; border-bottom-color: rgb(170, 170, 170); border-left-color: initial; border-image: initial;"><p style="margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="margin: 0px; padding: 0px; border: 0px;"><span style="font-weight: 700;">通过使用 ECMAScript，不仅可以创建对象，还可以修改已有对象的行为。</span></span></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="margin: 0px; padding: 0px; border: 0px;"><span style="font-weight: 700;">prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。</span></span></p></div><h3 style="" id="blogTitle138"><span style="font-weight: 700;">创建新方法</span></h3><h4 style="" id="blogTitle139"><span style="font-weight: 700;">通过已有的方法创建新方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">可以用 prototype 属性为任何已有的类定义新方法，就像处理自己的类一样。例如，还记得 Number 类的 toString() 方法吗？如果给它传递参数 16，它将输出十六进制的字符串。如果这个方法的参数是 2，那么它将输出二进制的字符串。我们可以创建一个方法，可以把数字对象直接转换为十六进制字符串。创建这个方法非常简单：</p><pre>Number.prototype.toHexString = function() {
  return this.toString(16);
};
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在此环境中，关键字 this 指向 Number 的实例，因此可完全访问 Number 的所有方法。有了这段代码，可实现下面的操作：</p><pre>var iNum = 15;
alert(iNum.toHexString());      <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "F"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">由于数字 15 等于十六进制中的 F，因此警告将显示 "F"。</p><h4 style="" id="blogTitle140"><span style="font-weight: 700;">重命名已有方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">我们还可以为已有的方法命名更易懂的名称。例如，可以给 Array 类添加两个方法 enqueue() 和 dequeue()，只让它们反复调用已有的 push() 和 shift() 方法即可：</p><pre>Array.prototype.enqueue = function(vItem) {
  this.push(vItem);
};

Array.prototype.dequeue = function() {
  return this.shift();
};</pre><h4 style="" id="blogTitle141"><span style="font-weight: 700;">添加与已有方法无关的方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">当然，还可以添加与已有方法无关的方法。例如，假设要判断某个项在数组中的位置，没有本地方法可以做这种事情。我们可以轻松地创建下面的方法：</p><pre>Array.prototype.indexOf = function (vItem) {
  for (var i=0; i&lt;this.length; i++) {
    if (vItem == this[i]) {
      return i;
    }
  }

  return -1;
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">该方法 indexOf() 与 String 类的同名方法保持一致，在数组中检索每个项，直到发现与传进来的项相同的项目为止。如果找到相同的项，则返回该项的位置，否则，返回 -1。有了这种定义，我们可以编写下面的代码：</p><pre>var aColors = new Array("red","green","blue");
alert(aColors.indexOf("green"));    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "1"</span></pre><h4 style="" id="blogTitle142"><span style="font-weight: 700;">为本地对象添加新方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">最后，如果想给 ECMAScript 中每个本地对象添加新方法，必须在 Object 对象的 prototype 属性上定义它。前面的章节我们讲过，所有本地对象都继承了 Object 对象，所以对 Object 对象做任何改变，都会反应在所有本地对象上。例如，如果想添加一个用警告输出对象的当前值的方法，可以采用下面的代码：</p><pre>Object.prototype.showValue = function () {
  alert(this.valueOf());
};

var str = "hello";
var iNum = 25;
str.showValue();        <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "hello"</span>
iNum.showValue();       <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "25"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里，String 和 Number 对象都从 Object 对象继承了 showValue() 方法，分别在它们的对象上调用该方法，将显示 "hello" 和 "25"。</p><h3 style="" id="blogTitle143"><span style="font-weight: 700;">重定义已有方法</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">就像能给已有的类定义新方法一样，也可重定义已有的方法。如前面的章节所述，函数名只是指向函数的指针，因此可以轻松地指向其他函数。如果修改了本地方法，如 toString()，会出现什么情况呢？</p><pre>Function.prototype.toString = function() {
  return "Function code hidden";
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">前面的代码完全合法，运行结果完全符合预期：</p><pre>function sayHi() {
  alert("hi");
}

alert(sayHi.toString());    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "Function code hidden"</span></pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">也许你还记得，Function 对象这一章中介绍过 Function 的 toString() 方法通常输出的是函数的源代码。覆盖该方法，可以返回另一个字符串（在这个例子中，可以返回 "Function code hidden"）。不过，toString() 指向的原始函数怎么了呢？它将被无用存储单元回收程序回收，因为它被完全废弃了。没有能够恢复原始函数的方法，所以在覆盖原始方法前，比较安全的做法是存储它的指针，以便以后的使用。有时你甚至可能在新方法中调用原始方法：</p><pre><font color="#0000dd" face="Consolas, Courier New, Courier, monospace"><span style="border-style: initial; border-color: initial; border-image: initial;">Function.prototype.originalToString = Function.prototype.toString;</span></font>

Function.prototype.toString = function() {
  if (this.originalToString().length &gt; 100) {
    return "Function too long to display.";
  } else {
    return this.originalToString();
  }
};</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在这段代码中，第一行代码把对当前 toString() 方法的引用保存在属性 originalToString 中。然后用定制的方法覆盖了 toString() 方法。新方法将检查该函数源代码的长度是否大于 100。如果是，就返回错误信息，说明该函数代码太长，否则调用 originalToString() 方法，返回函数的源代码。</p><h3 id="blogTitle144"><span style="font-weight: 700;">极晚绑定（Very Late Binding）</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">从技术上讲，根本不存在极晚绑定。本书采用该术语描述 ECMAScript 中的一种现象，即能够在对象实例化后再定义它的方法。例如：</p><pre>var o = new Object();

Object.prototype.sayHi = function () {
  alert("hi");
};

o.sayHi();</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在大多数程序设计语言中，必须在实例化对象之前定义对象的方法。这里，方法 sayHi() 是在创建 Object 类的一个实例之后来添加进来的。在传统语言中不仅没听说过这种操作，也没听说过该方法还会自动赋予 Object 对象的实例并能立即使用（接下来的一行）。</p><p class="important" style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="margin: 0px; padding: 0px; border: 0px;">注意：</span>不建议使用极晚绑定方法，因为很难对其跟踪和记录。不过，还是应该了解这种可能。</p></div><div><br></div><h1 id="blogTitle145"><b>Class 的基本语法</b><br></h1><div><ol class="content-toc" id="content-toc" style="padding-top: 0.5rem; padding-bottom: 0.5rem; background: rgb(189, 195, 199); border-radius: 5px; font-size: 14.336px; font-family: Verdana, Arial; color: rgb(51, 51, 51);"><li data-src="简介" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#简介" style="background-position: initial; color: rgb(70, 130, 190);">简介</a></li><li data-src="严格模式" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#严格模式" style="background-position: initial; color: rgb(70, 130, 190);">严格模式</a></li><li data-src="constructor-方法" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#constructor 方法" style="background-position: initial; color: rgb(70, 130, 190);">constructor 方法</a></li><li data-src="类的实例对象" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#类的实例对象" style="background-position: initial; color: rgb(70, 130, 190);">类的实例对象</a></li><li data-src="Class-表达式" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#Class 表达式" style="background-position: initial; color: rgb(70, 130, 190);">Class 表达式</a></li><li data-src="不存在变量提升" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#不存在变量提升" style="background-position: initial; color: rgb(70, 130, 190);">不存在变量提升</a></li><li data-src="私有方法" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#私有方法" style="background-position: initial; color: rgb(70, 130, 190);">私有方法</a></li><li data-src="私有属性" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#私有属性" style="background-position: initial; color: rgb(70, 130, 190);">私有属性</a></li><li data-src="this-的指向" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#this 的指向" style="background-position: initial; color: rgb(70, 130, 190);">this 的指向</a></li><li data-src="name-属性" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#name 属性" style="background-position: initial; color: rgb(70, 130, 190);">name 属性</a></li><li data-src="Class-的取值函数（getter）和存值函数（setter）" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#Class 的取值函数（getter）和存值函数（setter）" style="background-position: initial; color: rgb(70, 130, 190);">Class 的取值函数（getter）和存值函数（setter）</a></li><li data-src="Class-的-Generator-方法" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#Class 的 Generator 方法" style="background-position: initial; color: rgb(70, 130, 190);">Class 的 Generator 方法</a></li><li data-src="Class-的静态方法" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#Class 的静态方法" style="background-position: initial; color: rgb(70, 130, 190);">Class 的静态方法</a></li><li data-src="Class-的静态属性和实例属性" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#Class 的静态属性和实例属性" style="background-position: initial; color: rgb(70, 130, 190);">Class 的静态属性和实例属性</a></li><li data-src="new-target-属性" class="link" style="font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer; text-indent: -5px;"><a href="http://es6.ruanyifeng.com/#docs/class#new.target 属性" style="background-position: initial; color: rgb(70, 130, 190);">new.target 属性</a></li></ol><h2 id="blogTitle146" class="简介" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">简介</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};

var p = new Point(1, 2);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>关键字，可以定义类。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">基本上，ES6 的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>改写，就是下面这样。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码定义了一个“类”，可以看到里面有一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法，这就是构造方法，而<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>关键字则代表实例对象。也就是说，ES5 的构造函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>，对应 ES6 的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类的构造方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类除了构造方法，还定义了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 的类，完全可以看作构造函数的另一种写法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  // ...
}

typeof Point // "function"
Point === Point.prototype.constructor // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">使用的时候，也是直接对类使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令，跟构造函数的用法完全一致。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Bar {
  doStuff() {
    console.log('stuff');
  }
}

var b = new Bar();
b.doStuff() // "stuff"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">构造函数的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性上面。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">在类的实例上面调用方法，其实就是调用原型上的方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class B {}
let b = new B();

b.constructor === B.prototype.constructor // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">b</code>是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>类的实例，它的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法就是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>类原型的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">由于类的方法都定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象上面，所以类的新方法可以添加在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象上面。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">Point.prototype.constructor === Point // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>方法是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function() {
  // ...
};

Object.keys(Point.prototype)
// ["toString"]
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码采用 ES5 的写法，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>方法就是可枚举的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类的属性名，可以采用表达式。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let methodName = 'getArea';

class Square {
  constructor(length) {
    // ...
  }

  [methodName]() {
    // ...
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Square</code>类的方法名<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">getArea</code>，是从表达式得到的。</p><h2 id="blogTitle147" class="严格模式" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">严格模式</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类和模块的内部，默认就是严格模式，所以不需要使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><h2 id="blogTitle148" class="constructor-方法" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">constructor 方法</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法是类的默认方法，通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法，如果没有显式定义，一个空的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法会被默认添加。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
}

// 等同于
class Point {
  constructor() {}
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，定义了一个空的类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>，JavaScript 引擎会自动为它添加一个空的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法默认返回实例对象（即<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>），完全可以指定返回另外一个对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo
// false</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的实例。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类必须使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>也可以执行。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  constructor() {
    return Object.create(null);
  }
}

Foo()
// TypeError: Class constructor Foo cannot be invoked without 'new'</code></pre><h2 id="blogTitle149" class="类的实例对象" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">类的实例对象</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">生成类的实例对象的写法，与 ES5 完全一样，也是使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令。前面说过，如果忘记加上<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>，像函数那样调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Class</code>，将会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  // ...
}

// 报错
var point = Point(2, 3);

// 正确
var point = new Point(2, 3);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象上），否则都是定义在原型上（即定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>上）。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">//定义类
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">y</code>都是实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">point</code>自身的属性（因为定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>变量上），所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">hasOwnProperty</code>方法返回<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">true</code>，而<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>是原型对象的属性（因为定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类上），所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">hasOwnProperty</code>方法返回<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">false</code>。这些都与 ES5 的行为保持一致。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与 ES5 一样，类的所有实例共享一个原型对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p1</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p2</code>都是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>的实例，它们的原型都是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point.prototype</code>，所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性是相等的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这也意味着，可以通过实例的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性为“类”添加方法。</p><blockquote style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px; font-style: normal;"><p><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>&nbsp;并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用&nbsp;<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getPrototypeOf</code>&nbsp;方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p></blockquote><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () { return 'Oops' };

p1.printName() // "Oops"
p2.printName() // "Oops"

var p3 = new Point(4,2);
p3.printName() // "Oops"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p1</code>的原型上添加了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">printName</code>方法，由于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p1</code>的原型就是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p2</code>的原型，因此<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p2</code>也可以调用这个方法。而且，此后新建的实例<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p3</code>也可以调用这个方法。这意味着，使用实例的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h2 id="blogTitle150" class="Class-表达式" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Class 表达式</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与函数一样，类也可以使用表达式的形式定义。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const MyClass = class Me {
  getClassName() {
    return Me.name;
  }
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>而不是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Me</code>，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Me</code>只在 Class 的内部代码可用，指代当前类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码表示，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Me</code>只在 Class 内部有定义。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果类的内部没用到的话，可以省略<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Me</code>，也就是可以写成下面的形式。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const MyClass = class { /* ... */ };</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">采用 Class 表达式，可以写出立即执行的 Class。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let person = new class {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}('张三');

person.sayName(); // "张三"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">person</code>是一个立即执行的类的实例。</p><h2 id="blogTitle151" class="不存在变量提升" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">不存在变量提升</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">new Foo(); // ReferenceError
class Foo {}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">{
  let Foo = class {};
  class Bar extends Foo {
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面的代码不会报错，因为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Bar</code>继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>的时候，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>已经有定义了。但是，如果存在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>的提升，上面代码就会报错，因为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>会被提升到代码头部，而<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">let</code>命令是不提升的，所以导致<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Bar</code>继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>的时候，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>还没有定义。</p><h2 id="blogTitle152" class="私有方法" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">私有方法</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">一种做法是在命名上加以区别。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Widget {

  // 公有方法
  foo (baz) {
    this._bar(baz);
  }

  // 私有方法
  _bar(baz) {
    return this.snaf = baz;
  }

  // ...
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Widget {
  foo (baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>是公有方法，内部调用了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar.call(this, baz)</code>。这使得<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar</code>实际上成为了当前模块的私有方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">还有一种方法是利用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Symbol</code>值的唯一性，将私有方法的名字命名为一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Symbol</code>值。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const bar = Symbol('bar');
const snaf = Symbol('snaf');

export default class myClass{

  // 公有方法
  foo(baz) {
    this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }

  // ...
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">snaf</code>都是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Symbol</code>值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h2 id="blogTitle153" class="私有属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">私有属性</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与私有方法一样，ES6 不支持私有属性。目前，有一个<a href="https://github.com/tc39/proposal-class-fields#private-fields" style="background-position: initial; color: rgb(70, 130, 190);">提案</a>，为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>加了私有属性。方法是在属性名之前，使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">#</code>表示。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  #x;

  constructor(x = 0) {
    #x = +x; // 写成 this.#x 亦可
  }

  get x() { return #x }
  set x(value) { #x = +value }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">#x</code>就表示私有属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>，在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">#x</code>与<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">get x()</code>）。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">私有属性可以指定初始值，在构造函数执行时进行初始化。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  #x = 0;
  constructor() {
    #x; // 0
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">之所以要引入一个新的前缀<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">#</code>表示私有属性，而没有采用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">private</code>关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@</code>表示私有属性，ES6 没有用这个符号而使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">#</code>，是因为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@</code>已经被留给了 Decorator。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  #a;
  #b;
  #sum() { return #a + #b; }
  printSum() { console.log(#sum()); }
  constructor(a, b) { #a = a; #b = b; }
}</code></pre><h2 id="blogTitle154" class="this-的指向" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">this 的指向</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类的方法内部如果含有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`);
  }

  print(text) {
    console.log(text);
  }
}

const logger = new Logger();
const { printName } = logger;
printName(); // TypeError: Cannot read property 'print' of undefined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">printName</code>方法中的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，默认指向<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>会指向该方法运行时所在的环境，因为找不到<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">print</code>方法而导致报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">一个比较简单的解决方法是，在构造方法中绑定<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，这样就不会找不到<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">print</code>方法了。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Logger {
  constructor() {
    this.printName = this.printName.bind(this);
  }

  // ...
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另一种解决方法是使用箭头函数。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Logger {
  constructor() {
    this.printName = (name = 'there') =&gt; {
      this.print(`Hello ${name}`);
    };
  }

  // ...
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">还有一种解决方法是使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Proxy</code>，获取方法的时候，自动绑定<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function selfish (target) {
  const cache = new WeakMap();
  const handler = {
    get (target, key) {
      const value = Reflect.get(target, key);
      if (typeof value !== 'function') {
        return value;
      }
      if (!cache.has(value)) {
        cache.set(value, value.bind(target));
      }
      return cache.get(value);
    }
  };
  const proxy = new Proxy(target, handler);
  return proxy;
}

const logger = selfish(new Logger());</code></pre><h2 id="blogTitle155" class="name-属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">name 属性</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Class</code>继承，包括<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">name</code>属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {}
Point.name // "Point"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">name</code>属性总是返回紧跟在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">class</code>关键字后面的类名。</p><h2 id="blogTitle156" class="Class-的取值函数（getter）和存值函数（setter）" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Class 的取值函数（getter）和存值函数（setter）</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">与 ES5 一样，在“类”的内部可以使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">get</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// 'getter'</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class CustomHTMLElement {
  constructor(element) {
    this.element = element;
  }

  get html() {
    return this.element.innerHTML;
  }

  set html(value) {
    this.element.innerHTML = value;
  }
}

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, "html"
);

"get" in descriptor  // true
"set" in descriptor  // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，存值函数和取值函数是定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">html</code>属性的描述对象上面，这与 ES5 完全一致。</p><h2 id="blogTitle157" class="Class-的-Generator-方法" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Class 的 Generator 方法</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果某个方法之前加上星号（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">*</code>），就表示该方法是一个 Generator 函数。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  constructor(...args) {
    this.args = args;
  }
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}

for (let x of new Foo('hello', 'world')) {
  console.log(x);
}
// hello
// world</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Symbol.iterator</code>方法返回一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的默认遍历器，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">for...of</code>循环会自动调用这个遍历器。</p><h2 id="blogTitle158" class="Class-的静态方法" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Class 的静态方法</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">classMethod</code>方法前有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">static</code>关键字，表明该方法是一个静态方法，可以直接在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类上调用（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo.classMethod()</code>），而不是在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，如果静态方法包含<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>关键字，这个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指的是类，而不是实例。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  static bar () {
    this.baz();
  }
  static baz () {
    console.log('hello');
  }
  baz () {
    console.log('world');
  }
}

Foo.bar() // hello</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，静态方法<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar</code>调用了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this.baz</code>，这里的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类，而不是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>的实例，等同于调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">父类的静态方法，可以被子类继承。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
}

Bar.classMethod() // 'hello'</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>有一个静态方法，子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Bar</code>可以调用这个方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">静态方法也是可以从<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>对象上调用的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + ', too';
  }
}

Bar.classMethod() // "hello, too"</code></pre><h2 id="blogTitle159" class="Class-的静态属性和实例属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Class 的静态属性和实例属性</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">静态属性指的是 Class 本身的属性，即<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Class.propName</code>，而不是定义在实例对象（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>）上的属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Foo {
}

Foo.prop = 1;
Foo.prop // 1</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面的写法为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类定义了一个静态属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prop</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// 以下两种写法都无效
class Foo {
  // 写法一
  prop: 2

  // 写法二
  static prop: 2
}

Foo.prop // undefined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">目前有一个静态属性的<a href="https://github.com/tc39/proposal-class-fields" style="background-position: initial; color: rgb(70, 130, 190);">提案</a>，对实例属性和静态属性都规定了新的写法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">（1）类的实例属性</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类的实例属性可以用等式，写入类的定义之中。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass {
  myProp = 42;

  constructor() {
    console.log(this.myProp); // 42
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">myProp</code>就是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>的实例属性。在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>的实例上，可以读取这个属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">以前，我们定义实例属性，只能写在类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法里面。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ReactCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，构造方法<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>里面，定义了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this.state</code>属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">有了新的写法以后，可以不在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法里面定义。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ReactCounter extends React.Component {
  state = {
    count: 0
  };
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这种写法比以前更清晰。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">为了可读性的目的，对于那些在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>里面已经定义的实例属性，新写法允许直接列出。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ReactCounter extends React.Component {
  state;
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">（2）类的静态属性</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">类的静态属性只要在上面的实例属性写法前面，加上<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">static</code>关键字就可以了。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass {
  static myStaticProp = 42;

  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">同样的，这个新写法大大方便了静态属性的表达。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// 老写法
class Foo {
  // ...
}
Foo.prop = 1;

// 新写法
class Foo {
  static prop = 1;
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><h2 id="blogTitle160" class="new-target-属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">new.target 属性</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>是从构造函数生成实例对象的命令。ES6 为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令引入了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>属性，该属性一般用在构造函数之中，返回<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令作用于的那个构造函数。如果构造函数不是通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令调用的，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>会返回<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function Person(name) {
  if (new.target !== undefined) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

// 另一种写法
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

var person = new Person('张三'); // 正确
var notAPerson = Person.call(person, '张三');  // 报错</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码确保构造函数只能通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new</code>命令调用。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Class 内部调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>，返回当前 Class。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  }
}

var obj = new Rectangle(3, 4); // 输出 true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">需要注意的是，子类继承父类时，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>会返回子类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle);
    // ...
  }
}

class Square extends Rectangle {
  constructor(length) {
    super(length, length);
  }
}

var obj = new Square(3); // 输出 false</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>会返回子类。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('本类不能实例化');
    }
  }
}

class Rectangle extends Shape {
  constructor(length, width) {
    super();
    // ...
  }
}

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Shape</code>类不能被实例化，只能用于继承。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，在函数外部，使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>会报错。</p></div><div><br></div><h1 id="blogTitle161"><b>Class 的继承</b><br></h1><div><ol class="content-toc" id="content-toc" style="padding-top: 0.5rem; padding-bottom: 0.5rem; background: rgb(189, 195, 199); border-radius: 5px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><li data-src="简介" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#简介" style="background-position: initial; color: rgb(70, 130, 190);">简介</a></li><li data-src="Object-getPrototypeOf" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#Object.getPrototypeOf()" style="background-position: initial; color: rgb(70, 130, 190);">Object.getPrototypeOf()</a></li><li data-src="super-关键字" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#super 关键字" style="background-position: initial; color: rgb(70, 130, 190);">super 关键字</a></li><li data-src="类的-prototype-属性和__proto__属性" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#类的 prototype 属性和__proto__属性" style="background-position: initial; color: rgb(70, 130, 190);">类的 prototype 属性和__proto__属性</a></li><li data-src="原生构造函数的继承" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#原生构造函数的继承" style="background-position: initial; color: rgb(70, 130, 190);">原生构造函数的继承</a></li><li data-src="Mixin-模式的实现" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/class-extends#Mixin 模式的实现" style="background-position: initial; color: rgb(70, 130, 190);">Mixin 模式的实现</a></li></ol><h2 id="blogTitle162" class="简介" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">简介</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Class 可以通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
}

class ColorPoint extends Point {
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码定义了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>类，该类通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">extends</code>关键字，继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类。下面，我们在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>内部加上代码。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">toString</code>方法之中，都出现了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">子类必须在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法中调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象，而是继承父类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象，然后对其进行加工。如果不调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法，子类就得不到<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point { /* ... */ }

class ColorPoint extends Point {
  constructor() {
  }
}

let cp = new ColorPoint(); // ReferenceError</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>继承了父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>，但是它的构造函数没有调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法，导致新建实例时报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES5 的继承，实质是先创造子类的实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，然后再将父类的方法添加到<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>上面（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>（所以必须先调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法），然后再用子类的构造函数修改<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果子类没有定义<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ColorPoint extends Point {
}

// 等同于
class ColorPoint extends Point {
  constructor(...args) {
    super(...args);
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另一个需要注意的地方是，在子类的构造函数中，只有调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>之后，才可以使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法才能返回父类实例。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，子类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">constructor</code>方法没有调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>之前，就使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>关键字，结果报错，而放在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法之后就是正确的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是生成子类实例的代码。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let cp = new ColorPoint(25, 8, 'green');

cp instanceof ColorPoint // true
cp instanceof Point // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">cp</code>同时是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">最后，父类的静态方法，也会被子类继承。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  static hello() {
    console.log('hello world');
  }
}

class B extends A {
}

B.hello()  // hello world</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">hello()</code>是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>类的静态方法，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>，也继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>的静态方法。</p><h2 id="blogTitle163" class="Object-getPrototypeOf" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Object.getPrototypeOf()</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">Object.getPrototypeOf(ColorPoint) === Point
// true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="blogTitle164" class="super-关键字" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">super 关键字</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">第一种情况，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>函数。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {}

class B extends A {
  constructor() {
    super();
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的构造函数之中的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>虽然代表了父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>的构造函数，但是返回的是子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的实例，即<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>内部的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>，因此<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>在这里相当于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.constructor.call(this)</code>。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new.target</code>指向当前正在执行的函数。可以看到，在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>执行时，它指向的是子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的构造函数，而不是父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>的构造函数。也就是说，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>内部的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指向的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">作为函数时，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {}

class B extends A {
  m() {
    super(); // 报错
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super()</code>用在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">m</code>方法之中，就会造成句法错误。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">第二种情况，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>当中的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.p()</code>，就是将<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>当作一个对象使用。这时，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>在普通方法之中，指向<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype</code>，所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.p()</code>就相当于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.p()</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这里需要注意，由于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>调用的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  constructor() {
    this.p = 2;
  }
}

class B extends A {
  get m() {
    return super.p;
  }
}

let b = new B();
b.m // undefined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p</code>是父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>实例的属性，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.p</code>就引用不到它。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果属性定义在父类的原型对象上，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>就可以取到。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {}
A.prototype.x = 2;

class B extends A {
  constructor() {
    super();
    console.log(super.x) // 2
  }
}

let b = new B();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">x</code>是定义在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype</code>上面的，所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.x</code>可以取到它的值。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 规定，通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>调用父类的方法时，方法内部的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指向子类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  constructor() {
    this.x = 1;
  }
  print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  m() {
    super.print();
  }
}

let b = new B();
b.m() // 2</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.print()</code>虽然调用的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.print()</code>，但是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.print()</code>内部的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指向子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>，导致输出的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">2</code>，而不是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">1</code>。也就是说，实际上执行的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.print.call(this)</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">由于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指向子类，所以如果通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>对某个属性赋值，这时<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>就是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，赋值的属性会变成子类实例的属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.x</code>赋值为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">3</code>，这时等同于对<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this.x</code>赋值为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">3</code>。而当读取<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.x</code>的时候，读的是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.x</code>，所以返回<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">undefined</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>作为对象，用在静态方法之中，这时<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>将指向父类，而不是父类的原型对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }

  myMethod(msg) {
    console.log('instance', msg);
  }
}

class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }

  myMethod(msg) {
    super.myMethod(msg);
  }
}

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {}

class B extends A {
  constructor() {
    super();
    console.log(super); // 报错
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">console.log(super)</code>当中的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>的数据类型，就不会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {}

class B extends A {
  constructor() {
    super();
    console.log(super.valueOf() instanceof B); // true
  }
}

let b = new B();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.valueOf()</code>表明<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>是一个对象，因此就不会报错。同时，由于<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>使得<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>指向<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>，所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.valueOf()</code>返回的是一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的实例。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>关键字。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var obj = {
  toString() {
    return "MyObject: " + super.toString();
  }
};

obj.toString(); // MyObject: [object Object]</code></pre><h2 id="blogTitle165" class="类的-prototype-属性和__proto__属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">类的 prototype 属性和__proto__属性</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">大多数浏览器的 ES5 实现之中，每一个对象都有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性，指向对应的构造函数的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性。Class 作为构造函数的语法糖，同时有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性，因此同时存在两条继承链。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">（1）子类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">（2）子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性，表示方法的继承，总是指向父类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
}

class B extends A {
}

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性指向父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>，子类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性指向父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这样的结果是因为，类的继承是按照下面的模式实现的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
}

class B {
}

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 的实例继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">《对象的扩展》一章给出过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.setPrototypeOf</code>方法的实现。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">因此，就得到了上面的结果。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这两条继承链，可以这样理解：作为一个对象，子类（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>）的原型（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性）是父类（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>）；作为一个构造函数，子类（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>）的原型对象（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性）是父类的原型对象（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性）的实例。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;</code></pre><h3 id="blogTitle166" class="extends-的继承目标" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; border-top: 1px dotted rgb(119, 119, 119); color: rgb(51, 51, 51); font-family: Verdana, Arial;">extends 的继承目标</h3><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">extends</code>关键字后面可以跟多种类型的值。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class B extends A {
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>，只要是一个有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性的函数，就能被<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">B</code>继承。由于函数都有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性（除了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Function.prototype</code>函数），因此<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>可以是任意函数。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面，讨论三种特殊情况。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">第一种特殊情况，子类继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A extends Object {
}

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这种情况下，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>其实就是构造函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>的复制，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>的实例就是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>的实例。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">第二种特殊情况，不存在任何继承。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A {
}

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这种情况下，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Function.prototype</code>。但是，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>调用后返回一个空对象（即<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>实例），所以<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A.prototype.__proto__</code>指向构造函数（<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>）的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">第三种特殊情况，子类继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">null</code>。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class A extends null {
}

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === undefined // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这种情况与第二种情况非常像。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>也是一个普通函数，所以直接继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Function.prototype</code>。但是，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">A</code>调用后返回的对象不继承任何方法，所以它的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>指向<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Function.prototype</code>，即实质上执行了下面的代码。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class C extends null {
  constructor() { return Object.create(null); }
}</code></pre><h3 id="blogTitle167" class="实例的-__proto__-属性" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; border-top: 1px dotted rgb(119, 119, 119); color: rgb(51, 51, 51); font-family: Verdana, Arial;">实例的 __proto__ 属性</h3><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">子类实例的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性，指向父类实例的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, 'red');

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>，导致前者原型的原型是后者的原型。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">因此，通过子类实例的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">p2.__proto__.__proto__.printName = function () {
  console.log('Ha');
};

p1.printName() // "Ha"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">ColorPoint</code>的实例<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p2</code>上向<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>类添加方法，结果影响到了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Point</code>的实例<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">p1</code>。</p><h2 id="blogTitle168" class="原生构造函数的继承" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">原生构造函数的继承</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul style="list-style-type: none; padding-top: 0.5rem; padding-bottom: 0.5rem; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><li style="text-indent: -5px; font-size: 0.8rem;">Boolean()</li><li style="text-indent: -5px; font-size: 0.8rem;">Number()</li><li style="text-indent: -5px; font-size: 0.8rem;">String()</li><li style="text-indent: -5px; font-size: 0.8rem;">Array()</li><li style="text-indent: -5px; font-size: 0.8rem;">Date()</li><li style="text-indent: -5px; font-size: 0.8rem;">Function()</li><li style="text-indent: -5px; font-size: 0.8rem;">RegExp()</li><li style="text-indent: -5px; font-size: 0.8rem;">Error()</li><li style="text-indent: -5px; font-size: 0.8rem;">Object()</li></ul><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>的子类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function MyArray() {
  Array.apply(this, arguments);
}

MyArray.prototype = Object.create(Array.prototype, {
  constructor: {
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  }
});</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码定义了一个继承 Array 的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyArray</code>类。但是，这个类的行为与<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>完全不一致。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var colors = new MyArray();
colors[0] = "red";
colors.length  // 0

colors.length = 0;
colors[0]  // "red"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">apply</code>方法传入的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，也就是说，原生构造函数的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>无法绑定，导致拿不到内部属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES5 是先新建子类的实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>构造函数有一个内部属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">length</code>属性，这个内部属性无法在子类获取，导致子类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">length</code>属性行为不正常。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面的例子中，我们想让一个普通对象继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error</code>对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var e = {};

Object.getOwnPropertyNames(Error.call(e))
// [ 'stack' ]

Object.getOwnPropertyNames(e)
// []</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，我们想通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error.call(e)</code>这种写法，让普通对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">e</code>具有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error</code>对象的实例属性。但是，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">e</code>本身没有任何变化。这证明了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，然后再用子类的构造函数修饰<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>，使得父类的所有行为都可以继承。下面是一个继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>的例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyArray extends Array {
  constructor(...args) {
    super(...args);
  }
}

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码定义了一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyArray</code>类，继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>构造函数，因此就可以从<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Array</code>、<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">String</code>等）的子类，这是 ES5 无法做到的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面这个例子也说明，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class VersionedArray extends Array {
  constructor() {
    super();
    this.history = [[]];
  }
  commit() {
    this.history.push(this.slice());
  }
  revert() {
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  }
}

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]

x.push(3);
x // [1, 2, 3]
x.history // [[], [1, 2]]

x.revert();
x // [1, 2]</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">VersionedArray</code>会通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">commit</code>方法，将自己的当前状态生成一个版本快照，存入<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">history</code>属性。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是一个自定义<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Error</code>子类的例子，可以用来定制报错时的行为。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class ExtendableError extends Error {
  constructor(message) {
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  }
}

class MyError extends ExtendableError {
  constructor(m) {
    super(m);
  }
}

var myerror = new MyError('ll');
myerror.message // "ll"
myerror instanceof Error // true
myerror.name // "MyError"
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>的子类，有一个<a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object" style="background-position: initial; color: rgb(70, 130, 190);">行为差异</a>。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class NewObj extends Object{
  constructor(){
    super(...arguments);
  }
}
var o = new NewObj({attr: true});
o.attr === true  // false</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">NewObj</code>继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>，但是无法通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>方法向父类<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>传参。这是因为 ES6 改变了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>构造函数的行为，一旦发现<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>方法不是通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">new Object()</code>这种形式调用，ES6 规定<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object</code>构造函数会忽略参数。</p><h2 id="blogTitle169" class="Mixin-模式的实现" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Mixin 模式的实现</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const a = {
  a: 'a'
};
const b = {
  b: 'b'
};
const c = {...a, ...b}; // {a: 'a', b: 'b'}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">c</code>对象是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">a</code>对象和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">b</code>对象的合成，具有两者的接口。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function mix(...mixins) {
  class Mix {}

  for (let mixin of mixins) {
    copyProperties(Mix, mixin); // 拷贝实例属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  }

  return Mix;
}

function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== "constructor"
      &amp;&amp; key !== "prototype"
      &amp;&amp; key !== "name"
    ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class DistributedEdit extends mix(Loggable, Serializable) {
  // ...
}</code></pre></div><h1 id="blogTitle170"><b>修饰器</b><br></h1><div><ol class="content-toc" id="content-toc" style="padding-top: 0.5rem; padding-bottom: 0.5rem; background: rgb(189, 195, 199); border-radius: 5px; color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><li data-src="类的修饰" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#类的修饰" style="background-position: initial; color: rgb(70, 130, 190);">类的修饰</a></li><li data-src="方法的修饰" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#方法的修饰" style="background-position: initial; color: rgb(70, 130, 190);">方法的修饰</a></li><li data-src="为什么修饰器不能用于函数？" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#为什么修饰器不能用于函数？" style="background-position: initial; color: rgb(70, 130, 190);">为什么修饰器不能用于函数？</a></li><li data-src="core-decorators-js" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#core-decorators.js" style="background-position: initial; color: rgb(70, 130, 190);">core-decorators.js</a></li><li data-src="使用修饰器实现自动发布事件" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#使用修饰器实现自动发布事件" style="background-position: initial; color: rgb(70, 130, 190);">使用修饰器实现自动发布事件</a></li><li data-src="Mixin" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#Mixin" style="background-position: initial; color: rgb(70, 130, 190);">Mixin</a></li><li data-src="Trait" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#Trait" style="background-position: initial; color: rgb(70, 130, 190);">Trait</a></li><li data-src="Babel-转码器的支持" class="link" style="text-indent: -5px; font-size: 0.7rem; color: rgb(41, 128, 185); font-weight: bold; cursor: pointer;"><a href="http://es6.ruanyifeng.com/#docs/decorator#Babel 转码器的支持" style="background-position: initial; color: rgb(70, 130, 190);">Babel 转码器的支持</a></li></ol><h2 id="blogTitle171" class="类的修饰" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">类的修饰</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个<a href="https://github.com/tc39/proposal-decorators" style="background-position: initial; color: rgb(70, 130, 190);">提案</a>将这项功能，引入了 ECMAScript。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@testable
class MyTestableClass {
  // ...
}

function testable(target) {
  target.isTestable = true;
}

MyTestableClass.isTestable // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@testable</code>就是一个修饰器。它修改了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyTestableClass</code>这个类的行为，为它加上了静态属性<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">isTestable</code>。<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">testable</code>函数的参数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">target</code>是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyTestableClass</code>类本身。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">基本上，修饰器的行为就是下面这样。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function testable(target) {
  // ...
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">testable</code>函数的参数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">target</code>，就是会被修饰的类。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  }
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable // true

@testable(false)
class MyClass {}
MyClass.isTestable // false</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，修饰器<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">testable</code>可以接受参数，这就等于可以修改修饰器的行为。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象操作。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();
obj.isTestable // true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，修饰器函数<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">testable</code>是在目标类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象上添加属性，因此就可以在实例上调用。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是另外一个例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list)
  }
}

// main.js
import { mixins } from './mixins'

const Foo = {
  foo() { console.log('foo') }
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() // 'foo'</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码通过修饰器<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">mixins</code>，把<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>类的方法添加到了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>的实例上面。可以用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.assign()</code>模拟这个功能。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const Foo = {
  foo() { console.log('foo') }
};

class MyClass {}

Object.assign(MyClass.prototype, Foo);

let obj = new MyClass();
obj.foo() // 'foo'</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyReactComponent extends React.Component {}

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">有了装饰器，就可以改写上面的代码。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component {}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">相对来说，后一种写法看上去更容易理解。</p><h2 id="blogTitle172" class="方法的修饰" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">方法的修饰</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">修饰器不仅可以修饰类，还可以修饰类的属性。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，修饰器<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">readonly</code>用来修饰“类”的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">name</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，即类的实例（这不同于类的修饰，那种情况时<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">target</code>参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function readonly(target, name, descriptor){
  // descriptor对象原来的值如下
  // {
  //   value: specifiedFunction,
  //   enumerable: false,
  //   configurable: true,
  //   writable: true
  // };
  descriptor.writable = false;
  return descriptor;
}

readonly(Person.prototype, 'name', descriptor);
// 类似于
Object.defineProperty(Person.prototype, 'name', descriptor);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是另一个例子，修改属性描述对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">enumerable</code>属性，使得该属性不可遍历。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Person {
  @nonenumerable
  get kidCount() { return this.children.length; }
}

function nonenumerable(target, name, descriptor) {
  descriptor.enumerable = false;
  return descriptor;
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@log</code>修饰器，可以起到输出日志的作用。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

function log(target, name, descriptor) {
  var oldValue = descriptor.value;

  descriptor.value = function() {
    console.log(`Calling "${name}" with`, arguments);
    return oldValue.apply(null, arguments);
  };

  return descriptor;
}

const math = new Math();

// passed parameters should get logged now
math.add(2, 4);</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@log</code>修饰器的作用就是在执行原始的操作之前，执行一次<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">console.log</code>，从而达到输出日志的目的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">修饰器有注释的作用。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@testable
class Person {
  @readonly
  @nonenumerable
  name() { return `${this.first} ${this.last}` }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">从上面代码中，我们一眼就能看出，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Person</code>类是可测试的，而<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">name</code>方法是只读和不可枚举的。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是使用 Decorator 写法的<a href="https://github.com/ionic-team/stencil" style="background-position: initial; color: rgb(70, 130, 190);">组件</a>，看上去一目了然。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@Component({
  tag: 'my-component',
  styleUrl: 'my-component.scss'
})
export class MyComponent {
  @Prop() first: string;
  @Prop() last: string;
  @State() isVisible: boolean = true;

  render() {
    return (
      &lt;p&gt;Hello, my name is {this.first} {this.last}&lt;/p&gt;
    );
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function dec(id){
  console.log('evaluated', id);
  return (target, property, descriptor) =&gt; console.log('executed', id);
}

class Example {
    @dec(1)
    @dec(2)
    method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，外层修饰器<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@dec(1)</code>先进入，但是内层修饰器<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">@dec(2)</code>先执行。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h2 id="blogTitle173" class="为什么修饰器不能用于函数？" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">为什么修饰器不能用于函数？</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var counter = 0;

var add = function () {
  counter++;
};

@add
function foo() {
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面的代码，意图是执行后<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">counter</code>等于 1，但是实际上结果是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@add
function foo() {
}

var counter;
var add;

counter = 0;

add = function () {
  counter++;
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面是另一个例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var readOnly = require("some-decorator");

@readOnly
function foo() {
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码也有问题，因为实际执行是下面这样。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">var readOnly;

@readOnly
function foo() {
}

readOnly = require("some-decorator");</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">function doSomething(name) {
  console.log('Hello, ' + name);
}

function loggingDecorator(wrapped) {
  return function() {
    console.log('Starting');
    const result = wrapped.apply(this, arguments);
    console.log('Finished');
    return result;
  }
}

const wrapped = loggingDecorator(doSomething);</code></pre><h2 id="blogTitle174" class="core-decorators-js" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">core-decorators.js</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><a href="https://github.com/jayphelps/core-decorators.js" style="background-position: initial; color: rgb(70, 130, 190);">core-decorators.js</a>是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（1）@autobind</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">autobind</code>修饰器使得方法中的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">this</code>对象，绑定原始对象。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { autobind } from 'core-decorators';

class Person {
  @autobind
  getPerson() {
    return this;
  }
}

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（2）@readonly</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">readonly</code>修饰器使得属性或方法不可写。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { readonly } from 'core-decorators';

class Meal {
  @readonly
  entree = 'steak';
}

var dinner = new Meal();
dinner.entree = 'salmon';
// Cannot assign to read only property 'entree' of [object Object]</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（3）@override</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">override</code>修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { override } from 'core-decorators';

class Parent {
  speak(first, second) {}
}

class Child extends Parent {
  @override
  speak() {}
  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)
}

// or

class Child extends Parent {
  @override
  speaks() {}
  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.
  //
  //   Did you mean "speak"?
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（4）@deprecate (别名@deprecated)</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">deprecate</code>或<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">deprecated</code>修饰器在控制台显示一条警告，表示该方法将废除。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { deprecate } from 'core-decorators';

class Person {
  @deprecate
  facepalm() {}

  @deprecate('We stopped facepalming')
  facepalmHard() {}

  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })
  facepalmHarder() {}
}

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: We stopped facepalming

person.facepalmHarder();
// DEPRECATION Person#facepalmHarder: We stopped facepalming
//
//     See http://knowyourmeme.com/memes/facepalm for more details.
//</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><strong>（5）@suppressWarnings</strong></p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">suppressWarnings</code>修饰器抑制<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">deprecated</code>修饰器导致的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">console.warn()</code>调用。但是，异步代码发出的调用除外。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { suppressWarnings } from 'core-decorators';

class Person {
  @deprecated
  facepalm() {}

  @suppressWarnings
  facepalmWithoutWarning() {
    this.facepalm();
  }
}

let person = new Person();

person.facepalmWithoutWarning();
// no warning is logged</code></pre><h2 id="blogTitle175" class="使用修饰器实现自动发布事件" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">使用修饰器实现自动发布事件</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const postal = require("postal/lib/postal.lodash");

export default function publish(topic, channel) {
  const channelName = channel || '/';
  const msgChannel = postal.channel(channelName);
  msgChannel.subscribe(topic, v =&gt; {
    console.log('频道: ', channelName);
    console.log('事件: ', topic);
    console.log('数据: ', v);
  });

  return function(target, name, descriptor) {
    const fn = descriptor.value;

    descriptor.value = function() {
      let value = fn.apply(this, arguments);
      msgChannel.publish(topic, value);
    };
  };
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码定义了一个名为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">publish</code>的修饰器，它通过改写<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">descriptor.value</code>，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是<a href="https://github.com/postaljs/postal.js" style="background-position: initial; color: rgb(70, 130, 190);">Postal.js</a>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">它的用法如下。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">// index.js
import publish from './publish';

class FooComponent {
  @publish('foo.some.message', 'component')
  someMethod() {
    return { my: 'data' };
  }
  @publish('foo.some.other')
  anotherMethod() {
    // ...
  }
}

let foo = new FooComponent();

foo.someMethod();
foo.anotherMethod();</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">以后，只要调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">someMethod</code>或者<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">anotherMethod</code>，就会自动发出一个事件。</p><pre class=" language-bash" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-bash" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">$ bash-node index.js
频道:  component
事件:  foo.some.message
数据:  { my: 'data' }

频道:  /
事件:  foo.some.other
数据:  undefined</code></pre><h2 id="blogTitle176" class="Mixin" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Mixin</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">在修饰器的基础上，可以实现<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Mixin</code>模式。所谓<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Mixin</code>模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">请看下面的例子。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">const Foo = {
  foo() { console.log('foo') }
};

class MyClass {}

Object.assign(MyClass.prototype, Foo);

let obj = new MyClass();
obj.foo() // 'foo'</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码之中，对象<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>有一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法，通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Object.assign</code>方法，可以将<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法“混入”<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>类，导致<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>的实例<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">obj</code>对象都具有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法。这就是“混入”模式的一个简单实现。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面，我们部署一个通用脚本<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">mixins.js</code>，将 Mixin 写成一个修饰器。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">然后，就可以使用上面这个修饰器，为类“混入”各种方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { mixins } from './mixins';

const Foo = {
  foo() { console.log('foo') }
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() // "foo"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">mixins</code>这个修饰器，实现了在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>类上面“混入”<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">Foo</code>对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">不过，上面的方法会改写<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">prototype</code>对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass extends MyBaseClass {
  /* ... */
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyBaseClass</code>。如果我们想在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>里面“混入”一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法，一个办法是在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyBaseClass</code>之间插入一个混入类，这个类具有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法，并且继承了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyBaseClass</code>的所有方法，然后<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>再继承这个类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let MyMixin = (superclass) =&gt; class extends superclass {
  foo() {
    console.log('foo from MyMixin');
  }
};</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyMixin</code>是一个混入类生成器，接受<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">superclass</code>作为参数，然后返回一个继承<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">superclass</code>的子类，该子类包含一个<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">接着，目标类再去继承这个混入类，就达到了“混入”<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法的目的。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass extends MyMixin(MyBaseClass) {
  /* ... */
}

let c = new MyClass();
c.foo(); // "foo from MyMixin"</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">如果需要“混入”多个方法，就生成多个混入类。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">class MyClass extends Mixin1(Mixin2(MyBaseClass)) {
  /* ... */
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这种写法的一个好处，是可以调用<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super</code>，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">let Mixin1 = (superclass) =&gt; class extends superclass {
  foo() {
    console.log('foo from Mixin1');
    if (super.foo) super.foo();
  }
};

let Mixin2 = (superclass) =&gt; class extends superclass {
  foo() {
    console.log('foo from Mixin2');
    if (super.foo) super.foo();
  }
};

class S {
  foo() {
    console.log('foo from S');
  }
}

class C extends Mixin1(Mixin2(S)) {
  foo() {
    console.log('foo from C');
    super.foo();
  }
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，每一次<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">混入</code>发生时，都调用了父类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">super.foo</code>方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">new C().foo()
// foo from C
// foo from Mixin1
// foo from Mixin2
// foo from S</code></pre><h2 id="blogTitle177" class="Trait" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Trait</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">下面采用<a href="https://github.com/CocktailJS/traits-decorator" style="background-position: initial; color: rgb(70, 130, 190);">traits-decorator</a>这个第三方模块作为例子。这个模块提供的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">traits</code>修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { traits } from 'traits-decorator';

class TFoo {
  foo() { console.log('foo') }
}

const TBar = {
  bar() { console.log('bar') }
};

@traits(TFoo, TBar)
class MyClass { }

let obj = new MyClass();
obj.foo() // foo
obj.bar() // bar</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，通过<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">traits</code>修饰器，在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>类上面“混入”了<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TFoo</code>类的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>对象的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar</code>方法。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Trait 不允许“混入”同名方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { traits } from 'traits-decorator';

class TFoo {
  foo() { console.log('foo') }
}

const TBar = {
  bar() { console.log('bar') },
  foo() { console.log('foo') }
};

@traits(TFoo, TBar)
class MyClass { }
// 报错
// throw new Error('Method named: ' + methodName + ' is defined twice.');
//        ^
// Error: Method named: foo is defined twice.</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码中，<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TFoo</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>都有<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法，结果<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">traits</code>修饰器报错。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">一种解决方法是排除<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { traits, excludes } from 'traits-decorator';

class TFoo {
  foo() { console.log('foo') }
}

const TBar = {
  bar() { console.log('bar') },
  foo() { console.log('foo') }
};

@traits(TFoo, TBar::excludes('foo'))
class MyClass { }

let obj = new MyClass();
obj.foo() // foo
obj.bar() // bar</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码使用绑定运算符（::）在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>上排除<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法，混入时就不会报错了。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">另一种方法是为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法起一个别名。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">import { traits, alias } from 'traits-decorator';

class TFoo {
  foo() { console.log('foo') }
}

const TBar = {
  bar() { console.log('bar') },
  foo() { console.log('foo') }
};

@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))
class MyClass { }

let obj = new MyClass();
obj.foo() // foo
obj.aliasFoo() // foo
obj.bar() // bar</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法起了别名<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">aliasFoo</code>，于是<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">MyClass</code>也可以混入<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">TBar</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法了。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">alias</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">excludes</code>方法，可以结合起来使用。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))
class MyClass {}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">上面代码排除<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">了TExample</code>的<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">foo</code>方法和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">bar</code>方法，为<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">baz</code>方法起了别名<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">exampleBaz</code>。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;"><code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">as</code>方法则为上面的代码提供了另一种写法。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">@traits(TExample::as({excludes:['foo', 'bar'], alias: {baz: 'exampleBaz'}}))
class MyClass {}</code></pre><h2 id="blogTitle178" class="Babel-转码器的支持" style="margin-top: 50px; margin-bottom: 0px; padding-top: 20px; padding-bottom: 0px; font-size: 18px; border-top: 2px solid rgb(102, 102, 102); counter-increment: section 1; color: rgb(51, 51, 51); font-family: Verdana, Arial;">Babel 转码器的支持</h2><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">目前，Babel 转码器已经支持 Decorator。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">首先，安装<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">babel-core</code>和<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">babel-plugin-transform-decorators</code>。由于后者包括在<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">babel-preset-stage-0</code>之中，所以改为安装<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">babel-preset-stage-0</code>亦可。</p><pre class=" language-bash" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-bash" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">$ npm install babel-core babel-plugin-transform-decorators</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">然后，设置配置文件<code style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(199, 37, 78); background: rgb(249, 242, 244); border-radius: 2px; padding-left: 3px; padding-right: 3px;">.babelrc</code>。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">{
  "plugins": ["transform-decorators"]
}</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">这时，Babel 就可以对 Decorator 转码了。</p><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">脚本中打开的命令如下。</p><pre class=" language-javascript" style="font-family: Consolas, Monaco, &quot;Andale Mono&quot;, monospace; font-size: 14.336px; color: rgb(255, 255, 255); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-break: normal; hyphens: none; padding-right: 1em; padding-left: 0.7rem; margin: 0.5em auto; border-radius: 5px; background-color: rgb(17, 17, 17); line-height: 1.2;"><code class=" language-javascript" style="font-family: Consolas, &quot;Courier New&quot;, Courier, FreeMono, monospace; font-size: 0.7rem; color: rgb(166, 226, 46); text-shadow: rgba(0, 0, 0, 0.3) 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; hyphens: none; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; border-radius: 2px;">babel.transform("code", {plugins: ["transform-decorators"]})</code></pre><p style="color: rgb(51, 51, 51); font-family: Verdana, Arial; font-size: 14.336px;">Babel 的官方网站提供一个<a href="https://babeljs.io/repl/" style="background-position: initial; color: rgb(70, 130, 190);">在线转码器</a>，只要勾选 Experimental，就能支持 Decorator 的在线转码。</p></div><h2 id="blogTitle179"><span style="font-weight: 700;">继承 -&nbsp;</span>面向对象编程的三大特性</h2><div><ul><li>基类 &nbsp;父类 &nbsp;子类 &nbsp;派生类</li><li>继承就是定义一个新的对象，继承另一个对象的方法和属性</li><li>JS 中万物都继承自 object.prototype</li></ul></div><div><p style="margin-bottom: 24px; padding: 0px; border: 0px;">所有的 JavaScript 对象继承于至少一个对象。被继承的对象被称作原型，并且继承的属性可通过构造函数的&nbsp;<span style="border-style: initial; border-color: initial;">prototype</span>&nbsp;对象找到。查看更多详细&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" style="margin: 0px; padding: 0px; border: 0px;">Inheritance and the prototype chain</a></p></div><h3 id="blogTitle180"><b>继承的好处</b></h3><div><div>核心：</div><div><ul><li>模块化编程，降低耦合<br></li><li>应对需求变化：随着时间流逝，产品需求可能对你类的行为有更多的要求<br></li></ul></div><div>其他好处</div><div><ul><li>扩展功能<br></li><li>修改功能<br></li><li>通过继承实现代码重用</li></ul></div></div><h3 id="blogTitle181"><span style="font-weight: 700;">ES 继承机制实现</span></h3><div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">选定基类后，就可以创建它的子类了。是否使用基类完全由你决定。有时，你可能想创建一个不能直接使用的基类，它只是用于给子类提供通用的函数。在这种情况下，基类被看作抽象类。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">尽管 ECMAScript 并没有像其他语言那样严格地定义抽象类，但有时它的确会创建一些不允许使用的类。通常，我们称这种类为抽象类。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。记住，所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。</p><h4 id="blogTitle182">ES 继承机制实现实例</h4><div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">说明继承机制最简单的方式是，利用一个经典的例子 - 几何形状。实际上，几何形状只有两种，即椭圆形（是圆形的）和多边形（具有一定数量的边）。圆是椭圆的一种，它只有一个焦点。三角形、矩形和五边形都是多边形的一种，具有不同数量的边。正方形是矩形的一种，所有的边等长。这就构成了一种完美的继承关系。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在这个例子中，形状（Shape）是椭圆形（Ellipse）和多边形（Polygon）的基类（base class）（所有类都由它继承而来）。椭圆具有一个属性&nbsp;<span style="border-style: initial; border-color: initial; border-image: initial;">foci</span>，说明椭圆具有的焦点的个数。圆形（Circle）继承了椭圆形，因此圆形是椭圆形的子类（subclass），椭圆形是圆形的超类（superclass）。同样，三角形（Triangle）、矩形（Rectangle）和五边形（Pentagon）都是多边形的子类，多边形是它们的超类。最后，正方形（Square）继承了矩形。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">最好用图来解释这种继承关系，这是 UML（统一建模语言）的用武之地。UML 的主要用途之一是，可视化地表示像继承这样的复杂对象关系。下面的图示是解释 Shape 和它的子类之间关系的 UML 图示：</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk8AAAGYCAYAAABbFAZkAAAgAElEQVR4Xu3dPXosNdu14SZjCJBBxhAgJIMMMqbBCIARMA0yyCAjhCGQQQZDIPN3NN9jXu/GP6oq3ZaW6nQCx7Z+lq51l7Ra3bbfuru7u7v4QgABBBBAAAEEEGgi8Jbw1MRJIwQQQAABBBBA4B8CwpNCQAABBBBAAAEENhAQnjbA0hQBBBBAAAEEEBCe1AACCCCAAAIIILCBgPC0AZamCCCAAAIIIICA8KQGEEAAAQQQQACBDQSEpw2wNB1H4K233ho3uZkPEfDbUA7h0xkBBCYkIDxNaApJ/yVwDU8O4bzK4FueZxQjgMDLBISnlxlpMQEBh/AEJuyQwLcd0HRBAIHpCQhP01tE4JWAQzizDviW6RvVCCDwPAHhSYVEEHAIR9j0H5F8y/SNagQQEJ7UwAIEVjiEb9fw2Jpa2iTZuYJvSbxpRQCB1yHg5ul1OJvlIIG0Q/i5nw68/+D7lvCUtv57u1N1HyxX3RFAYHECwtPiBq+yvNRD+KHup/7/6tH99567eUpkkKh5lWfGOhBAoI6A8FTH1sgdCaQewo8FpqfWcn9bdb2Zarm56oi3bKhU38qAGBgBBJYgIDwtYeP6i0g7hFvCz5a37VIdTvMtlTPdCCDwugSEp9flbbadBFIP4da37e6x+MD4zgLRDQEEEHhFAsLTK8I21X4CK4WnlrftHoap6/+n/nb1VN/2V6qeCCBwBgLC0xlcXmCNqYfw7c3TbRC6/aD4ls9IJdia6lsCWxoRQGAcAeFpHHszbyCQeAi/9BbcS595eu6n8zagG9o00behwEyOAAIRBISnCJuITDyEnwpPD3+q7tbZ25uoh99fgYFKRgABBFYgIDyt4OIJ1pAWHJ66Vbp92+6x8PRcmxU4nKBcLREBBBYnIDwtbvAqy0sLDatwP7oOvh0lqD8CCMxIQHia0RWa/kPAIZxZFHzL9I1qBBB4noDwpEIiCDiEI2wSejNtohoBBDYSEJ42AtN8DAHhaQz3o7Py7ShB/RFAYEYCwtOMrtDkBmORGhCeFjHSMhBA4A0CwpOCiCBw/+P9EWKJfINA6m9HZyMCCCDwFAHhSW1EEHCDEWGTG8NMm6hGAIGNBISnjcA0H0NAeBrD/eisfDtKUH8EEJiRgPA0oys0ucFYpAaEp0WMtAwEEHiDgPCkICIIOIQjbBJ6M22iGgEENhIQnjYC03wMAeFpDPejs/LtKEH9EUBgRgLC04yu0OQGY5EaEJ4WMdIyEEDA23ZqII+AQzjPs6tivmX6RjUCCDxPwM2TCokg4BCOsMmNYaZNVCOAwEYCwtNGYJqPISA8jeF+dFa+HSWoPwIIzEhAeJrRFZrcYCxSA8LTIkZaBgIIvEFAeFIQEQQcwhE2Cb2ZNlGNAAIbCQhPG4FpPoaA8DSG+9FZ+XaUoP4IIDAjAeFpRldocoOxSA0IT4sYaRkIIOBtOzWQR8AhnOfZVTHfMn2jGgEEnifg5kmFRBBwCEfY5MYw0yaqEUBgIwHhaSMwzccQEJ7GcD86K9+OEtQfAQRmJCA8zegKTW4wFqkB4WkRIy0DAQTeICA8KYgIAg7hCJuE3kybqEYAgY0EhKeNwDQfQ0B4GsP96Kx8O0pQfwQQmJGA8DSjKzS5wVikBoSnRYy0DAQQ8LadGsgj4BDO8+yqmG+ZvlGNAALPE3DzpEIiCDiEI2xyY5hpE9UIILCRgPC0EZjmYwgIT2O4H52Vb0cJ6o8AAjMSEJ5mdIUmNxiL1IDwtIiRloEAAm8QEJ4URAQBh3CETUJvpk1UI4DARgLC00Zgmo8hIDyN4X50Vr4dJag/AgjMSEB4mtEVmtxgLFIDwtMiRloGAgh4204N5BFwCOd5dlXMt0zfqEYAgecJuHlSIREEHMIRNrkxzLSJagQQ2EhAeNoITPMxBISnMdyPzsq3owT1RwCBGQkITzO6QpMbjEVqQHhaxEjLQACBNwgITwoigoBDOMImoTfTJqoRQGAjAeFpIzDNxxAQnsZwPzor344S1B8BBGYkIDzN6ApNbjAWqQHhaREjLQMBBLxtpwbyCDiE8zy7KuZbpm9UI4DA8wTcPKmQCAIO4Qib3Bhm2kQ1AghsJCA8bQSm+RgCwtMY7kdn5dtRgvojgMCMBISnGV2hyQ3GIjUgPC1ipGUggMAbBIQnBRFBwCEcYZPQm2kT1QggsJGA8LQRmOZjCAhPY7gfnZVvRwnqjwACMxIQnmZ0hSY3GIvUgPC0iJGWgQAC3rZTA3kEHMJ5nl0V8y3TN6oRQOB5Am6eVEgEAYdwhE1uDDNtohoBBDYSEJ42AtN8DAHhaQz3o7Py7ShB/RFAYEYCwtOMrtDkBmORGhCeFjHSMhBA4A0CwpOCiCDgEI6wSejNtIlqBBDYSEB42ghM8zEEhKcx3I/OyrejBPVHAIEZCQhPM7pCkxuMRWpAeFrESMtAAAFv26mBPAIO4TzPror5lukb1Qgg8DwBN08qJIKAQzjCJjeGmTZRjQACGwkITxuBaT6GgPA0hvvRWfl2lKD+CCAwIwHhaUZXaHKDsUgNCE+LGGkZCCDwBgHhSUFEEHAIR9gk9GbaRDUCCGwkIDxtBKb5GALC0xjuR2fl21GC+iOAwIwEhKcZXaHJDcYiNSA8LWKkZSCAgLft1EAeAYdwnmdXxXzL9I1qBBB4noCbJxUSQcAhHGGTG8NMm6hGAIGNBISnjcA0H0PgGp58ZRK4u7vLFE41Aggg8AQB4UlpIDCYwMcff3z5+eefB6swPQIIIIBAKwHhqZWUdggUEPjhhx8un3/++eX777+/fPbZZwUzGBIBBBBAoDcB4ak3UeMhsIHANThdA9Q1OF0DlC8EEEAAgfkJCE/ze0ThogT++uuvy7vvvvvv6v7888/LO++8s+hqLQsBBBBYh4DwtI6XVhJG4Ouvv7588803/6r+6quvLtd/84UAAgggMDcB4Wluf6hblMDff/99ef/99y/X26f7r+ut0++//355++23F121ZSGAAAJrEBCe1vDRKsII3H9Q/Fa2D46HGUkuAgickoDwdErbLXo0gU8//fTy008/XT788MPLr7/++u9/P/nkk8uPP/44Wp75EUAAAQSeISA8KQ8EXpnAH3/8cfnoo48u33777eWLL77490+YfPfdd5cvv/zy8ssvv1zee++9V1ZlOgQQQACBVgLCUysp7RDoROC33377Jxzdf7bp4Z+euX4W6hquPvjgg06zGQYBBBBAoDcB4ak3UeMhsJGAv9u3EZjmCCCAwGACwtNgA0yPgPCkBhBAAIEsAsJTll/ULkhAeFrQVEtCAIGlCQhPS9trcQkEhKcEl2hEAAEE/o+A8KQaEBhMQHgabIDpEUAAgY0EhKeNwDRHoDcB4ak3UeMhgAACtQSEp//xvR5gvhBAAIEzEri7uzvjsq0Zgd0EhKcH4ckGsruOdEQAgVACbj5DjSN7KAHhSXgaWoAmRwCBsQSEp7H8zZ5JQHgSnjIrl2oEEOhCQHjqgtEgJyMgPAlPJyt5y0UAgYcEhCf1gMB2AsKT8LS9avRAAIFlCAhPy1hpIa9IQHgSnl6x3EyFAAKzERCeZnOEngQCwpPwlFCnNCKAQBEB4akIrGGXJiA8CU9LF7jFIYDA8wSEJxWCwHYCwpPwtL1q9EAAgWUICE/LWGkhr0igOTz5Ddyv6Ernqfzyz85ADXcqAva+XLvtfbneza58U3hSiLPb+V99XlXmeUbxXAQ8Q3P50aqGb62ktNtDQHjaQy2ojw0kyCxSpyTgGZrSlhdF8e1FRBocICA8HYCX0NUGkuASjTMT8AzN7M7T2viW6VuKauEpxamdOm0gO8HphsD/CHiGMkuBb5m+paheOjw99/A89r3WD4YmffbLBpLyKNI5K4GkZ+glrU/te6172m3/l+Yb6enM2kZyMXcfAqcJTw+D0XWj2LuJpD2QaXr7lLVREOhHIOUZeurF320wei4APfzecy8m78ecmc3M2vpVp5FGEVg2PD324N+HplvYtxvBU32v/dIeyDS9ox4E8yLwFIGEZ+h+z3oYlJ7Sff/vLeHods+7DVetN1YjqivBtxFczNmHwLLh6amH/rFN5h7lw03lqU0o7YFM09unrI2CQD8CMz9Dt/vZU3vYczReCkSPfX9mJrf7eb9KMBIC/0dg+fB0XerDG6fHbp9abp4ejjPzq63b4k7Y5DyQCMxMIOUZeniT9Nge9dQLx6fCU8vN1MxsZtY2c73T1kZg2fD0cKN46v+fu5166nMCaQ9kmt62stUKgdcjMPMzdBuYXtL62Pf33Dzd7p2v50b7TC+xaB9JSwT+S+AU4enhg/7Yq6nHbp5uP1S+5zp8hoKzgczgAg3JBFKeoT03Rbdraw1XCUwSNCY/F2fXvmx4euxW6aHZj/20yG1Aur2xeuqn9GYuIhvIzO7QlkAg4Rl6SuNz4eiloHTvze3N1PXfWz6YPtrbBN9GMzL/fgKnCk8PA1NrkHrqrb39yF+3pw3kdXmbbT0CMz9Dj73Au9+zbkPO7Q38Y/vhll9rcLs3zub8zL7Nxoqe7QROG55abp4e4vS23fbi0gOBFQgkHcIPw9Qt+z172FM3V8/NM4vnSb7NwoyOdgKnDk+3G8Bznxl47KaqHfO4ljaQcezNvAaBWZ+hx/ar534S+LG3355y6LlfJPzYjdaMTs/q24ysaNpOYOnwtB3Hej1sIOt5akWvS8Az9Lq8e83Gt14kjfMYAeFp8bqwgSxusOWVE/AMlSMumYBvJVgN+j8CwtPipWADWdxgyysn4BkqR1wyAd9KsBpUeDpHDdhAzuGzVdYR8AzVsa0cmW+VdI3t5mnxGrCBLG6w5ZUT8AyVIy6ZgG8lWA265+YJtUwCSX+LL5Mw1SsTaP0p3JUZpK7N3pfq3Py63TzN79EhhV59HcKnMwIXz1BmEfAt07cU1cJTilM7ddpAdoLTDYH76/m33nrjz5EAk0HA3pfhU6pK4SnVuUbdNpBGUJoh8AQBz1BmafAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRbXwlOLUTp02kJ3gdEPAzVN0Ddj7ou2bXrzwNL1FxwTaQI7x0xsBz1BmDfAt07cU1cJTilM7ddpAdoLTDQE3T9E1YO+Ltm968cLT9BYdE2gDOcZPbwQ8Q5k1wLdM31JUC08pTu3UaQPZCU43BNw8RdeAvS/avunFC0/TW3RMoA3kGD+9EfAMZdYA3zJ9S1EtPKU4tVOnDWQnON0QcPMUXQP2vmj7phcvPE1v0TGBNpBj/PRGwDOUWQN8y/QtRfWm8JSyKDrfJHB3dwcJAgjsJHA9hH1lErD3ZfqWoLo5PCUs5ojGjz/++PLzzz8fGUJfBBBAII6AvS/OMoInICA8XS6XH3744fL5559fvv/++8tnn302gS0kIIAAAvUE7H31jM2wJgHh6XL5JzhdN5FrcLoGKF8IIIDAGQjY+87gsjVWEDh9ePrrr78u77777r9s//zzz8s777xTwdqYCCCAwDQE7H3TWEFIIIHTh6evv/768s033/xr3VdffXW5/psvBBBAYGUC9r6V3bW2agKnDk9///335f33379cX4Hdf11vnX7//ffL22+/Xc3e+AgggMAQAva+IdhNuhCBU4en+w9L3vrpg+MLVbilIIDAfwjY+xQFAscInDo8ffrpp5effvrp8uGHH15+/fXXf//7ySefXH788cdjZPVGAAEEJiVg75vUGLJiCJw2PP3xxx+Xjz766PLtt99evvjii8v9b6P97rvvLl9++eXll19+ubz33nsxRhKKAAIItBCw97VQ0gaB5wmcNjz99ttv/4Sj+882PfxV/tfPA1w3mA8++ED9IIAAAksRsPctZafFDCJw2vB0y9vfQRpUgaZFAIGhBOx9Q/GbPJSA8PQ/42wgoRVMNgIIHCJg7zuET+eTEhCehKeTlr5lI4DAlYDwpA4Q2E5AeBKetleNHgggsAwB4WkZKy3kFQkIT8LTK5abqRBAYDYCwtNsjtCTQEB4Ep4S6pRGBBAoIiA8FYE17NIEhCfhaekCt7j/Ergelr4QQACBpwjc3d2B8wIB4Ul48pCcjICbhpMZbrkIbCBgf2iDJTwJT22VotUyBGyOy1hpIQh0J2B/aEMqPAlPbZWi1TIEbI7LWGkhCHQnYH9oQyo8CU9tlaLVMgRsjstYaSEIdCdgf2hDKjwJT22VotUyBGyOy1hpIQh0J2B/aEMqPAlPbZWi1TIEbI7LWGkhCHQnYH9oQyo8CU9tlaLVMgRsjstYaSEIdCdgf2hDKjwJT22VotUyBGyOy1hpIQh0J2B/aEMqPAlPbZWi1TIEbI7LWGkhCHQnYH9oQyo8CU9tlaLVMgRsjstYaSEIdCdgf2hD2hye/EmHNqAztvKr9re5ota38ZqpdUWtq4eZHN6mRT1s47V66571sCk89Zx4dZNmWZ9XEdudwGw7sxl6VPlWNe4MzFbWUOVb1bgrezHD2nr7JjzN4Gqhht4FUyh1mqExm8aKTUKqfKsad9PiNN5MoMq3qnE3L1CHTQR6+yY8bcKf17h3weQR2K4Ys+3MZuhR5VvVuDMwW1lDlW9V467sxQxr6+2b8DSDq4UaehdModRphsZsGis2CanyrWrcTYvTeDOBKt+qxt28QB02Eejt2ynDU+sHQFf4jFfvgtlUraGNU5k9p3vvmm777R3nNUqhSlvVuJVMHvPtsfme2uOSfH+KY5VvVeP2qIeWs+2h54+tZcv6kupky7pavDhteHopGPUG3WJGRZtV1lHB5rU33R5r2Lo53s/5WL/bZ+C5se/bzlxPVdqqxu1RD601/FKwfmqcBN9bGfTinVIPrTqfC0APv2d/eLOCTh2enjtQWguv1wNZNc4q66ji89i4qzHb+urwdsNMOUCrfKsat6qmnzrktrxgfKoGqjRXjFvlW9W4vRm06rxv1xKOrhrtD//fqdOHp6euMFsLr3fB9x5vlXX05vLceCsx23NT9djmmMCkSmPVuFU1/fAwfBh8b+d77ObxNiinrf3hGqu0V43bux726nwpONsfhKd/EvRjX9cNZG/h9X4Ajo63yjqOctjSfxVmTx2iz71gSH77psq3qnG31OSets8dgrffS/b9Ke1VvlWNu8fj2z4vvVi6ffav/VtC9P2NU3Kd9PbNzdPd3Rv18NiB06OoR43Ru2BGreM1552d2XMb5GNvzWzZUO83ycfeqkvg8tJbU3vqaPZ1tx6gWz4o/NLtwx6Or92nyreqcXvzudX5mO6X/m3L92fn0luf8HRzyyQ89X6E88br/ZCNJtB6A3Gv87H2CUyqNFaNW10XZ/HdzdPjBPaEp619ks7L3s+x8PS/8HR/fZlUDC2bb++CaZkzvc1qzI7ePN1e7c/Kp0pX1bjVz8lteLqd76W3a1J8F57+S+ClG6PnXig9HO2lce73lpduNatrvWX83s/xqcNT8lsULcVyu77WPmdv1/shG81zyw3ES688Z2ZTpa1q3Mq6uH0R+NIakn0Xno6Hp6eC9nMB+7Hz5aU6q6z5l8bure3U4em5VN0b9EvGVn1/lXVU8Xls3GRmWw/B1vaPvcJ8TU9a5qryrWrcljXtbfPYYfjc58GeqoME34WnfeHpNmC31FpynfR+jk8bnloKpeLDpy3z9mzTu2B6apt1rFmZ3R9kLdye+onRhxvm/TjP/R6npMOzyreqcVt83NPmqReFj431XJ1c2yfvgVW+VY27x+uHfY7sDy/1XaFOevt2yvB0tEiT+vcumKS179WK2V5yY/tV+VY17lha689e5VvVuOs7MnaFvX0Tnsb6WT5774IpFzzBBJhNYMIOCVW+VY27Y4m6bCBQ5VvVuBuWpukOAr19E552mJDUpXfBJK19r1bM9pIb26/Kt6pxx9Jaf/Yq36rGXd+RsSvs7ZvwNNbP8tl7F0y54AkmwGwCE3ZIqPKtatwdS9RlA4Eq36rG3bA0TXcQ6O2b8LTDhKQuvQsmae17tWK2l9zYflW+VY07ltb6s1f5VjXu+o6MXWFv3zaFp7FLN/teAsk/MbN3zUf6XR8yX5kEKmpdPWTWwlW1esj1rkJ5z3rYFJ56TlwBxpj/JdA7bZ+BMWaZLlf5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObvukhUQAAA7PSURBVIhZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fhKfMOmhW3btgmicObohZpnlVvlWNm0k5R3WVb1Xj5pDNVNrbN+Epsw6aVfcumOaJgxtilmlelW9V42ZSzlFd5VvVuDlkM5X29k14yqyDZtW9C6Z54uCGmGWaV+Vb1biZlHNUV/lWNW4O2UylvX0TnjLroFl174Jpnji4IWaZ5lX5VjVuJuUc1VW+VY2bQzZTaW/fNoWnTGRU393dgbCBwPUh85VJoKLW1UNmLVxVq4dc7yqU96yH5vBUsRBjIoAAAgiMJfDxxx9ffv7557EizI5AGAHhKcwwchFAAIFeBH744YfL559/fvn+++8vn332Wa9hjYPA8gSEp+UttkAEEEDgcQLX4HQNUNfgdA1QvhBAoI2A8NTGSSsEEEBgKQJ//fXX5d133/13TX/++eflnXfeWWqNFoNAFQHhqYqscRFAAIGJCXz99deXb7755l+FX3311eX6b74QQOBlAsLTy4y0QAABBJYi8Pfff1/ef//9y/X26f7reuv0+++/X95+++2l1moxCFQQEJ4qqBoTAQQQmJjA/QfFbyX64PjEppE2FQHhaSo7iEEAAQTqCXz66aeXn3766fLhhx9efv3113//+8knn1x+/PHHegFmQCCcgPAUbiD5CCCAwBYCf/zxx+Wjjz66fPvtt5cvvvjicv+bl7/77rvLl19+efnll18u77333pYhtUXgdASEp9NZbsEIIHBmAr/99ts/4ej+s00P/2zF9bNQ13D1wQcfnBmRtSPwIgHh6UVEGiCAAALrEuj9N7/WJWVlCPwfAeFJNSCAAAInJiA8ndh8S99NQHjajU5HBBBAIJ+A8JTvoRW8PgHh6fWZmxEBBBCYhoDwNI0VhAQREJ6CzCIVAQQQ6E1AeOpN1HhnICA8ncFla0QAAQSeICA8KQ0EthMQnrYz0wMBBBBYhoDwtIyVFvKKBISnV4RtKgQQQGA2AsLTbI7Qk0BAeEpwiUYEEECgiIDwVATWsEsTEJ6WttfiEEAAgecJCE8qBIHtBISn7cz0QAABBJYhIDwtY6WFvCIB4ekVYZsKAQQQmI2A8DSbI/QkEBCeElyiEQEEECgiIDwVgTXs0gSEp6XttTgEEEDgeQLCkwpBYDsB4Wk7Mz0QQACBZQgIT8tYaSGvSEB4ekXYpkIAAQRmIyA8zeYIPQkEhKcEl2hEAIFhBK7hwlcmgbu7u0zhVE9PQHia3iICEUBgJAE3MyPp75+bb/vZ6fkyAeHpZUZaIIDAiQk4hDPN51umbymqhacUp+hEAIEhBBzCQ7AfnpRvhxEa4BkCwpPyQAABBJ7bJN966+KzM3klIjzleZakWHhKcotWBBB4dQLJh/BL2l/6/i3s2/Zb+7+meTNre00O5qohIDzVcDUqAggsQmDWQ3jLTwE+d3P2cH23//+UhffjzcrmqntmbYs8GqdehvB0avstHgEEXiKQdAg/p3Vv2HouXM38dmaSby/VoO/PR0B4ms8TihBAYCICSYfwFq2tbR8LT619R9qYoHEkH3MfIyA8HeOnNwIILE5g9kP4qZuhl2x57Cbq4U3SczdV3rZ7ia7vr05AeFrdYetDAIFDBNLC0+1in3prrfXD3962O1Q+Oi9KQHha1FjLQgCBPgTSwlPr55COhKfZmVydT9DYp0KNMoKA8DSCujkRQCCGwOyH8J637R5b01PrfOwn8G7f3msNbK9p+uy+vSYLc/UnIDz1Z2pEBBBYiMDsh3BleHrpdmpmNjNrW+jxOO1ShKfTWm/hCCDQQmD2Q3hreGq5Ybrn8lR4uv8w+Yw3Tk9pb/FaGwRaCQhPraS0QwCBUxKYNTw999Nwt0ZdQ85jgefhGLdB6Km39q5jzxyahKdTPqavvmjh6dWRmxABBJIIzBqekhiO0Mq3EdTPM6fwdB6vrRQBBHYQcAjvgDZBF75NYMLCEoSnhc21NAQQOE7AIXyc4YgR+DaC+nnmFJ7O47WVIoDADgIO4R3QJujCtwlMWFiC8LSwuZaGAALHCTiEjzMcMQLfRlA/z5zC03m8tlIEENhBYMtPte0YXpdCAgk/FVi4fEMXEhCeCuEaGgEE8gm4wcj0kG+ZvqWoFp5SnKITAQSGEHAID8F+eFK+HUZogGcICE/KAwEEEHhuk3zrrYhfCsnENwkITyqikoDwVEnX2AggEE/AIZxpId8yfUtRLTylOEUnAggMIeAQHoL98KR8O4zQAN62UwMIIIDAPgIO4X3cRvfi22gH1p7fzdPa/lodAggcJOAQPghwUHe+DQJ/kmmFp5MYbZkIILCPgEN4H7fRvfg22oG15xee1vbX6hBA4CABh/BBgIO6820Q+JNMKzydxGjLRACBfQQcwvu4je7Ft9EOrD2/8LS2v1aHAAIHCTiEDwIc1J1vg8CfZFrh6SRGWyYCCOwj4BDex210L76NdmDt+YWntf21OgQQOEjAIXwQ4KDufBsE/iTTCk8nMdoyEUBgHwGH8D5uo3vxbbQDa88vPK3tr9UhgMBBAg7hgwAHdefbIPAnmVZ4OonRlokAAvsIOIT3cRvdi2+jHVh7fuFpbX+tDgEEDhJwCB8EOKg73waBP8m0wtNJjLZMBBDYR8AhvI/b6F58G+3A2vMLT2v7a3UIIHCQgEP4IMBB3fk2CPxJphWeTmK0ZSKAwD4CDuF93Eb34ttoB9aeX3ha21+rQwCBgwQcwgcBDurOt0HgTzKt8HQSoy0TAQT2EXAI7+M2uhffRjuw9vzC09r+Wh0CCBwk4BA+CHBQd74NAn+SaYWnkxhtmQggsI+AQ3gft9G9+DbagbXnF57W9tfqEEDgIAGH8EGAg7rzbRD4k0wrPJ3EaMtEAIF9BBzC+7iN7sW30Q6sPb/wtLa/VocAAgcJOIQPAhzUnW+DwJ9kWuHpJEZbJgII7CPgEN7HbXQvvo12YO35hae1/bU6BBA4SMAhfBDgoO58GwT+JNMKTycx2jIRQGAfAYfwPm6je/FttANrzy88re2v1SGAwEECDuGDAAd159sg8CeZVng6idGWiQAC+wg4hPdxG92Lb6MdWHt+4Wltf60OAQQOEnAIHwQ4qDvfBoE/ybTC00mMtkwEENhHwCG8j9voXnwb7cDa8wtPa/trdQggcJCAQ/ggwEHd+TYI/EmmFZ5OYrRlIoDAPgIO4X3cRvfi22gH1p5feFrbX6tDAIGDBBzCBwEO6s63QeBPMq3wdBKjLRMBBPYRcAjv4za6F99GO7D2/MLT2v5aHQIIHCTgED4IcFB3vg0Cf5JphaeTGG2ZCCCwj4BDeB+30b34NtqBtecXntb21+oQQOAgAYfwQYCDuvNtEPiTTCs8ncRoy0QAgX0EHML7uI3uxbfRDqw9v/C0tr9WhwACBwk4hA8CHNSdb4PAn2Ra4ekkRlsmAgjsI+AQ3sdtdC++jXZg7fmFp7X9tToEEDhIwCF8EOCg7nwbBP4k0wpPJzHaMhFAYB8Bh/A+bqN78W20A2vPLzyt7a/VIYDAQQIO4YMAB3Xn2yDwJ5lWeDqJ0ZaJAAL7CDiE93Eb3Ytvox1Ye37haW1/rQ4BBA4ScAgfBDioO98GgT/JtMLTSYy2TAQQ2EfAIbyP2+hefBvtwNrzC09r+2t1CCBwkIBD+CDAQd35Ngj8SaYVnk5itGUigMA+Ag7hfdxG9+LbaAfWnl94Wttfq0MAgYMEHMIHAQ7qzrdB4E8yrfB0EqMtEwEE9hFwCO/jNroX30Y7sPb8wtPa/lodAggcJOAQPghwUHe+DQJ/kmmFp5MYbZkIILCPgEN4H7fRvfg22oG15xee1vbX6hBA4CABh/BBgIO6820Q+JNMKzydxGjLRACBfQSuh7CvTAJ3d3eZwqmenoDwNL1FBCKAAAIIIIDATASEp5ncoAUBBBBAAAEEpifw/wAXAwzsPhPdLwAAAABJRU5ErkJggg==" style=""><br><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在 UML 中，每个方框表示一个类，由类名说明。三角形 、矩形和五边形顶部的线段汇集在一起，指向形状，说明这些类都由形状继承而来。同样，从正方形指向矩形的箭头说明了它们之间的继承关系。</p></div><h3 style="" id="blogTitle183"><span style="font-weight: 700;">继承的实现方式</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">和其他功能一样，ECMAScript 实现继承的方式不止一种。这是因为 JavaScript 中的继承机制并不是明确规定的，而是通过模仿实现的。这意味着所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适用的继承方式。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">下面为您介绍几种具体的继承方式。</p><h4 id="blogTitle184"><span style="font-weight: 700;">对象冒充</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">构想原始的 ECMAScript 时，根本没打算设计对象冒充（object masquerading）。它是在开发者开始理解函数的工作方式，尤其是如何在函数环境中使用 this 关键字后才发展出来。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">其原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB：</p><pre>function ClassA(sColor) {
    this.color = sColor;
    this.sayColor = function () {
        alert(this.color);
    };
}

function ClassB(sColor) {
}
</pre><p>还记得吗？关键字 this 引用的是构造函数当前创建的对象。不过在这个方法中，this 指向的是所属的对象。这个原理是把 ClassA 作为常规函数来建立继承机制，而不是作为构造函数。如下使用构造函数 ClassB 可以实现继承机制：</p><pre>function ClassB(sColor) {
    this.newMethod = ClassA;
    this.newMethod(sColor);
    delete this.newMethod;
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法：</p><pre>function ClassB(sColor, sName) {
    this.newMethod = ClassA;
    this.newMethod(sColor);
    delete this.newMethod;

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">为证明前面的代码有效，可以运行下面的例子：</p><pre>var objA = new ClassA("blue");
var objB = new ClassB("red", "John");
objA.sayColor();    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "blue"</span>
objB.sayColor();    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "red"</span>
objB.sayName();     <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "John"</span><span style="font-weight: 700;">
</span></pre><h5 style="" id="blogTitle185"><span style="font-weight: 700;">对象冒充可以实现多重继承</span></h5><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">有趣的是，对象冒充可以支持多重继承。也就是说，一个类可以继承多个超类。用 UML 表示的多重继承机制如下图所示：</p><img src="data:image/png;base64,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"><br><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：</p><pre>function ClassZ() {
    this.newMethod = ClassX;
    this.newMethod();
    delete this.newMethod;

    this.newMethod = ClassY;
    this.newMethod();
    delete this.newMethod;
}
</pre><p class="tiy" style="margin-top: 12px; margin-bottom: 10px; padding: 6px 16px; border: none; line-height: 22.5px; display: inline-block; outline: 0px; vertical-align: middle; overflow: hidden; text-align: center; transition: 0.2s ease-out; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.118) 0px 1px 3px, rgba(0, 0, 0, 0.24) 0px 1px 2px;"><a target="_blank" href="http://www.w3school.com.cn/tiy/t.asp?f=jseg_pro_js_inheritance_implementing_object_masquerading" style="background-position: initial; margin: 0px; padding: 0px; border: 0px;">TIY</a></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。</p><h4 style="" id="blogTitle186"><span style="font-weight: 700;">call() 方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p><pre>function sayColor(sPrefix,sSuffix) {
    alert(sPrefix + this.color + sSuffix);
};

var obj = new Object();
obj.color = "blue";

sayColor.call(obj, "The color is ", "a very nice color indeed.");
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 "The color is blue, a very nice color indeed." 将被显示出来。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可：</p><pre>function ClassB(sColor, sName) {
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod = ClassA;</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod(color);</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//delete this.newMethod;</span>
    ClassA.call(this, sColor);

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre><p class="tiy" style="margin-top: 12px; margin-bottom: 10px; padding: 6px 16px; border: none; line-height: 22.5px; display: inline-block; outline: 0px; vertical-align: middle; overflow: hidden; text-align: center; transition: 0.2s ease-out; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.118) 0px 1px 3px, rgba(0, 0, 0, 0.24) 0px 1px 2px;"><a target="_blank" href="http://www.w3school.com.cn/tiy/t.asp?f=jseg_pro_js_inheritance_implementing_call" style="background-position: initial; margin: 0px; padding: 0px; border: 0px;">TIY</a></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。</p><h4 id="blogTitle187"><span style="font-weight: 700;">apply() 方法</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p><pre>function sayColor(sPrefix,sSuffix) {
    alert(sPrefix + this.color + sSuffix);
};

var obj = new Object();
obj.color = "blue";

sayColor.apply(obj, new Array("The color is ", "a very nice color indeed."));
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 "The color is blue, a very nice color indeed."，将被显示出来。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">该方法也用于替换前三行的赋值、调用和删除新方法的代码：</p><pre>function ClassB(sColor, sName) {
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod = ClassA;</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod(color);</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//delete this.newMethod;</span>
    ClassA.apply(this, new Array(sColor));

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法：</p><pre>function ClassB(sColor, sName) {
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod = ClassA;</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//this.newMethod(color);</span>
    <span style="margin: 0px; padding: 0px; border: 0px;">//delete this.newMethod;</span>
    ClassA.apply(this, arguments);

    this.name = sName;
    this.sayName = function () {
        alert(this.name);
    };
}
</pre><p class="tiy" style="margin-top: 12px; margin-bottom: 10px; padding: 6px 16px; border: none; line-height: 22.5px; display: inline-block; outline: 0px; vertical-align: middle; overflow: hidden; text-align: center; transition: 0.2s ease-out; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.118) 0px 1px 3px, rgba(0, 0, 0, 0.24) 0px 1px 2px;"><a target="_blank" href="http://www.w3school.com.cn/tiy/t.asp?f=jseg_pro_js_inheritance_implementing_apply" style="background-position: initial; margin: 0px; padding: 0px; border: 0px;">TIY</a></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。</p><h4 style="" id="blogTitle188"><span style="font-weight: 700;">原型链（prototype chaining）</span></h4><div><b>原型链继承的本质就是通过 __proto__ 指针指向某个对象，系统能够自动链式访问所指向的对象的属性和方法</b></div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">继承这种形式在 ECMAScript 中原本是用于原型链的。上一章介绍了定义类的原型方式。原型链扩展了这种方式，以一种有趣的方式实现继承机制。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在上一章学过，prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">如果用原型方式重定义前面例子中的类，它们将变为下列形式：</p><pre>function ClassA() {
}

ClassA.prototype.color = "blue";
ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB() {
}

<font color="#0000dd" face="Consolas, Courier New, Courier, monospace"><span style="border-style: initial; border-color: initial; border-image: initial;">ClassB.prototype = new ClassA();</span></font>
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">原型方式的神奇之处在于突出显示的蓝色代码行。这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们赋给&nbsp;ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？</p><p class="important" style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><span style="margin: 0px; padding: 0px; border: 0px;">注意：</span>调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">与对象冒充相似，子类的所有属性和方法都必须出现在 prototype 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：</p><pre>function ClassB() {
}

ClassB.prototype = new ClassA();

ClassB.prototype.name = "";
ClassB.prototype.sayName = function () {
    alert(this.name);
};
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">可通过运行下面的例子测试这段代码：</p><pre>var objA = new ClassA();
var objB = new ClassB();
objA.color = "blue";
objB.color = "red";
objB.name = "John";
objA.sayColor();
objB.sayColor();
objB.sayName();
</pre><p class="tiy" style="margin-top: 12px; margin-bottom: 10px; padding: 6px 16px; border: none; line-height: 22.5px; display: inline-block; outline: 0px; vertical-align: middle; overflow: hidden; text-align: center; transition: 0.2s ease-out; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.118) 0px 1px 3px, rgba(0, 0, 0, 0.24) 0px 1px 2px;"><a target="_blank" href="http://www.w3school.com.cn/tiy/t.asp?f=jseg_pro_js_inheritance_implementing_prototype_chaining" style="background-position: initial; margin: 0px; padding: 0px; border: 0px;">TIY</a></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">此外，在原型链中，instanceof 运算符的运行方式也很独特。对 ClassB 的所有实例，instanceof 为 ClassA 和 ClassB 都返回 true。例如：</p><pre>var objB = new ClassB();
alert(objB instanceof ClassA);  <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "true"</span>
alert(objB instanceof ClassB);  <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "true"</span>
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在 ECMAScript 的弱类型世界中，这是极其有用的工具，不过使用对象冒充时不能使用它。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">原型链的弊端是不支持多重继承。记住，原型链会用另一类型的对象重写类的 prototype 属性。</p><h4 style="" id="blogTitle189"><span style="font-weight: 700;">混合方式</span></h4><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">这种继承方式使用构造函数定义类，并非使用任何原型。对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在前一章，我们曾经讲解过创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法。用这两种方式重写前面的例子，代码如下：</p><pre>function ClassA(sColor) {
    this.color = sColor;
}

ClassA.prototype.sayColor = function () {
    alert(this.color);
};

function ClassB(sColor, sName) {
    <font color="#0000dd" face="Consolas, Courier New, Courier, monospace"><span style="border-style: initial; border-color: initial; border-image: initial;">ClassA.call(this, sColor);</span></font>
    this.name = sName;
}

<font color="#0000dd" face="Consolas, Courier New, Courier, monospace"><span style="border-style: initial; border-color: initial; border-image: initial;">ClassB.prototype = new ClassA();</span></font>

ClassB.prototype.sayName = function () {
    alert(this.name);
};
</pre><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">在此例子中，继承机制由两行突出显示的蓝色代码实现。在第一行突出显示的代码中，在 ClassB 构造函数中，用对象冒充继承 ClassA 类的 sColor 属性。在第二行突出显示的代码中，用原型链继承 ClassA 类的方法。由于这种混合方式使用了原型链，所以 instanceof 运算符仍能正确运行。</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">下面的例子测试了这段代码：</p><pre>var objA = new ClassA("blue");
var objB = new ClassB("red", "John");
objA.sayColor();    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "blue"</span>
objB.sayColor();    <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "red"</span>
objB.sayName(); <span style="margin: 0px; padding: 0px; border: 0px;">//输出 "John"</span></pre></div><h2 style="" id="blogTitle190"><b>多态</b></h2><h2 style="" id="blogTitle191"><b>原型与原型链</b></h2><div><b>原型规则是学习原型链的基础</b></div><h3 id="blogTitle192"><b>5 条原型规则</b></h3><div><ol><li>除了 null，所有的引用类型（数组、对象、函数等），都具有对象特性，即可自由扩展属性<br></li><li><b>除了 null，所有的引用类型（数组、对象、函数等），都具有 __proto__（隐式原型）属性，属性值是一个普通的对象</b><br></li><li>所有函数，都有一个 prototype（显式原型）属性，属性值是一个普通的对象<br></li><li><b>除了 null，所有的引用类型（数组、对象、函数等），其 __proto__ 属性值指向其构造函数的 prototype 属性值（指向即完全等于）</b><br></li><li>当试图得到一个引用类型的某个属性时，如果该引用类型本身没有这个属性，那么会去它的 __proto__ 属性（即它的构造函数的 prototype 属性）中寻找<br></li><li><b>Object.prototype 对象的 __proto__ 属性值强制规定为 null，原因是为了避免原型链出现死循环。</b></li></ol></div><h3 style="" id="blogTitle193"><b>JS 对象原型链的指向问题</b></h3><div><b><font color="#ff0000" style="background-color: yellow;">构造函数包含内置对象，构造函数也是对象</font></b></div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><img src="data:image/png;base64,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"><br></p><div><h3 style="margin-top: 25px;" id="blogTitle194"><span style="font-weight: 700;">原型链</span></h3><div><div>理解原型链的概念</div><div>理解属性的搜索机制</div></div><div><br></div><div>既然实例不拷贝原型中的属性方法，如何访问到其属性呢?</div><div><br></div><div>JS 中的对象是由两个独立的对象组成的，一个是构造函数对象，另一个是原型对象，这两个对象之间是通过原型链（__proto__ 属性）链接在一起的。</div><h4 id="blogTitle195"><span style="font-weight: 700;">属性访问搜索法则</span></h4><div><ul><li>系统首先在自定义函数（对象）A 中寻找，</li><li>如果没找到，根据 __proto__ 找到其指向的对象 B，</li><li>然后遍历其 B 属性，如果没找到，则检查 B 的 __proto__，</li><li>如果 B 的 __proto__ 不为 null，则找到其指向的对象 C，并遍历其属性继续寻找，直到 __proto__ 为 null .搜索结束</li></ul><div><p style="margin-top: 7.68pt; margin-bottom: 0pt; margin-left: 0in; direction: ltr; unicode-bidi: embed; word-break: normal;"><span style="font-weight: 700;">停止条件：</span></p><p style="margin-top: 5.76pt; margin-bottom: 0pt; margin-left: 0.5in; direction: ltr; unicode-bidi: embed; word-break: normal;">系统已经设计好，Object.prototype 对象的 __proto__ 为 null，是所有链式属性搜索的终点</p><p style="margin-top: 5.76pt; margin-bottom: 0pt; margin-left: 0.5in; direction: ltr; unicode-bidi: embed; word-break: normal;"><br></p></div><div><div><span style="font-weight: 700;"><font color="#ff0000">属性搜索机制的底层就是通过 __proto__ 属性链接起来的。</font></span></div><div><span style="font-weight: 700;"><font color="#ff0000">所以 __proto__ 是面向对象的底层实现机制，是理解面向对象本质所在。</font></span></div></div></div><div><br></div><h4 id="blogTitle196"><span style="font-weight: 700;">属性屏蔽理论 - 构造函数中和原型对象中存在相同属性的问题</span></h4><div><span style="font-weight: 700;">如果构造函数中和原型对象中存在相同属性的话：</span></div><div><ul><li><span style="font-weight: 700;">用属性搜索法则寻找出访问属性的链条</span><br></li><li><span style="font-weight: 700;">一旦</span>搜索所需属性到即返回，后面的相同属性会被屏蔽掉（并不是删除）。</li></ul></div><h4 id="blogTitle197"><span style="font-weight: 700;">如何访问原型中被屏蔽掉的属性</span></h4><div><span style="font-weight: 700;">方法一：使用 delete，删除构造函数中与原型对象同名的属性，再用简化的点语法格式访问该属性</span></div><div><span style="font-weight: 700;">方法二：直接用原型对象属性的完整写法来获取，如：实例名.prototype.属性或方法名</span></div><h4 id="blogTitle198"><span style="font-weight: 700;">构造属性和原型属性判断</span></h4><h4 id="blogTitle199"><span style="font-weight: 700;">实例属性和原型属性或构造属性判断</span></h4><div><div>hasOwnProperty() 方法</div><div>可以判定一个属性是存在于构造对象的实例上还是原型对象或构造函数上。该方法继承自 Object。</div><div>如果是实例对象 - true</div><div>如果是原型对象 - false</div></div><div><pre style="background-color: rgb(39, 40, 34); font-size: 10.5pt; font-family: &quot;Source Code Pro&quot;; color: rgb(248, 248, 242);">let <span style="color: rgb(166, 226, 46);">Person </span><span style="color: rgb(249, 38, 114);">= function </span>() {<br>    age <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(174, 129, 255);">1<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span><span style="color: rgb(166, 226, 46);">Person</span>.prototype <span style="color: rgb(249, 38, 114);">= </span>{<br>    name<span style="color: rgb(249, 38, 114);">: </span><span style="color: rgb(230, 219, 116);">'foo'<br></span>}<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span>let <span style="font-style: italic;">xiaowang </span><span style="color: rgb(249, 38, 114);">= new </span><span style="color: rgb(166, 226, 46);">Person</span>()<span style="color: rgb(92, 122, 184);">;<br></span><span style="color: rgb(92, 122, 184);"><br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">"name"</span>))<span style="color: rgb(92, 122, 184);">;</span><span style="color: rgb(11, 139, 21);">//false --</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">不是实例自定义的属性，而是原型对象属性<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">"age"</span>))<span style="color: rgb(92, 122, 184);">; </span><span style="color: rgb(11, 139, 21);">//false --</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">不是实例自定义的属性，而是构造函数内定义的属性<br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(11, 139, 21); font-family: SimSun;"><br></span><span style="color: rgb(11, 139, 21);">//</span><span style="color: rgb(11, 139, 21); font-family: SimSun;">当定义一个实例化属性之后，会自动屏蔽原型属性<br></span><span style="font-style: italic;">xiaowang</span>.name <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'foo'<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">'name'</span>)) <span style="color: rgb(11, 139, 21);">//true<br></span><span style="color: rgb(11, 139, 21);"><br></span><span style="font-style: italic;">xiaowang</span>.sex <span style="color: rgb(249, 38, 114);">= </span><span style="color: rgb(230, 219, 116);">'nan'<br></span>console.<span style="color: rgb(166, 226, 46);">log</span>(<span style="font-style: italic;">xiaowang</span>.<span style="color: rgb(166, 226, 46);">hasOwnProperty</span>(<span style="color: rgb(230, 219, 116);">'sex'</span>)) <span style="color: rgb(11, 139, 21);">//true</span></pre></div></div><h3 style="" id="blogTitle200"><span style="font-weight: 700;">构造函数实例的 __proto__ 指向</span></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">__proto__：构造函数实例 --→ （构造函数.prototype） --→ Object.prototype --→ null<br></p><pre style="margin-top: 12px; margin-bottom: 0px; padding: 0px; font-size: 14px; line-height: 22.5px; border: 0px;">var obj = {name: 'jack'}<br>var arr = [1,2,3]<br>var reg = /hello/g<br>var date = new Date<br>var err = new Error('exception')<br>&nbsp;<br>console.log(obj.__proto__ === Object.prototype) // true<br>console.log(arr.__proto__ === Array.prototype) &nbsp;// true<br>console.log(reg.__proto__ === RegExp.prototype) // true<br>console.log(date.__proto__ === Date.prototype) &nbsp;// true<br>console.log(err.__proto__ === Error.prototype) &nbsp;// true</pre><div><h3 id="blogTitle201"><b style="font-size: 24px;">构造函数的 __proto__ 指向</b></h3></div><div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">__proto__：构造函数 --→ Function.prototype --→ Object.prototype --→ null</p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><br></p><div><div>Object对象就是Function对象的实例</div><div>表示Object底层是是通过函数实现的</div></div><div><br></div><div>所有构造函数都是Function对象的实例</div></div><pre style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">Number.__proto__ === Function.prototype &nbsp;// true<br>Boolean.__proto__ === Function.prototype // true<br>String.__proto__ === Function.prototype &nbsp;// true<br>Object.__proto__ === Function.prototype &nbsp;// true<br>Function.__proto__ === Function.prototype// true&nbsp;<br>Array.__proto__ === Function.prototype &nbsp; // true<br>RegExp.__proto__ === Function.prototype &nbsp;// true<br>Error.__proto__ === Function.prototype &nbsp; // true<br>Date.__proto__ === Function.prototype &nbsp; &nbsp;// true</pre><div><br></div><h3 style="" id="blogTitle202"><b>构造函数原型对象的</b>&nbsp;<span style="font-weight: 700;">__proto__ 指向</span></h3><div><br></div><div>__proto__：（构造函数.prototype） --→ Object.prototype --→ null<br></div><div><br></div><h3 style="" id="blogTitle203"><b>Object 和 Function 谁是鼻祖？</b></h3><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">Object.prototype 是一切链式循环的终点<br></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;">Function.prototype 是一切函数和内置对象的原型对象<br></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><br></p><h2 id="blogTitle204"><b>面向对象认识&nbsp;JS 世界</b></h2><p><b>整个 JS 其实全是对象</b></p><h3 id="blogTitle205"><b>内置</b><span style="font-weight: 700;">（built-in）</span><b>对象</b></h3><p></p><ul><li><b>Number&nbsp;</b><br></li><li><b>String</b><br></li><li><b>Boolean</b><br></li><li><b>Date&nbsp;</b><br></li><li><b>Object&nbsp;</b><br></li><li><b>Function&nbsp;</b><br></li><li><b>RegExp&nbsp;</b><br></li><li><b>Array&nbsp;</b><br></li><li><b>Cookie&nbsp;</b><br></li><li><b>Session&nbsp;</b><br></li><li><b>Error</b><br></li></ul><p></p><h3 id="blogTitle206"><b>BOM（browser object model）</b></h3><div><b>整体上把握什么是 BOM</b></div><div><b>理解 window 窗口是如何用面向对象分析的</b></div><div><b>理解 window 窗口对象的基本属性，对象属性和方法</b></div><p></p><ul><li><b>window&nbsp;</b><br></li><ul><li><b>任何我们定义的全局变量、全局函数、全局对象等都会成为 window 对象的属性</b></li></ul><li><b>location&nbsp;</b><br></li><li><b>history&nbsp;</b><br></li><li><b>navigator&nbsp;</b><br></li><li><b>document&nbsp;</b><br></li><li><b>console&nbsp;</b><br></li><li><b>screen</b><br></li></ul><p></p><div><h3 style="margin-top: 25px;" id="blogTitle207"><span style="font-weight: 700;">自定义对象</span></h3></div><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><br></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><br></p><p style="margin-top: 12px; margin-bottom: 0px; padding: 0px; border: 0px; line-height: 22.5px;"><br></p><div><br></div>
</article>
{% endblock point1 %}